
#ifndef DOXYGEN

#if defined MAXON_COMPILER_GCC
	#pragma GCC diagnostic push
	#if MAXON_COMPILER_GCC >= 600
		#pragma GCC diagnostic ignored "-Wmisleading-indentation"
	#endif
#endif

#if 1
namespace py
{
#ifdef MAXON_TARGET_WINDOWS
#endif

	struct PythonErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if constexpr (!S::Implementation::PROXY)
				{
					if (!(Super0::InitMTablesWithBases(info, offset))) return false;
				}
				auto* vt = (PythonErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonErrorInterface::_interface); if (!vt) return false;
				return true;
			}
		};

	};

	auto PythonErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonErrorInterface() { new (s_ui_maxon_py_PythonErrorInterface) maxon::EntityUse(PythonErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonErrorInterface(PythonErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct PythonTracebackErrorInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetUrl);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetUrl);
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		PRIVATE_MAXON_MF_POINTER(PythonTracebackErrorInterface_SetUrl, SetUrl, true, maxon::GenericComponent,, (void), const Url& url);
		maxon::Int PythonTracebackErrorInterface_SetUrl_Offset;
		PRIVATE_MAXON_MF_POINTER(PythonTracebackErrorInterface_GetUrl, GetUrl, true, maxon::GenericComponent, const, (const Url&));
		maxon::Int PythonTracebackErrorInterface_GetUrl_Offset;
		PRIVATE_MAXON_MF_POINTER(PythonTracebackErrorInterface_SetLineNumber, SetLineNumber, true, maxon::GenericComponent,, (void), Int line);
		maxon::Int PythonTracebackErrorInterface_SetLineNumber_Offset;
		PRIVATE_MAXON_MF_POINTER(PythonTracebackErrorInterface_GetLineNumber, GetLineNumber, true, maxon::GenericComponent, const, (Int));
		maxon::Int PythonTracebackErrorInterface_GetLineNumber_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, SetUrl))
		{
			maxon::Tie(PythonTracebackErrorInterface_SetUrl, PythonTracebackErrorInterface_SetUrl_Offset) = PythonTracebackErrorInterface_SetUrl_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, GetUrl))
		{
			maxon::Tie(PythonTracebackErrorInterface_GetUrl, PythonTracebackErrorInterface_GetUrl_Offset) = PythonTracebackErrorInterface_GetUrl_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, SetLineNumber))
		{
			maxon::Tie(PythonTracebackErrorInterface_SetLineNumber, PythonTracebackErrorInterface_SetLineNumber_Offset) = PythonTracebackErrorInterface_SetLineNumber_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, GetLineNumber))
		{
			maxon::Tie(PythonTracebackErrorInterface_GetLineNumber, PythonTracebackErrorInterface_GetLineNumber_Offset) = PythonTracebackErrorInterface_GetLineNumber_GetPtr<W>(offset, true);
		}
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonTracebackErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonTracebackErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonTracebackErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetLineNumber);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetUrl);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetLineNumber);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetUrl);
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if constexpr (!S::Implementation::PROXY)
				{
					if (!(Super0::InitMTablesWithBases(info, offset))) return false;
				}
				auto* vt = (PythonTracebackErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonTracebackErrorInterface::_interface); if (!vt) return false;
				vt->template Init<CWrapper>(offset);
				return true;
			}
			PRIVATE_MAXON_MF_WRAPPER(PythonTracebackErrorInterface_SetUrl, maxon::GenericComponent,, (void), const Url& url) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->SetUrl(url); }
			PRIVATE_MAXON_MF_WRAPPER(PythonTracebackErrorInterface_GetUrl, maxon::GenericComponent, const, (const Url&)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetUrl(); }
			PRIVATE_MAXON_MF_WRAPPER(PythonTracebackErrorInterface_SetLineNumber, maxon::GenericComponent,, (void), Int line) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->SetLineNumber(line); }
			PRIVATE_MAXON_MF_WRAPPER(PythonTracebackErrorInterface_GetLineNumber, maxon::GenericComponent, const, (Int)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetLineNumber(); }
		};

	};
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetUrl(const Url& url) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_SetUrl_Offset), mt_.PythonTracebackErrorInterface_SetUrl, url);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetUrl() const -> const Url&
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_GetUrl_Offset), mt_.PythonTracebackErrorInterface_GetUrl);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetLineNumber(Int line) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset), mt_.PythonTracebackErrorInterface_SetLineNumber, line);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetLineNumber() const -> Int
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_GetLineNumber_Offset), mt_.PythonTracebackErrorInterface_GetLineNumber);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::Fn<S>::SetUrl(const Url& url) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetUrl_Offset), mt_.PythonTracebackErrorInterface_SetUrl, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::COWFn<S>::SetUrl(const Url& url) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetUrl_Offset), mt_.PythonTracebackErrorInterface_SetUrl, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::ConstFn<S>::GetUrl() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const Url&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_GetUrl_Offset), mt_.PythonTracebackErrorInterface_GetUrl));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::Fn<S>::SetLineNumber(Int line) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset), mt_.PythonTracebackErrorInterface_SetLineNumber, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::COWFn<S>::SetLineNumber(Int line) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset), mt_.PythonTracebackErrorInterface_SetLineNumber, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::ConstFn<S>::GetLineNumber() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_GetLineNumber_Offset), mt_.PythonTracebackErrorInterface_GetLineNumber));
	}
	auto PythonTracebackErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonTracebackErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonTracebackErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonTracebackErrorInterface() { new (s_ui_maxon_py_PythonTracebackErrorInterface) maxon::EntityUse(PythonTracebackErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonTracebackErrorInterface(PythonTracebackErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct PythonSystemExitErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonSystemExitErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonSystemExitErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonSystemExitErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if constexpr (!S::Implementation::PROXY)
				{
					if (!(Super0::InitMTablesWithBases(info, offset))) return false;
				}
				auto* vt = (PythonSystemExitErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonSystemExitErrorInterface::_interface); if (!vt) return false;
				return true;
			}
		};

	};

	auto PythonSystemExitErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonSystemExitErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonSystemExitErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonSystemExitErrorInterface() { new (s_ui_maxon_py_PythonSystemExitErrorInterface) maxon::EntityUse(PythonSystemExitErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonSystemExitErrorInterface(PythonSystemExitErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct CPythonLibraryInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(AssociateDataTypeWithPythonTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_FromBool);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallable_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallerContext_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCode_Addr2Line);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyData_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Contains);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Copy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Items);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Keys);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Values);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_ExceptionMatches);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Fetch);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_NormalizeException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Occurred);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Print);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Restore);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetNone);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrno);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrnoAndFilename);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_AcquireThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_EvalCode);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_GetBuiltins);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_InitThreads);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ReleaseThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_RestoreThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_SaveThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ThreadsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ArithmeticError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AssertionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AttributeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BaseException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BufferError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BytesWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_DeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EOFError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EnvironmentError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Exception);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FloatingPointError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FutureWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_GeneratorExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IOError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndentationError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndexError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyboardInterrupt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_LookupError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NameError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NotImplementedError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OSError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OverflowError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_PendingDeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ReferenceError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StandardError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StopIteration);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TabError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TypeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnboundLocalError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeDecodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeEncodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeTranslateError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UserWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ValueError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Warning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_WindowsError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ZeroDivisionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExceptionClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_AsFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGC_Collect);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGILState_GetThisThreadState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Ensure);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Release);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyId_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_GetImporter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_GetModuleDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_ImportModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInternedId_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyIter_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Append);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_AsTuple);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Insert);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Reverse);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Sort);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyMem_SetAllocator);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyMemoryView_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddIntConstant);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Create);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNullImporter_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNumber_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_AsData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Call);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_CallFunction);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Dir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_FromGeneric);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemInt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetIter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_HasAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Hash);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_IsTrue);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Length);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Not);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Repr);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_RichCompare);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Str);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_TypeCheck);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_FileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_InteractiveLoopFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleFileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySite_AddSiteDir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySlice_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySuper_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetArgvEx);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_Swap);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_FastSubclass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_GetName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_HasFeature);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_IsSubtype);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Ready);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_AsCString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_AsString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_FromString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_FromStringAndSize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_GetLength);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_BytesWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_CompileStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DebugFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Decref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DontWriteBytecodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_False);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Finalize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_FrozenFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetBuildInfo);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCompiler);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCopyright);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPlatform);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetVersion);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IgnoreEnvironmentFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Incref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Initialize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InspectFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InteractiveFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoSiteFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoUserSiteDirectory);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_None);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NotImplemented);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_OptimizeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeDecref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeIncref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_True);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_VerboseFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ConvertAndCacheString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CreateGlobalDictionary);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ExecuteModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(FopenNative);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Free);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetAssociatedDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyCodeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyFrameRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTracebackRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConverterPyObject_FromData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCurrentTraceback);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetDll);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetGilState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyCallerContextRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyClassRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyFunctionRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyHashMapRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyMemberRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetRegisteredTypesWithConversions);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Init);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitBuiltinModules);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(LastPythonCallFailed);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyClass_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_GetDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyFunction_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyHashMap_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyMember_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MaxonConvertAuto);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ParseDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateGetCurrentCallerContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateRegisterBuiltinConverter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterComponentProxy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecificPythonClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackDataType);
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_Init, Init, true, maxon::GenericComponent,, (Result<void>), const Url& librarypath, Bool createSubLibrary);
		maxon::Int CPythonLibraryInterface_Init_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_InitTypes, InitTypes, true, maxon::GenericComponent,, (Result<void>));
		maxon::Int CPythonLibraryInterface_InitTypes_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_InitBuiltinModules, InitBuiltinModules, true, maxon::GenericComponent,, (Result<void>));
		maxon::Int CPythonLibraryInterface_InitBuiltinModules_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_Initialize, CPy_Initialize, true, maxon::GenericComponent,, (void));
		maxon::Int CPythonLibraryInterface_CPy_Initialize_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_Finalize, CPy_Finalize, true, maxon::GenericComponent,, (void));
		maxon::Int CPythonLibraryInterface_CPy_Finalize_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_Create, CPyModule_Create, true, maxon::GenericComponent,, (CPyRef), const ModuleDefinition& module);
		maxon::Int CPythonLibraryInterface_CPyModule_Create_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_Free, Free, true, maxon::GenericComponent,, (void), const Delegate<void()>& shutdownEngine);
		maxon::Int CPythonLibraryInterface_Free_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetDll, GetDll, true, maxon::GenericComponent, const, (const PythonDll&));
		maxon::Int CPythonLibraryInterface_GetDll_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_FopenNative, FopenNative, true, maxon::GenericComponent,, (FILE_native*), const Char* name, const Char* mode);
		maxon::Int CPythonLibraryInterface_FopenNative_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_LastPythonCallFailed, LastPythonCallFailed, true, maxon::GenericComponent,, (Error), const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError);
		maxon::Int CPythonLibraryInterface_LastPythonCallFailed_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_RegisterComponentProxy, RegisterComponentProxy, true, maxon::GenericComponent,, (Result<MPyDataRef>), const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject);
		maxon::Int CPythonLibraryInterface_RegisterComponentProxy_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_IsInitialized, CPy_IsInitialized, true, maxon::GenericComponent,, (Bool));
		maxon::Int CPythonLibraryInterface_CPy_IsInitialized_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetVersion, CPy_GetVersion, true, maxon::GenericComponent,, (const Char*));
		maxon::Int CPythonLibraryInterface_CPy_GetVersion_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetPlatform, CPy_GetPlatform, true, maxon::GenericComponent,, (const Char*));
		maxon::Int CPythonLibraryInterface_CPy_GetPlatform_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetCopyright, CPy_GetCopyright, true, maxon::GenericComponent,, (const Char*));
		maxon::Int CPythonLibraryInterface_CPy_GetCopyright_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetCompiler, CPy_GetCompiler, true, maxon::GenericComponent,, (const Char*));
		maxon::Int CPythonLibraryInterface_CPy_GetCompiler_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetBuildInfo, CPy_GetBuildInfo, true, maxon::GenericComponent,, (const Char*));
		maxon::Int CPythonLibraryInterface_CPy_GetBuildInfo_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_SetProgramName, CPy_SetProgramName, true, maxon::GenericComponent,, (Result<void>), const String& name);
		maxon::Int CPythonLibraryInterface_CPy_SetProgramName_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_SetPythonHome, CPy_SetPythonHome, true, maxon::GenericComponent,, (Result<void>), const Url& name);
		maxon::Int CPythonLibraryInterface_CPy_SetPythonHome_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetProgramName, CPy_GetProgramName, true, maxon::GenericComponent,, (String));
		maxon::Int CPythonLibraryInterface_CPy_GetProgramName_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_GetPythonHome, CPy_GetPythonHome, true, maxon::GenericComponent,, (String));
		maxon::Int CPythonLibraryInterface_CPy_GetPythonHome_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_ExecuteModule, ExecuteModule, true, maxon::GenericComponent,, (Bool), const String& name);
		maxon::Int CPythonLibraryInterface_ExecuteModule_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCallerContext_New, CPyCallerContext_New, true, maxon::GenericComponent,, (MPyCallerContextRef));
		maxon::Int CPythonLibraryInterface_CPyCallerContext_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyRun_SimpleFileExFlags, CPyRun_SimpleFileExFlags, true, maxon::GenericComponent,, (Bool), FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, CPyRun_SimpleFileExFlags, true, maxon::GenericComponent,, (Bool), const Url& url, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyRun_SimpleStringFlags, CPyRun_SimpleStringFlags, true, maxon::GenericComponent,, (CPyRef), const String& code, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyRun_FileExFlags, CPyRun_FileExFlags, true, maxon::GenericComponent,, (NativePyObject*), FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_FileExFlags_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, CPyRun_InteractiveLoopFlags, true, maxon::GenericComponent,, (Result<void>), FILE* fp, const Char* filename, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyGilState_Ensure, CPyGilState_Ensure, true, maxon::GenericComponent,, (PYGILSTATE));
		maxon::Int CPythonLibraryInterface_CPyGilState_Ensure_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyGilState_Release, CPyGilState_Release, true, maxon::GenericComponent,, (void), PYGILSTATE state);
		maxon::Int CPythonLibraryInterface_CPyGilState_Release_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetGilState, GetGilState, true, maxon::GenericComponent, const, (GILSTATE));
		maxon::Int CPythonLibraryInterface_GetGilState_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyGILState_GetThisThreadState, CPyGILState_GetThisThreadState, true, maxon::GenericComponent,, (NativePyThreadState*));
		maxon::Int CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyThreadState_Swap, CPyThreadState_Swap, true, maxon::GenericComponent,, (NativePyThreadState*), NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyThreadState_Swap_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyThreadState_GetDict, CPyThreadState_GetDict, true, maxon::GenericComponent,, (CPyRef));
		maxon::Int CPythonLibraryInterface_CPyThreadState_GetDict_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_CompileStringFlags, CPy_CompileStringFlags, true, maxon::GenericComponent,, (CPyCodeRef), const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPy_CompileStringFlags_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_Incref, CPy_Incref, true, maxon::GenericComponent, const, (void), NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_Incref_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_Decref, CPy_Decref, true, maxon::GenericComponent, const, (void), NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_Decref_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_SafeIncref, CPy_SafeIncref, true, maxon::GenericComponent, const, (void), NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_SafeIncref_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_SafeDecref, CPy_SafeDecref, true, maxon::GenericComponent, const, (void), NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_SafeDecref_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyGC_Collect, CPyGC_Collect, true, maxon::GenericComponent,, (Int64));
		maxon::Int CPythonLibraryInterface_CPyGC_Collect_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCode_Addr2Line, CPyCode_Addr2Line, true, maxon::GenericComponent,, (Int32), const CPyCodeRef& codeObject, Int32 x);
		maxon::Int CPythonLibraryInterface_CPyCode_Addr2Line_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_UnpackDataType, UnpackDataType, true, maxon::GenericComponent,, (CPyRef), const CPyRef& obj);
		maxon::Int CPythonLibraryInterface_UnpackDataType_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_UnpackData, UnpackData, true, maxon::GenericComponent,, (CPyRef), const CPyRef& obj);
		maxon::Int CPythonLibraryInterface_UnpackData_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_None, CPy_None, true, maxon::GenericComponent, const, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPy_None_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_True, CPy_True, true, maxon::GenericComponent, const, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPy_True_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_False, CPy_False, true, maxon::GenericComponent, const, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPy_False_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_NotImplemented, CPy_NotImplemented, true, maxon::GenericComponent, const, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPy_NotImplemented_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_Print, CPyErr_Print, true, maxon::GenericComponent,, (void));
		maxon::Int CPythonLibraryInterface_CPyErr_Print_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_Clear, CPyErr_Clear, true, maxon::GenericComponent,, (void));
		maxon::Int CPythonLibraryInterface_CPyErr_Clear_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_Occurred, CPyErr_Occurred, true, maxon::GenericComponent,, (Bool), CPyRef* type);
		maxon::Int CPythonLibraryInterface_CPyErr_Occurred_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_SetString, CPyErr_SetString, true, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, const Char* errorString);
		maxon::Int CPythonLibraryInterface_CPyErr_SetString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, CPyErr_SetWithErrnoAndFilename, true, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, Int32 errorNumber, const Char* filename);
		maxon::Int CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_SetWithErrno, CPyErr_SetWithErrno, true, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, Int32 errorNumber);
		maxon::Int CPythonLibraryInterface_CPyErr_SetWithErrno_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_SetString_1, CPyErr_SetString, true, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, const String& errorString);
		maxon::Int CPythonLibraryInterface_CPyErr_SetString_1_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_SetNone, CPyErr_SetNone, true, maxon::GenericComponent,, (void), const CPyRef& errorType);
		maxon::Int CPythonLibraryInterface_CPyErr_SetNone_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_Fetch, CPyErr_Fetch, true, maxon::GenericComponent,, (void), CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_Fetch_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_NormalizeException, CPyErr_NormalizeException, true, maxon::GenericComponent,, (void), CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_NormalizeException_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_Restore, CPyErr_Restore, true, maxon::GenericComponent,, (void), const CPyRef& type, const CPyRef& value, const CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_Restore_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyErr_ExceptionMatches, CPyErr_ExceptionMatches, true, maxon::GenericComponent,, (Bool), const CPyRef& exc);
		maxon::Int CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExceptionClass_Check, CPyExceptionClass_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyExceptionClass_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_New, CPyCapsule_New, true, maxon::GenericComponent, const, (CPyRef), void* pointer, const Char* name, CPyCapsule_Destructor* destructor);
		maxon::Int CPythonLibraryInterface_CPyCapsule_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_SetPointer, CPyCapsule_SetPointer, true, maxon::GenericComponent,, (Bool), const CPyRef& capsule, void* pointer);
		maxon::Int CPythonLibraryInterface_CPyCapsule_SetPointer_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_GetPointer, CPyCapsule_GetPointer, true, maxon::GenericComponent,, (void*), const CPyRef& capsule, const Char* name);
		maxon::Int CPythonLibraryInterface_CPyCapsule_GetPointer_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_GetContext, CPyCapsule_GetContext, true, maxon::GenericComponent,, (void*), const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_CPyCapsule_GetContext_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_SetContext, CPyCapsule_SetContext, true, maxon::GenericComponent,, (Bool), const CPyRef& capsule, void* context);
		maxon::Int CPythonLibraryInterface_CPyCapsule_SetContext_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_CheckExact, CPyCapsule_CheckExact, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyCapsule_CheckExact_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTraceBack_Check, CPyTraceBack_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyTraceBack_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyClass_Check, CPyClass_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyClass_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_New, CPyTuple_New, true, maxon::GenericComponent, const, (CPyRef), UInt size);
		maxon::Int CPythonLibraryInterface_CPyTuple_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_Size, CPyTuple_Size, true, maxon::GenericComponent,, (UInt), const CPyRef& tuple);
		maxon::Int CPythonLibraryInterface_CPyTuple_Size_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_GetItem, CPyTuple_GetItem, true, maxon::GenericComponent,, (CPyRef), const CPyRef& tuple, UInt index);
		maxon::Int CPythonLibraryInterface_CPyTuple_GetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_SetItem, CPyTuple_SetItem, true, maxon::GenericComponent,, (Bool), const CPyRef& tuple, UInt index, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyTuple_SetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_GetSlice, CPyTuple_GetSlice, true, maxon::GenericComponent,, (CPyRef), const CPyRef& tuple, UInt from, UInt to);
		maxon::Int CPythonLibraryInterface_CPyTuple_GetSlice_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_CheckExact, CPyTuple_CheckExact, true, maxon::GenericComponent,, (Bool), const CPyRef& tuple);
		maxon::Int CPythonLibraryInterface_CPyTuple_CheckExact_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_HasAttrString, CPyObject_HasAttrString, true, maxon::GenericComponent,, (Bool), const CPyRef& o, const Char* attrName);
		maxon::Int CPythonLibraryInterface_CPyObject_HasAttrString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_SetAttrString, CPyObject_SetAttrString, true, maxon::GenericComponent,, (Bool), const CPyRef& o, const Char* name, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyObject_SetAttrString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_GetAttrString, CPyObject_GetAttrString, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const Char* name);
		maxon::Int CPythonLibraryInterface_CPyObject_GetAttrString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Call, CPyObject_Call, true, maxon::GenericComponent,, (CPyRef), const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw);
		maxon::Int CPythonLibraryInterface_CPyObject_Call_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Str, CPyObject_Str, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Str_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Repr, CPyObject_Repr, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Repr_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Dir, CPyObject_Dir, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Dir_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_RichCompare, CPyObject_RichCompare, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o1, const CPyRef& o2, Int32 opid);
		maxon::Int CPythonLibraryInterface_CPyObject_RichCompare_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Hash, CPyObject_Hash, true, maxon::GenericComponent,, (Int64), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Hash_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_IsTrue, CPyObject_IsTrue, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_IsTrue_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Not, CPyObject_Not, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Not_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCallable_Check, CPyCallable_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyCallable_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Length, CPyObject_Length, true, maxon::GenericComponent,, (Int), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Length_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_GetItem, CPyObject_GetItem, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_GetItemInt, CPyObject_GetItemInt, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o, Int index);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItemInt_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_GetItemString, CPyObject_GetItemString, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const Char* index);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItemString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_DelItem, CPyObject_DelItem, true, maxon::GenericComponent,, (Bool), const CPyRef& o, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyObject_DelItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_SetItem, CPyObject_SetItem, true, maxon::GenericComponent,, (Bool), const CPyRef& o, const CPyRef& key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyObject_SetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_TypeCheck, CPyObject_TypeCheck, true, maxon::GenericComponent,, (Bool), const CPyRef& object, const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyObject_TypeCheck_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_CallFunction, CPyObject_CallFunction, true, maxon::GenericComponent,, (CPyRef), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_CallFunction_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySys_GetObject, CPySys_GetObject, true, maxon::GenericComponent,, (CPyRef), const Char* name);
		maxon::Int CPythonLibraryInterface_CPySys_GetObject_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySys_SetObject, CPySys_SetObject, true, maxon::GenericComponent,, (Bool), const Char* name, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPySys_SetObject_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_SetPath, CPy_SetPath, true, maxon::GenericComponent,, (Result<void>), const BaseArray<Url>& paths);
		maxon::Int CPythonLibraryInterface_CPy_SetPath_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySys_SetPath, CPySys_SetPath, true, maxon::GenericComponent,, (Result<void>), const BaseArray<Url>& paths, PATHHANDLE add);
		maxon::Int CPythonLibraryInterface_CPySys_SetPath_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySys_SetArgvEx, CPySys_SetArgvEx, true, maxon::GenericComponent,, (Result<void>), const BaseArray<String>& args, Bool updatepath);
		maxon::Int CPythonLibraryInterface_CPySys_SetArgvEx_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySys_GetPath, CPySys_GetPath, true, maxon::GenericComponent,, (BaseArray<Url>));
		maxon::Int CPythonLibraryInterface_CPySys_GetPath_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySite_AddSiteDir, CPySite_AddSiteDir, true, maxon::GenericComponent,, (Result<void>), const Url& siteDir);
		maxon::Int CPythonLibraryInterface_CPySite_AddSiteDir_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_Check, CPyUnicode_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyUnicode_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_FromString, CPyUnicode_FromString, true, maxon::GenericComponent, const, (CPyRef), const Char* str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_FromString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_FromStringAndSize, CPyUnicode_FromStringAndSize, true, maxon::GenericComponent,, (CPyRef), const Block<const Char>& block);
		maxon::Int CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_AsString, CPyUnicode_AsString, true, maxon::GenericComponent,, (Result<String>), const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_AsString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_AsCString, CPyUnicode_AsCString, true, maxon::GenericComponent,, (const Char*), const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_AsCString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_GetLength, CPyUnicode_GetLength, true, maxon::GenericComponent,, (Int), const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_GetLength_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_GetIter, CPyObject_GetIter, true, maxon::GenericComponent, const, (CPyRef), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_GetIter_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyIter_Next, CPyIter_Next, true, maxon::GenericComponent, const, (CPyRef), const CPyRef& it);
		maxon::Int CPythonLibraryInterface_CPyIter_Next_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_New, CPyDict_New, true, maxon::GenericComponent, const, (CPyRef));
		maxon::Int CPythonLibraryInterface_CPyDict_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_GetItem, CPyDict_GetItem, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict, const CPyRef& key, Bool raiseKeyError);
		maxon::Int CPythonLibraryInterface_CPyDict_GetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_GetItemString, CPyDict_GetItemString, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict, const Char* key, Bool raiseKeyError);
		maxon::Int CPythonLibraryInterface_CPyDict_GetItemString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_SetItem, CPyDict_SetItem, true, maxon::GenericComponent,, (Bool), const CPyRef& dict, const CPyRef& key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyDict_SetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_DelItem, CPyDict_DelItem, true, maxon::GenericComponent,, (Bool), const CPyRef& dict, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyDict_DelItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Contains, CPyDict_Contains, true, maxon::GenericComponent,, (CONTAINS), const CPyRef& dict, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyDict_Contains_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Clear, CPyDict_Clear, true, maxon::GenericComponent,, (void), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Clear_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Next, CPyDict_Next, true, maxon::GenericComponent,, (Bool), const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value);
		maxon::Int CPythonLibraryInterface_CPyDict_Next_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Keys, CPyDict_Keys, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Keys_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Values, CPyDict_Values, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Values_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Items, CPyDict_Items, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Items_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Size, CPyDict_Size, true, maxon::GenericComponent,, (Int), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Size_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Copy, CPyDict_Copy, true, maxon::GenericComponent,, (CPyRef), const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Copy_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_SetItemString, CPyDict_SetItemString, true, maxon::GenericComponent, const, (Bool), const CPyRef& dict, const Char* key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyDict_SetItemString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Check, CPyDict_Check, true, maxon::GenericComponent, const, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyDict_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_New, CPyList_New, true, maxon::GenericComponent,, (CPyRef), UInt size);
		maxon::Int CPythonLibraryInterface_CPyList_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_CheckExact, CPyList_CheckExact, true, maxon::GenericComponent,, (Bool), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_CheckExact_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Clear, CPyList_Clear, true, maxon::GenericComponent,, (Bool), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Clear_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Size, CPyList_Size, true, maxon::GenericComponent,, (Int), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Size_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_GetItem, CPyList_GetItem, true, maxon::GenericComponent,, (CPyRef), const CPyRef& list, UInt index);
		maxon::Int CPythonLibraryInterface_CPyList_GetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_SetItem, CPyList_SetItem, true, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_SetItem_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Insert, CPyList_Insert, true, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_Insert_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Append, CPyList_Append, true, maxon::GenericComponent,, (Bool), const CPyRef& list, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_Append_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_GetSlice, CPyList_GetSlice, true, maxon::GenericComponent,, (CPyRef), const CPyRef& list, UInt from, UInt to);
		maxon::Int CPythonLibraryInterface_CPyList_GetSlice_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_SetSlice, CPyList_SetSlice, true, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt from, UInt to, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_SetSlice_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Sort, CPyList_Sort, true, maxon::GenericComponent,, (Bool), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Sort_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Reverse, CPyList_Reverse, true, maxon::GenericComponent,, (Bool), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Reverse_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_AsTuple, CPyList_AsTuple, true, maxon::GenericComponent,, (CPyRef), const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_AsTuple_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_DelItemString, CPyDict_DelItemString, true, maxon::GenericComponent,, (Bool), const CPyRef& p, const Char* key);
		maxon::Int CPythonLibraryInterface_CPyDict_DelItemString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_Check, CPyModule_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyModule_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_AddObject, CPyModule_AddObject, true, maxon::GenericComponent,, (Result<Bool>), const CPyRef& module, const Char* name, const CPyRef& value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddObject_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_AddType, CPyModule_AddType, true, maxon::GenericComponent,, (Bool), const CPyRef& module, const CPyTypeRef& value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddType_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_GetDict, CPyModule_GetDict, true, maxon::GenericComponent,, (CPyRef), const CPyRef& module);
		maxon::Int CPythonLibraryInterface_CPyModule_GetDict_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_AddIntConstant, CPyModule_AddIntConstant, true, maxon::GenericComponent,, (Bool), const CPyRef& mod, const Char* name, long value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddIntConstant_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyImport_ImportModule, CPyImport_ImportModule, true, maxon::GenericComponent,, (CPyRef), const Char* name);
		maxon::Int CPythonLibraryInterface_CPyImport_ImportModule_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyImport_GetImporter, CPyImport_GetImporter, true, maxon::GenericComponent,, (CPyRef), const CPyRef& path);
		maxon::Int CPythonLibraryInterface_CPyImport_GetImporter_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyImport_GetModuleDict, CPyImport_GetModuleDict, true, maxon::GenericComponent,, (CPyRef));
		maxon::Int CPythonLibraryInterface_CPyImport_GetModuleDict_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_Check, CPyType_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyType_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_IsSubtype, CPyType_IsSubtype, true, maxon::GenericComponent,, (Bool), const CPyTypeRef& a, const CPyTypeRef& b);
		maxon::Int CPythonLibraryInterface_CPyType_IsSubtype_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_HasFeature, CPyType_HasFeature, true, maxon::GenericComponent, const, (Bool), const CPyTypeRef& type, Int64 f);
		maxon::Int CPythonLibraryInterface_CPyType_HasFeature_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_FastSubclass, CPyType_FastSubclass, true, maxon::GenericComponent, const, (Bool), const CPyTypeRef& type, Int64 f);
		maxon::Int CPythonLibraryInterface_CPyType_FastSubclass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_GetName, CPyType_GetName, true, maxon::GenericComponent,, (Result<String>), const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyType_GetName_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_Ready, CPyType_Ready, true, maxon::GenericComponent,, (Bool), CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyType_Ready_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_SaveThread, CPyEval_SaveThread, true, maxon::GenericComponent,, (NativePyThreadState*));
		maxon::Int CPythonLibraryInterface_CPyEval_SaveThread_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_RestoreThread, CPyEval_RestoreThread, true, maxon::GenericComponent,, (void), NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_RestoreThread_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_ThreadsInitialized, CPyEval_ThreadsInitialized, true, maxon::GenericComponent,, (Bool));
		maxon::Int CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_InitThreads, CPyEval_InitThreads, true, maxon::GenericComponent,, (void));
		maxon::Int CPythonLibraryInterface_CPyEval_InitThreads_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_AcquireThread, CPyEval_AcquireThread, true, maxon::GenericComponent,, (void), NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_AcquireThread_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_ReleaseThread, CPyEval_ReleaseThread, true, maxon::GenericComponent,, (void), NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_ReleaseThread_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_GetBuiltins, CPyEval_GetBuiltins, true, maxon::GenericComponent, const, (CPyRef));
		maxon::Int CPythonLibraryInterface_CPyEval_GetBuiltins_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyEval_EvalCode, CPyEval_EvalCode, true, maxon::GenericComponent, const, (CPyRef), const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals);
		maxon::Int CPythonLibraryInterface_CPyEval_EvalCode_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyFloat_Check, CPyFloat_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyFloat_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyFloat_FromFloat32, CPyFloat_FromFloat32, true, maxon::GenericComponent,, (CPyRef), Float32 value);
		maxon::Int CPythonLibraryInterface_CPyFloat_FromFloat32_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyFloat_FromFloat64, CPyFloat_FromFloat64, true, maxon::GenericComponent,, (CPyRef), Float64 value);
		maxon::Int CPythonLibraryInterface_CPyFloat_FromFloat64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyFloat_AsFloat64, CPyFloat_AsFloat64, true, maxon::GenericComponent,, (Float64), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyFloat_AsFloat64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_Check, CPyLong_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyBool_FromBool, CPyBool_FromBool, true, maxon::GenericComponent,, (CPyRef), Bool value);
		maxon::Int CPythonLibraryInterface_CPyBool_FromBool_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromInt16, CPyLong_FromInt16, true, maxon::GenericComponent,, (CPyRef), Int16 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt16_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromUInt16, CPyLong_FromUInt16, true, maxon::GenericComponent,, (CPyRef), UInt16 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt16_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromInt32, CPyLong_FromInt32, true, maxon::GenericComponent,, (CPyRef), Int32 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt32_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromUInt32, CPyLong_FromUInt32, true, maxon::GenericComponent,, (CPyRef), UInt32 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt32_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromInt64, CPyLong_FromInt64, true, maxon::GenericComponent,, (CPyRef), Int64 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_FromUInt64, CPyLong_FromUInt64, true, maxon::GenericComponent,, (CPyRef), UInt64 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsInt16, CPyLong_AsInt16, true, maxon::GenericComponent,, (Int16), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt16_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsUInt16, CPyLong_AsUInt16, true, maxon::GenericComponent,, (UInt16), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt16_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsInt32, CPyLong_AsInt32, true, maxon::GenericComponent,, (Int32), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt32_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsUInt32, CPyLong_AsUInt32, true, maxon::GenericComponent,, (UInt32), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt32_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsInt64, CPyLong_AsInt64, true, maxon::GenericComponent,, (Int64), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_AsUInt64, CPyLong_AsUInt64, true, maxon::GenericComponent,, (UInt64), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt64_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyNumber_Check, CPyNumber_Check, true, maxon::GenericComponent,, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyNumber_Check_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyFunction_New, MPyFunction_New, true, maxon::GenericComponent,, (MPyFunctionRef), const reflection::Function* func);
		maxon::Int CPythonLibraryInterface_MPyFunction_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyHashMap_New, MPyHashMap_New, true, maxon::GenericComponent,, (MPyHashMapRef), const HashMap<Data, Data>& map);
		maxon::Int CPythonLibraryInterface_MPyHashMap_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyHashMap_New_1, MPyHashMap_New, true, maxon::GenericComponent,, (MPyHashMapRef), HashMap<Data, Data>&& map);
		maxon::Int CPythonLibraryInterface_MPyHashMap_New_1_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyMember_New, MPyMember_New, true, maxon::GenericComponent,, (MPyMemberRef), const reflection::Member* member);
		maxon::Int CPythonLibraryInterface_MPyMember_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyMem_SetAllocator, CPyMem_SetAllocator, true, maxon::GenericComponent,, (Result<void>), CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator);
		maxon::Int CPythonLibraryInterface_CPyMem_SetAllocator_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyClass_New, MPyClass_New, true, maxon::GenericComponent,, (MPyClassRef), const reflection::Class* cls);
		maxon::Int CPythonLibraryInterface_MPyClass_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_DebugFlag, CPy_DebugFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_DebugFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_VerboseFlag, CPy_VerboseFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_VerboseFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_InteractiveFlag, CPy_InteractiveFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_InteractiveFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_InspectFlag, CPy_InspectFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_InspectFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_OptimizeFlag, CPy_OptimizeFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_OptimizeFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_NoSiteFlag, CPy_NoSiteFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_NoSiteFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_BytesWarningFlag, CPy_BytesWarningFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_BytesWarningFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_FrozenFlag, CPy_FrozenFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_FrozenFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag, CPy_IgnoreEnvironmentFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_DontWriteBytecodeFlag, CPy_DontWriteBytecodeFlag, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPy_NoUserSiteDirectory, CPy_NoUserSiteDirectory, true, maxon::GenericComponent,, (Int32*));
		maxon::Int CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_BaseException, CPyExc_BaseException, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_BaseException_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_Exception, CPyExc_Exception, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_Exception_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_StopIteration, CPyExc_StopIteration, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_StopIteration_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_GeneratorExit, CPyExc_GeneratorExit, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_GeneratorExit_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_StandardError, CPyExc_StandardError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_StandardError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ArithmeticError, CPyExc_ArithmeticError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ArithmeticError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_LookupError, CPyExc_LookupError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_LookupError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_AssertionError, CPyExc_AssertionError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_AssertionError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_AttributeError, CPyExc_AttributeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_AttributeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_EOFError, CPyExc_EOFError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_EOFError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_FloatingPointError, CPyExc_FloatingPointError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_FloatingPointError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_EnvironmentError, CPyExc_EnvironmentError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_EnvironmentError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_IOError, CPyExc_IOError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_IOError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_OSError, CPyExc_OSError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_OSError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ImportError, CPyExc_ImportError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ImportError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_IndexError, CPyExc_IndexError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_IndexError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_KeyError, CPyExc_KeyError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_KeyError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_KeyboardInterrupt, CPyExc_KeyboardInterrupt, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_MemoryError, CPyExc_MemoryError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_MemoryError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_NameError, CPyExc_NameError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_NameError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_OverflowError, CPyExc_OverflowError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_OverflowError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_RuntimeError, CPyExc_RuntimeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_RuntimeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_NotImplementedError, CPyExc_NotImplementedError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_NotImplementedError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_SyntaxError, CPyExc_SyntaxError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_SyntaxError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_IndentationError, CPyExc_IndentationError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_IndentationError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_TabError, CPyExc_TabError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_TabError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ReferenceError, CPyExc_ReferenceError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ReferenceError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_SystemError, CPyExc_SystemError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_SystemError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_SystemExit, CPyExc_SystemExit, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_SystemExit_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_TypeError, CPyExc_TypeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_TypeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnboundLocalError, CPyExc_UnboundLocalError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnicodeError, CPyExc_UnicodeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnicodeEncodeError, CPyExc_UnicodeEncodeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnicodeDecodeError, CPyExc_UnicodeDecodeError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnicodeTranslateError, CPyExc_UnicodeTranslateError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ValueError, CPyExc_ValueError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ValueError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ZeroDivisionError, CPyExc_ZeroDivisionError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_WindowsError, CPyExc_WindowsError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_WindowsError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_BufferError, CPyExc_BufferError, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_BufferError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_MemoryErrorInst, CPyExc_MemoryErrorInst, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_Warning, CPyExc_Warning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_Warning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UserWarning, CPyExc_UserWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UserWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_DeprecationWarning, CPyExc_DeprecationWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_PendingDeprecationWarning, CPyExc_PendingDeprecationWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_SyntaxWarning, CPyExc_SyntaxWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_RuntimeWarning, CPyExc_RuntimeWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_FutureWarning, CPyExc_FutureWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_FutureWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_ImportWarning, CPyExc_ImportWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_ImportWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_UnicodeWarning, CPyExc_UnicodeWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyExc_BytesWarning, CPyExc_BytesWarning, true, maxon::GenericComponent,, (CPyConstRef));
		maxon::Int CPythonLibraryInterface_CPyExc_BytesWarning_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyNullImporter_Type, CPyNullImporter_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyNullImporter_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySuper_Type, CPySuper_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPySuper_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyBool_Type, CPyBool_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyBool_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_Type, CPyObject_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyObject_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyModule_Type, CPyModule_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyModule_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyUnicode_Type, CPyUnicode_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyUnicode_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyLong_Type, CPyLong_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyLong_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyFloat_Type, CPyFloat_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyFloat_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTuple_Type, CPyTuple_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyTuple_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyList_Type, CPyList_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyList_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyDict_Type, CPyDict_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyDict_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyClass_Type, CPyClass_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyClass_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyTraceBack_Type, CPyTraceBack_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyTraceBack_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPySlice_Type, CPySlice_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPySlice_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyType_Type, CPyType_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyType_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyMemoryView_Type, CPyMemoryView_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyMemoryView_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_ConvertAndCacheString, ConvertAndCacheString, true, maxon::GenericComponent,, (const PyChar*), const String& str, PyStringEncodings encoding, UInt* size);
		maxon::Int CPythonLibraryInterface_ConvertAndCacheString_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_RegisterSpecificPythonClass, RegisterSpecificPythonClass, true, maxon::GenericComponent,, (Result<void>), const Id& typeId, const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_RegisterSpecificPythonClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_PrivateRegisterBuiltinConverter, PrivateRegisterBuiltinConverter, true, maxon::GenericComponent,, (Result<void>), const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2);
		maxon::Int CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetSpecialPath, GetSpecialPath, true, maxon::GenericComponent,, (Url), SPECIALPATH anonymous_param_1);
		maxon::Int CPythonLibraryInterface_GetSpecialPath_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_RegisterSpecialPath, RegisterSpecialPath, true, maxon::GenericComponent,, (void), SPECIALPATH anonymous_param_1, const Url& path);
		maxon::Int CPythonLibraryInterface_RegisterSpecialPath_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyDataCapsule_Type, MPyDataCapsule_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_MPyDataCapsule_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyData_Type, CPyData_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyData_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyCapsule_Type, CPyCapsule_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyCapsule_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyId_Type, CPyId_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyId_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyInternedId_Type, CPyInternedId_Type, true, maxon::GenericComponent,, (CPyTypeConstRef));
		maxon::Int CPythonLibraryInterface_CPyInternedId_Type_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_PrivateGetCurrentCallerContext, PrivateGetCurrentCallerContext, true, maxon::GenericComponent,, (CPyRef));
		maxon::Int CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyDataType_ToMapperInstance, MPyDataType_ToMapperInstance, true, maxon::GenericComponent,, (CPyRef), const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyData_ToMapperInstance, MPyData_ToMapperInstance, true, maxon::GenericComponent,, (CPyRef), const MPyDataRef& capsule);
		maxon::Int CPythonLibraryInterface_MPyData_ToMapperInstance_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_ToMapperInstance, CPyObject_ToMapperInstance, true, maxon::GenericComponent,, (CPyRef), const DataType& dt, const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, AssociateDataTypeWithPythonTypes, true, maxon::GenericComponent,, (Result<void>), const DataType& dt, const CPyRef& type);
		maxon::Int CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetAssociatedDataType, GetAssociatedDataType, true, maxon::GenericComponent,, (Result<CPyRef>), const DataType& dt);
		maxon::Int CPythonLibraryInterface_GetAssociatedDataType_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetConverterPyObject_FromData, GetConverterPyObject_FromData, true, maxon::GenericComponent,, (DelegatePyObject_FromData<>*), const DataType& dt);
		maxon::Int CPythonLibraryInterface_GetConverterPyObject_FromData_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyData_New, MPyData_New, true, maxon::GenericComponent,, (MPyDataRef), Data& data);
		maxon::Int CPythonLibraryInterface_MPyData_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyData_New_1, MPyData_New, true, maxon::GenericComponent,, (MPyDataRef), const DataType& dt, Generic* data, Bool owner, const DataType& mapDt);
		maxon::Int CPythonLibraryInterface_MPyData_New_1_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyDataType_New, MPyDataType_New, true, maxon::GenericComponent,, (MPyDataTypeRef), const DataType& dt);
		maxon::Int CPythonLibraryInterface_MPyDataType_New_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyDataType_CheckExact, MPyDataType_CheckExact, true, maxon::GenericComponent, const, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_MPyDataType_CheckExact_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyDataType_GetDataType, MPyDataType_GetDataType, true, maxon::GenericComponent, const, (const DataType&), const MPyDataTypeRef& o);
		maxon::Int CPythonLibraryInterface_MPyDataType_GetDataType_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MPyData_CheckExact, MPyData_CheckExact, true, maxon::GenericComponent, const, (Bool), const CPyRef& o);
		maxon::Int CPythonLibraryInterface_MPyData_CheckExact_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_AsData, CPyObject_AsData, true, maxon::GenericComponent,, (Result<Data*>), Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n);
		maxon::Int CPythonLibraryInterface_CPyObject_AsData_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetRegisteredTypesWithConversions, GetRegisteredTypesWithConversions, true, maxon::GenericComponent,, (Result<BaseArray<TYPE_CONVERSION_TUPLE>>));
		maxon::Int CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_ParseDataType, ParseDataType, true, maxon::GenericComponent,, (Result<DataType>), const CPyRef& args, Int32 argIndex, Bool canBeNone);
		maxon::Int CPythonLibraryInterface_ParseDataType_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_SetError, SetError, true, maxon::GenericComponent,, (void), const Error& err);
		maxon::Int CPythonLibraryInterface_SetError_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_SetError_1, SetError, true, maxon::GenericComponent,, (void), const ErrorPtr& err);
		maxon::Int CPythonLibraryInterface_SetError_1_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_MaxonConvertAuto, MaxonConvertAuto, true, maxon::GenericComponent,, (CPyRef), const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_MaxonConvertAuto_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CPyObject_FromGeneric, CPyObject_FromGeneric, true, maxon::GenericComponent,, (CPyRef), const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count);
		maxon::Int CPythonLibraryInterface_CPyObject_FromGeneric_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_CreateGlobalDictionary, CreateGlobalDictionary, true, maxon::GenericComponent, const, (CPyRef));
		maxon::Int CPythonLibraryInterface_CreateGlobalDictionary_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCurrentTraceback, GetCurrentTraceback, true, maxon::GenericComponent,, (Result<BaseArray<SourceLocation>>));
		maxon::Int CPythonLibraryInterface_GetCurrentTraceback_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCPyRefClass, GetCPyRefClass, true, maxon::GenericComponent, const, (Class<CPyRef>));
		maxon::Int CPythonLibraryInterface_GetCPyRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCPyTypeRefClass, GetCPyTypeRefClass, true, maxon::GenericComponent, const, (Class<CPyTypeRef>));
		maxon::Int CPythonLibraryInterface_GetCPyTypeRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCPyFrameRefClass, GetCPyFrameRefClass, true, maxon::GenericComponent, const, (Class<CPyFrameRef>));
		maxon::Int CPythonLibraryInterface_GetCPyFrameRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCPyTracebackRefClass, GetCPyTracebackRefClass, true, maxon::GenericComponent, const, (Class<CPyTracebackRef>));
		maxon::Int CPythonLibraryInterface_GetCPyTracebackRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetCPyCodeRefClass, GetCPyCodeRefClass, true, maxon::GenericComponent, const, (Class<CPyCodeRef>));
		maxon::Int CPythonLibraryInterface_GetCPyCodeRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyClassRefClass, GetMPyClassRefClass, true, maxon::GenericComponent, const, (Class<MPyClassRef>));
		maxon::Int CPythonLibraryInterface_GetMPyClassRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyMemberRefClass, GetMPyMemberRefClass, true, maxon::GenericComponent, const, (Class<MPyMemberRef>));
		maxon::Int CPythonLibraryInterface_GetMPyMemberRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyFunctionRefClass, GetMPyFunctionRefClass, true, maxon::GenericComponent, const, (Class<MPyFunctionRef>));
		maxon::Int CPythonLibraryInterface_GetMPyFunctionRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyHashMapRefClass, GetMPyHashMapRefClass, true, maxon::GenericComponent, const, (Class<MPyHashMapRef>));
		maxon::Int CPythonLibraryInterface_GetMPyHashMapRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyDataTypeRefClass, GetMPyDataTypeRefClass, true, maxon::GenericComponent, const, (Class<MPyDataTypeRef>));
		maxon::Int CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyDataRefClass, GetMPyDataRefClass, true, maxon::GenericComponent, const, (Class<MPyDataRef>));
		maxon::Int CPythonLibraryInterface_GetMPyDataRefClass_Offset;
		PRIVATE_MAXON_MF_POINTER(CPythonLibraryInterface_GetMPyCallerContextRefClass, GetMPyCallerContextRefClass, true, maxon::GenericComponent, const, (Class<MPyCallerContextRef>));
		maxon::Int CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, Init))
		{
			maxon::Tie(CPythonLibraryInterface_Init, CPythonLibraryInterface_Init_Offset) = CPythonLibraryInterface_Init_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, InitTypes))
		{
			maxon::Tie(CPythonLibraryInterface_InitTypes, CPythonLibraryInterface_InitTypes_Offset) = CPythonLibraryInterface_InitTypes_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, InitBuiltinModules))
		{
			maxon::Tie(CPythonLibraryInterface_InitBuiltinModules, CPythonLibraryInterface_InitBuiltinModules_Offset) = CPythonLibraryInterface_InitBuiltinModules_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Initialize))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_Initialize, CPythonLibraryInterface_CPy_Initialize_Offset) = CPythonLibraryInterface_CPy_Initialize_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Finalize))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_Finalize, CPythonLibraryInterface_CPy_Finalize_Offset) = CPythonLibraryInterface_CPy_Finalize_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Create))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_Create, CPythonLibraryInterface_CPyModule_Create_Offset) = CPythonLibraryInterface_CPyModule_Create_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, Free))
		{
			maxon::Tie(CPythonLibraryInterface_Free, CPythonLibraryInterface_Free_Offset) = CPythonLibraryInterface_Free_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetDll))
		{
			maxon::Tie(CPythonLibraryInterface_GetDll, CPythonLibraryInterface_GetDll_Offset) = CPythonLibraryInterface_GetDll_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, FopenNative))
		{
			maxon::Tie(CPythonLibraryInterface_FopenNative, CPythonLibraryInterface_FopenNative_Offset) = CPythonLibraryInterface_FopenNative_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, LastPythonCallFailed))
		{
			maxon::Tie(CPythonLibraryInterface_LastPythonCallFailed, CPythonLibraryInterface_LastPythonCallFailed_Offset) = CPythonLibraryInterface_LastPythonCallFailed_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterComponentProxy))
		{
			maxon::Tie(CPythonLibraryInterface_RegisterComponentProxy, CPythonLibraryInterface_RegisterComponentProxy_Offset) = CPythonLibraryInterface_RegisterComponentProxy_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_IsInitialized))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_IsInitialized, CPythonLibraryInterface_CPy_IsInitialized_Offset) = CPythonLibraryInterface_CPy_IsInitialized_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetVersion))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetVersion, CPythonLibraryInterface_CPy_GetVersion_Offset) = CPythonLibraryInterface_CPy_GetVersion_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetPlatform))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetPlatform, CPythonLibraryInterface_CPy_GetPlatform_Offset) = CPythonLibraryInterface_CPy_GetPlatform_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetCopyright))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetCopyright, CPythonLibraryInterface_CPy_GetCopyright_Offset) = CPythonLibraryInterface_CPy_GetCopyright_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetCompiler))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetCompiler, CPythonLibraryInterface_CPy_GetCompiler_Offset) = CPythonLibraryInterface_CPy_GetCompiler_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetBuildInfo))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetBuildInfo, CPythonLibraryInterface_CPy_GetBuildInfo_Offset) = CPythonLibraryInterface_CPy_GetBuildInfo_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetProgramName))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_SetProgramName, CPythonLibraryInterface_CPy_SetProgramName_Offset) = CPythonLibraryInterface_CPy_SetProgramName_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetPythonHome))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_SetPythonHome, CPythonLibraryInterface_CPy_SetPythonHome_Offset) = CPythonLibraryInterface_CPy_SetPythonHome_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetProgramName))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetProgramName, CPythonLibraryInterface_CPy_GetProgramName_Offset) = CPythonLibraryInterface_CPy_GetProgramName_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetPythonHome))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_GetPythonHome, CPythonLibraryInterface_CPy_GetPythonHome_Offset) = CPythonLibraryInterface_CPy_GetPythonHome_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ExecuteModule))
		{
			maxon::Tie(CPythonLibraryInterface_ExecuteModule, CPythonLibraryInterface_ExecuteModule_Offset) = CPythonLibraryInterface_ExecuteModule_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCallerContext_New))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCallerContext_New, CPythonLibraryInterface_CPyCallerContext_New_Offset) = CPythonLibraryInterface_CPyCallerContext_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPyRun_SimpleFileExFlags, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset) = CPythonLibraryInterface_CPyRun_SimpleFileExFlags_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset) = CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleStringFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPyRun_SimpleStringFlags, CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset) = CPythonLibraryInterface_CPyRun_SimpleStringFlags_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_FileExFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPyRun_FileExFlags, CPythonLibraryInterface_CPyRun_FileExFlags_Offset) = CPythonLibraryInterface_CPyRun_FileExFlags_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_InteractiveLoopFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset) = CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGilState_Ensure))
		{
			maxon::Tie(CPythonLibraryInterface_CPyGilState_Ensure, CPythonLibraryInterface_CPyGilState_Ensure_Offset) = CPythonLibraryInterface_CPyGilState_Ensure_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGilState_Release))
		{
			maxon::Tie(CPythonLibraryInterface_CPyGilState_Release, CPythonLibraryInterface_CPyGilState_Release_Offset) = CPythonLibraryInterface_CPyGilState_Release_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetGilState))
		{
			maxon::Tie(CPythonLibraryInterface_GetGilState, CPythonLibraryInterface_GetGilState_Offset) = CPythonLibraryInterface_GetGilState_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGILState_GetThisThreadState))
		{
			maxon::Tie(CPythonLibraryInterface_CPyGILState_GetThisThreadState, CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset) = CPythonLibraryInterface_CPyGILState_GetThisThreadState_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyThreadState_Swap))
		{
			maxon::Tie(CPythonLibraryInterface_CPyThreadState_Swap, CPythonLibraryInterface_CPyThreadState_Swap_Offset) = CPythonLibraryInterface_CPyThreadState_Swap_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyThreadState_GetDict))
		{
			maxon::Tie(CPythonLibraryInterface_CPyThreadState_GetDict, CPythonLibraryInterface_CPyThreadState_GetDict_Offset) = CPythonLibraryInterface_CPyThreadState_GetDict_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_CompileStringFlags))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_CompileStringFlags, CPythonLibraryInterface_CPy_CompileStringFlags_Offset) = CPythonLibraryInterface_CPy_CompileStringFlags_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Incref))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_Incref, CPythonLibraryInterface_CPy_Incref_Offset) = CPythonLibraryInterface_CPy_Incref_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Decref))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_Decref, CPythonLibraryInterface_CPy_Decref_Offset) = CPythonLibraryInterface_CPy_Decref_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SafeIncref))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_SafeIncref, CPythonLibraryInterface_CPy_SafeIncref_Offset) = CPythonLibraryInterface_CPy_SafeIncref_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SafeDecref))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_SafeDecref, CPythonLibraryInterface_CPy_SafeDecref_Offset) = CPythonLibraryInterface_CPy_SafeDecref_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGC_Collect))
		{
			maxon::Tie(CPythonLibraryInterface_CPyGC_Collect, CPythonLibraryInterface_CPyGC_Collect_Offset) = CPythonLibraryInterface_CPyGC_Collect_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCode_Addr2Line))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCode_Addr2Line, CPythonLibraryInterface_CPyCode_Addr2Line_Offset) = CPythonLibraryInterface_CPyCode_Addr2Line_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, UnpackDataType))
		{
			maxon::Tie(CPythonLibraryInterface_UnpackDataType, CPythonLibraryInterface_UnpackDataType_Offset) = CPythonLibraryInterface_UnpackDataType_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, UnpackData))
		{
			maxon::Tie(CPythonLibraryInterface_UnpackData, CPythonLibraryInterface_UnpackData_Offset) = CPythonLibraryInterface_UnpackData_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_None))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_None, CPythonLibraryInterface_CPy_None_Offset) = CPythonLibraryInterface_CPy_None_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_True))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_True, CPythonLibraryInterface_CPy_True_Offset) = CPythonLibraryInterface_CPy_True_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_False))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_False, CPythonLibraryInterface_CPy_False_Offset) = CPythonLibraryInterface_CPy_False_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NotImplemented))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_NotImplemented, CPythonLibraryInterface_CPy_NotImplemented_Offset) = CPythonLibraryInterface_CPy_NotImplemented_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Print))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_Print, CPythonLibraryInterface_CPyErr_Print_Offset) = CPythonLibraryInterface_CPyErr_Print_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Clear))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_Clear, CPythonLibraryInterface_CPyErr_Clear_Offset) = CPythonLibraryInterface_CPyErr_Clear_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Occurred))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_Occurred, CPythonLibraryInterface_CPyErr_Occurred_Offset) = CPythonLibraryInterface_CPyErr_Occurred_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_SetString, CPythonLibraryInterface_CPyErr_SetString_Offset) = CPythonLibraryInterface_CPyErr_SetString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrnoAndFilename))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset) = CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrno))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_SetWithErrno, CPythonLibraryInterface_CPyErr_SetWithErrno_Offset) = CPythonLibraryInterface_CPyErr_SetWithErrno_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_SetString_1, CPythonLibraryInterface_CPyErr_SetString_1_Offset) = CPythonLibraryInterface_CPyErr_SetString_1_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetNone))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_SetNone, CPythonLibraryInterface_CPyErr_SetNone_Offset) = CPythonLibraryInterface_CPyErr_SetNone_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Fetch))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_Fetch, CPythonLibraryInterface_CPyErr_Fetch_Offset) = CPythonLibraryInterface_CPyErr_Fetch_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_NormalizeException))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_NormalizeException, CPythonLibraryInterface_CPyErr_NormalizeException_Offset) = CPythonLibraryInterface_CPyErr_NormalizeException_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Restore))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_Restore, CPythonLibraryInterface_CPyErr_Restore_Offset) = CPythonLibraryInterface_CPyErr_Restore_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_ExceptionMatches))
		{
			maxon::Tie(CPythonLibraryInterface_CPyErr_ExceptionMatches, CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset) = CPythonLibraryInterface_CPyErr_ExceptionMatches_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExceptionClass_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExceptionClass_Check, CPythonLibraryInterface_CPyExceptionClass_Check_Offset) = CPythonLibraryInterface_CPyExceptionClass_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_New))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_New, CPythonLibraryInterface_CPyCapsule_New_Offset) = CPythonLibraryInterface_CPyCapsule_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_SetPointer))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_SetPointer, CPythonLibraryInterface_CPyCapsule_SetPointer_Offset) = CPythonLibraryInterface_CPyCapsule_SetPointer_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_GetPointer))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_GetPointer, CPythonLibraryInterface_CPyCapsule_GetPointer_Offset) = CPythonLibraryInterface_CPyCapsule_GetPointer_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_GetContext))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_GetContext, CPythonLibraryInterface_CPyCapsule_GetContext_Offset) = CPythonLibraryInterface_CPyCapsule_GetContext_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_SetContext))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_SetContext, CPythonLibraryInterface_CPyCapsule_SetContext_Offset) = CPythonLibraryInterface_CPyCapsule_SetContext_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_CheckExact))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_CheckExact, CPythonLibraryInterface_CPyCapsule_CheckExact_Offset) = CPythonLibraryInterface_CPyCapsule_CheckExact_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTraceBack_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTraceBack_Check, CPythonLibraryInterface_CPyTraceBack_Check_Offset) = CPythonLibraryInterface_CPyTraceBack_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyClass_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyClass_Check, CPythonLibraryInterface_CPyClass_Check_Offset) = CPythonLibraryInterface_CPyClass_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_New))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_New, CPythonLibraryInterface_CPyTuple_New_Offset) = CPythonLibraryInterface_CPyTuple_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_Size))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_Size, CPythonLibraryInterface_CPyTuple_Size_Offset) = CPythonLibraryInterface_CPyTuple_Size_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_GetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_GetItem, CPythonLibraryInterface_CPyTuple_GetItem_Offset) = CPythonLibraryInterface_CPyTuple_GetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_SetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_SetItem, CPythonLibraryInterface_CPyTuple_SetItem_Offset) = CPythonLibraryInterface_CPyTuple_SetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_GetSlice))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_GetSlice, CPythonLibraryInterface_CPyTuple_GetSlice_Offset) = CPythonLibraryInterface_CPyTuple_GetSlice_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_CheckExact))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_CheckExact, CPythonLibraryInterface_CPyTuple_CheckExact_Offset) = CPythonLibraryInterface_CPyTuple_CheckExact_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_HasAttrString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_HasAttrString, CPythonLibraryInterface_CPyObject_HasAttrString_Offset) = CPythonLibraryInterface_CPyObject_HasAttrString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_SetAttrString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_SetAttrString, CPythonLibraryInterface_CPyObject_SetAttrString_Offset) = CPythonLibraryInterface_CPyObject_SetAttrString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetAttrString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_GetAttrString, CPythonLibraryInterface_CPyObject_GetAttrString_Offset) = CPythonLibraryInterface_CPyObject_GetAttrString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Call))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Call, CPythonLibraryInterface_CPyObject_Call_Offset) = CPythonLibraryInterface_CPyObject_Call_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Str))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Str, CPythonLibraryInterface_CPyObject_Str_Offset) = CPythonLibraryInterface_CPyObject_Str_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Repr))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Repr, CPythonLibraryInterface_CPyObject_Repr_Offset) = CPythonLibraryInterface_CPyObject_Repr_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Dir))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Dir, CPythonLibraryInterface_CPyObject_Dir_Offset) = CPythonLibraryInterface_CPyObject_Dir_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_RichCompare))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_RichCompare, CPythonLibraryInterface_CPyObject_RichCompare_Offset) = CPythonLibraryInterface_CPyObject_RichCompare_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Hash))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Hash, CPythonLibraryInterface_CPyObject_Hash_Offset) = CPythonLibraryInterface_CPyObject_Hash_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_IsTrue))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_IsTrue, CPythonLibraryInterface_CPyObject_IsTrue_Offset) = CPythonLibraryInterface_CPyObject_IsTrue_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Not))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Not, CPythonLibraryInterface_CPyObject_Not_Offset) = CPythonLibraryInterface_CPyObject_Not_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCallable_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCallable_Check, CPythonLibraryInterface_CPyCallable_Check_Offset) = CPythonLibraryInterface_CPyCallable_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Length))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Length, CPythonLibraryInterface_CPyObject_Length_Offset) = CPythonLibraryInterface_CPyObject_Length_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_GetItem, CPythonLibraryInterface_CPyObject_GetItem_Offset) = CPythonLibraryInterface_CPyObject_GetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItemInt))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_GetItemInt, CPythonLibraryInterface_CPyObject_GetItemInt_Offset) = CPythonLibraryInterface_CPyObject_GetItemInt_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItemString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_GetItemString, CPythonLibraryInterface_CPyObject_GetItemString_Offset) = CPythonLibraryInterface_CPyObject_GetItemString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_DelItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_DelItem, CPythonLibraryInterface_CPyObject_DelItem_Offset) = CPythonLibraryInterface_CPyObject_DelItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_SetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_SetItem, CPythonLibraryInterface_CPyObject_SetItem_Offset) = CPythonLibraryInterface_CPyObject_SetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_TypeCheck))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_TypeCheck, CPythonLibraryInterface_CPyObject_TypeCheck_Offset) = CPythonLibraryInterface_CPyObject_TypeCheck_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_CallFunction))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_CallFunction, CPythonLibraryInterface_CPyObject_CallFunction_Offset) = CPythonLibraryInterface_CPyObject_CallFunction_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_GetObject))
		{
			maxon::Tie(CPythonLibraryInterface_CPySys_GetObject, CPythonLibraryInterface_CPySys_GetObject_Offset) = CPythonLibraryInterface_CPySys_GetObject_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetObject))
		{
			maxon::Tie(CPythonLibraryInterface_CPySys_SetObject, CPythonLibraryInterface_CPySys_SetObject_Offset) = CPythonLibraryInterface_CPySys_SetObject_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetPath))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_SetPath, CPythonLibraryInterface_CPy_SetPath_Offset) = CPythonLibraryInterface_CPy_SetPath_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetPath))
		{
			maxon::Tie(CPythonLibraryInterface_CPySys_SetPath, CPythonLibraryInterface_CPySys_SetPath_Offset) = CPythonLibraryInterface_CPySys_SetPath_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetArgvEx))
		{
			maxon::Tie(CPythonLibraryInterface_CPySys_SetArgvEx, CPythonLibraryInterface_CPySys_SetArgvEx_Offset) = CPythonLibraryInterface_CPySys_SetArgvEx_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_GetPath))
		{
			maxon::Tie(CPythonLibraryInterface_CPySys_GetPath, CPythonLibraryInterface_CPySys_GetPath_Offset) = CPythonLibraryInterface_CPySys_GetPath_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySite_AddSiteDir))
		{
			maxon::Tie(CPythonLibraryInterface_CPySite_AddSiteDir, CPythonLibraryInterface_CPySite_AddSiteDir_Offset) = CPythonLibraryInterface_CPySite_AddSiteDir_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_Check, CPythonLibraryInterface_CPyUnicode_Check_Offset) = CPythonLibraryInterface_CPyUnicode_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_FromString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_FromString, CPythonLibraryInterface_CPyUnicode_FromString_Offset) = CPythonLibraryInterface_CPyUnicode_FromString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_FromStringAndSize))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_FromStringAndSize, CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset) = CPythonLibraryInterface_CPyUnicode_FromStringAndSize_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_AsString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_AsString, CPythonLibraryInterface_CPyUnicode_AsString_Offset) = CPythonLibraryInterface_CPyUnicode_AsString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_AsCString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_AsCString, CPythonLibraryInterface_CPyUnicode_AsCString_Offset) = CPythonLibraryInterface_CPyUnicode_AsCString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_GetLength))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_GetLength, CPythonLibraryInterface_CPyUnicode_GetLength_Offset) = CPythonLibraryInterface_CPyUnicode_GetLength_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetIter))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_GetIter, CPythonLibraryInterface_CPyObject_GetIter_Offset) = CPythonLibraryInterface_CPyObject_GetIter_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyIter_Next))
		{
			maxon::Tie(CPythonLibraryInterface_CPyIter_Next, CPythonLibraryInterface_CPyIter_Next_Offset) = CPythonLibraryInterface_CPyIter_Next_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_New))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_New, CPythonLibraryInterface_CPyDict_New_Offset) = CPythonLibraryInterface_CPyDict_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_GetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_GetItem, CPythonLibraryInterface_CPyDict_GetItem_Offset) = CPythonLibraryInterface_CPyDict_GetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_GetItemString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_GetItemString, CPythonLibraryInterface_CPyDict_GetItemString_Offset) = CPythonLibraryInterface_CPyDict_GetItemString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_SetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_SetItem, CPythonLibraryInterface_CPyDict_SetItem_Offset) = CPythonLibraryInterface_CPyDict_SetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_DelItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_DelItem, CPythonLibraryInterface_CPyDict_DelItem_Offset) = CPythonLibraryInterface_CPyDict_DelItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Contains))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Contains, CPythonLibraryInterface_CPyDict_Contains_Offset) = CPythonLibraryInterface_CPyDict_Contains_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Clear))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Clear, CPythonLibraryInterface_CPyDict_Clear_Offset) = CPythonLibraryInterface_CPyDict_Clear_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Next))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Next, CPythonLibraryInterface_CPyDict_Next_Offset) = CPythonLibraryInterface_CPyDict_Next_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Keys))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Keys, CPythonLibraryInterface_CPyDict_Keys_Offset) = CPythonLibraryInterface_CPyDict_Keys_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Values))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Values, CPythonLibraryInterface_CPyDict_Values_Offset) = CPythonLibraryInterface_CPyDict_Values_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Items))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Items, CPythonLibraryInterface_CPyDict_Items_Offset) = CPythonLibraryInterface_CPyDict_Items_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Size))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Size, CPythonLibraryInterface_CPyDict_Size_Offset) = CPythonLibraryInterface_CPyDict_Size_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Copy))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Copy, CPythonLibraryInterface_CPyDict_Copy_Offset) = CPythonLibraryInterface_CPyDict_Copy_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_SetItemString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_SetItemString, CPythonLibraryInterface_CPyDict_SetItemString_Offset) = CPythonLibraryInterface_CPyDict_SetItemString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Check, CPythonLibraryInterface_CPyDict_Check_Offset) = CPythonLibraryInterface_CPyDict_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_New))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_New, CPythonLibraryInterface_CPyList_New_Offset) = CPythonLibraryInterface_CPyList_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_CheckExact))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_CheckExact, CPythonLibraryInterface_CPyList_CheckExact_Offset) = CPythonLibraryInterface_CPyList_CheckExact_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Clear))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Clear, CPythonLibraryInterface_CPyList_Clear_Offset) = CPythonLibraryInterface_CPyList_Clear_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Size))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Size, CPythonLibraryInterface_CPyList_Size_Offset) = CPythonLibraryInterface_CPyList_Size_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_GetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_GetItem, CPythonLibraryInterface_CPyList_GetItem_Offset) = CPythonLibraryInterface_CPyList_GetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_SetItem))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_SetItem, CPythonLibraryInterface_CPyList_SetItem_Offset) = CPythonLibraryInterface_CPyList_SetItem_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Insert))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Insert, CPythonLibraryInterface_CPyList_Insert_Offset) = CPythonLibraryInterface_CPyList_Insert_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Append))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Append, CPythonLibraryInterface_CPyList_Append_Offset) = CPythonLibraryInterface_CPyList_Append_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_GetSlice))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_GetSlice, CPythonLibraryInterface_CPyList_GetSlice_Offset) = CPythonLibraryInterface_CPyList_GetSlice_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_SetSlice))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_SetSlice, CPythonLibraryInterface_CPyList_SetSlice_Offset) = CPythonLibraryInterface_CPyList_SetSlice_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Sort))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Sort, CPythonLibraryInterface_CPyList_Sort_Offset) = CPythonLibraryInterface_CPyList_Sort_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Reverse))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Reverse, CPythonLibraryInterface_CPyList_Reverse_Offset) = CPythonLibraryInterface_CPyList_Reverse_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_AsTuple))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_AsTuple, CPythonLibraryInterface_CPyList_AsTuple_Offset) = CPythonLibraryInterface_CPyList_AsTuple_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_DelItemString))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_DelItemString, CPythonLibraryInterface_CPyDict_DelItemString_Offset) = CPythonLibraryInterface_CPyDict_DelItemString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_Check, CPythonLibraryInterface_CPyModule_Check_Offset) = CPythonLibraryInterface_CPyModule_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddObject))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_AddObject, CPythonLibraryInterface_CPyModule_AddObject_Offset) = CPythonLibraryInterface_CPyModule_AddObject_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddType))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_AddType, CPythonLibraryInterface_CPyModule_AddType_Offset) = CPythonLibraryInterface_CPyModule_AddType_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_GetDict))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_GetDict, CPythonLibraryInterface_CPyModule_GetDict_Offset) = CPythonLibraryInterface_CPyModule_GetDict_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddIntConstant))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_AddIntConstant, CPythonLibraryInterface_CPyModule_AddIntConstant_Offset) = CPythonLibraryInterface_CPyModule_AddIntConstant_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_ImportModule))
		{
			maxon::Tie(CPythonLibraryInterface_CPyImport_ImportModule, CPythonLibraryInterface_CPyImport_ImportModule_Offset) = CPythonLibraryInterface_CPyImport_ImportModule_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_GetImporter))
		{
			maxon::Tie(CPythonLibraryInterface_CPyImport_GetImporter, CPythonLibraryInterface_CPyImport_GetImporter_Offset) = CPythonLibraryInterface_CPyImport_GetImporter_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_GetModuleDict))
		{
			maxon::Tie(CPythonLibraryInterface_CPyImport_GetModuleDict, CPythonLibraryInterface_CPyImport_GetModuleDict_Offset) = CPythonLibraryInterface_CPyImport_GetModuleDict_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_Check, CPythonLibraryInterface_CPyType_Check_Offset) = CPythonLibraryInterface_CPyType_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_IsSubtype))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_IsSubtype, CPythonLibraryInterface_CPyType_IsSubtype_Offset) = CPythonLibraryInterface_CPyType_IsSubtype_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_HasFeature))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_HasFeature, CPythonLibraryInterface_CPyType_HasFeature_Offset) = CPythonLibraryInterface_CPyType_HasFeature_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_FastSubclass))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_FastSubclass, CPythonLibraryInterface_CPyType_FastSubclass_Offset) = CPythonLibraryInterface_CPyType_FastSubclass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_GetName))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_GetName, CPythonLibraryInterface_CPyType_GetName_Offset) = CPythonLibraryInterface_CPyType_GetName_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Ready))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_Ready, CPythonLibraryInterface_CPyType_Ready_Offset) = CPythonLibraryInterface_CPyType_Ready_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_SaveThread))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_SaveThread, CPythonLibraryInterface_CPyEval_SaveThread_Offset) = CPythonLibraryInterface_CPyEval_SaveThread_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_RestoreThread))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_RestoreThread, CPythonLibraryInterface_CPyEval_RestoreThread_Offset) = CPythonLibraryInterface_CPyEval_RestoreThread_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_ThreadsInitialized))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_ThreadsInitialized, CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset) = CPythonLibraryInterface_CPyEval_ThreadsInitialized_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_InitThreads))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_InitThreads, CPythonLibraryInterface_CPyEval_InitThreads_Offset) = CPythonLibraryInterface_CPyEval_InitThreads_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_AcquireThread))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_AcquireThread, CPythonLibraryInterface_CPyEval_AcquireThread_Offset) = CPythonLibraryInterface_CPyEval_AcquireThread_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseThread))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_ReleaseThread, CPythonLibraryInterface_CPyEval_ReleaseThread_Offset) = CPythonLibraryInterface_CPyEval_ReleaseThread_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_GetBuiltins))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_GetBuiltins, CPythonLibraryInterface_CPyEval_GetBuiltins_Offset) = CPythonLibraryInterface_CPyEval_GetBuiltins_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_EvalCode))
		{
			maxon::Tie(CPythonLibraryInterface_CPyEval_EvalCode, CPythonLibraryInterface_CPyEval_EvalCode_Offset) = CPythonLibraryInterface_CPyEval_EvalCode_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyFloat_Check, CPythonLibraryInterface_CPyFloat_Check_Offset) = CPythonLibraryInterface_CPyFloat_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat32))
		{
			maxon::Tie(CPythonLibraryInterface_CPyFloat_FromFloat32, CPythonLibraryInterface_CPyFloat_FromFloat32_Offset) = CPythonLibraryInterface_CPyFloat_FromFloat32_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyFloat_FromFloat64, CPythonLibraryInterface_CPyFloat_FromFloat64_Offset) = CPythonLibraryInterface_CPyFloat_FromFloat64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_AsFloat64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyFloat_AsFloat64, CPythonLibraryInterface_CPyFloat_AsFloat64_Offset) = CPythonLibraryInterface_CPyFloat_AsFloat64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_Check, CPythonLibraryInterface_CPyLong_Check_Offset) = CPythonLibraryInterface_CPyLong_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyBool_FromBool))
		{
			maxon::Tie(CPythonLibraryInterface_CPyBool_FromBool, CPythonLibraryInterface_CPyBool_FromBool_Offset) = CPythonLibraryInterface_CPyBool_FromBool_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt16))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromInt16, CPythonLibraryInterface_CPyLong_FromInt16_Offset) = CPythonLibraryInterface_CPyLong_FromInt16_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt16))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromUInt16, CPythonLibraryInterface_CPyLong_FromUInt16_Offset) = CPythonLibraryInterface_CPyLong_FromUInt16_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt32))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromInt32, CPythonLibraryInterface_CPyLong_FromInt32_Offset) = CPythonLibraryInterface_CPyLong_FromInt32_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt32))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromUInt32, CPythonLibraryInterface_CPyLong_FromUInt32_Offset) = CPythonLibraryInterface_CPyLong_FromUInt32_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromInt64, CPythonLibraryInterface_CPyLong_FromInt64_Offset) = CPythonLibraryInterface_CPyLong_FromInt64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_FromUInt64, CPythonLibraryInterface_CPyLong_FromUInt64_Offset) = CPythonLibraryInterface_CPyLong_FromUInt64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt16))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsInt16, CPythonLibraryInterface_CPyLong_AsInt16_Offset) = CPythonLibraryInterface_CPyLong_AsInt16_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt16))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsUInt16, CPythonLibraryInterface_CPyLong_AsUInt16_Offset) = CPythonLibraryInterface_CPyLong_AsUInt16_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt32))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsInt32, CPythonLibraryInterface_CPyLong_AsInt32_Offset) = CPythonLibraryInterface_CPyLong_AsInt32_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt32))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsUInt32, CPythonLibraryInterface_CPyLong_AsUInt32_Offset) = CPythonLibraryInterface_CPyLong_AsUInt32_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsInt64, CPythonLibraryInterface_CPyLong_AsInt64_Offset) = CPythonLibraryInterface_CPyLong_AsInt64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt64))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_AsUInt64, CPythonLibraryInterface_CPyLong_AsUInt64_Offset) = CPythonLibraryInterface_CPyLong_AsUInt64_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyNumber_Check))
		{
			maxon::Tie(CPythonLibraryInterface_CPyNumber_Check, CPythonLibraryInterface_CPyNumber_Check_Offset) = CPythonLibraryInterface_CPyNumber_Check_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyFunction_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyFunction_New, CPythonLibraryInterface_MPyFunction_New_Offset) = CPythonLibraryInterface_MPyFunction_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyHashMap_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyHashMap_New, CPythonLibraryInterface_MPyHashMap_New_Offset) = CPythonLibraryInterface_MPyHashMap_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyHashMap_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyHashMap_New_1, CPythonLibraryInterface_MPyHashMap_New_1_Offset) = CPythonLibraryInterface_MPyHashMap_New_1_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyMember_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyMember_New, CPythonLibraryInterface_MPyMember_New_Offset) = CPythonLibraryInterface_MPyMember_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyMem_SetAllocator))
		{
			maxon::Tie(CPythonLibraryInterface_CPyMem_SetAllocator, CPythonLibraryInterface_CPyMem_SetAllocator_Offset) = CPythonLibraryInterface_CPyMem_SetAllocator_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyClass_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyClass_New, CPythonLibraryInterface_MPyClass_New_Offset) = CPythonLibraryInterface_MPyClass_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_DebugFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_DebugFlag, CPythonLibraryInterface_CPy_DebugFlag_Offset) = CPythonLibraryInterface_CPy_DebugFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_VerboseFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_VerboseFlag, CPythonLibraryInterface_CPy_VerboseFlag_Offset) = CPythonLibraryInterface_CPy_VerboseFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_InteractiveFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_InteractiveFlag, CPythonLibraryInterface_CPy_InteractiveFlag_Offset) = CPythonLibraryInterface_CPy_InteractiveFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_InspectFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_InspectFlag, CPythonLibraryInterface_CPy_InspectFlag_Offset) = CPythonLibraryInterface_CPy_InspectFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_OptimizeFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_OptimizeFlag, CPythonLibraryInterface_CPy_OptimizeFlag_Offset) = CPythonLibraryInterface_CPy_OptimizeFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NoSiteFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_NoSiteFlag, CPythonLibraryInterface_CPy_NoSiteFlag_Offset) = CPythonLibraryInterface_CPy_NoSiteFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_BytesWarningFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_BytesWarningFlag, CPythonLibraryInterface_CPy_BytesWarningFlag_Offset) = CPythonLibraryInterface_CPy_BytesWarningFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_FrozenFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_FrozenFlag, CPythonLibraryInterface_CPy_FrozenFlag_Offset) = CPythonLibraryInterface_CPy_FrozenFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_IgnoreEnvironmentFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset) = CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_DontWriteBytecodeFlag))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_DontWriteBytecodeFlag, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset) = CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NoUserSiteDirectory))
		{
			maxon::Tie(CPythonLibraryInterface_CPy_NoUserSiteDirectory, CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset) = CPythonLibraryInterface_CPy_NoUserSiteDirectory_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BaseException))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_BaseException, CPythonLibraryInterface_CPyExc_BaseException_Offset) = CPythonLibraryInterface_CPyExc_BaseException_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_Exception))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_Exception, CPythonLibraryInterface_CPyExc_Exception_Offset) = CPythonLibraryInterface_CPyExc_Exception_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_StopIteration))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_StopIteration, CPythonLibraryInterface_CPyExc_StopIteration_Offset) = CPythonLibraryInterface_CPyExc_StopIteration_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_GeneratorExit))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_GeneratorExit, CPythonLibraryInterface_CPyExc_GeneratorExit_Offset) = CPythonLibraryInterface_CPyExc_GeneratorExit_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_StandardError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_StandardError, CPythonLibraryInterface_CPyExc_StandardError_Offset) = CPythonLibraryInterface_CPyExc_StandardError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ArithmeticError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ArithmeticError, CPythonLibraryInterface_CPyExc_ArithmeticError_Offset) = CPythonLibraryInterface_CPyExc_ArithmeticError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_LookupError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_LookupError, CPythonLibraryInterface_CPyExc_LookupError_Offset) = CPythonLibraryInterface_CPyExc_LookupError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_AssertionError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_AssertionError, CPythonLibraryInterface_CPyExc_AssertionError_Offset) = CPythonLibraryInterface_CPyExc_AssertionError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_AttributeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_AttributeError, CPythonLibraryInterface_CPyExc_AttributeError_Offset) = CPythonLibraryInterface_CPyExc_AttributeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_EOFError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_EOFError, CPythonLibraryInterface_CPyExc_EOFError_Offset) = CPythonLibraryInterface_CPyExc_EOFError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_FloatingPointError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_FloatingPointError, CPythonLibraryInterface_CPyExc_FloatingPointError_Offset) = CPythonLibraryInterface_CPyExc_FloatingPointError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_EnvironmentError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_EnvironmentError, CPythonLibraryInterface_CPyExc_EnvironmentError_Offset) = CPythonLibraryInterface_CPyExc_EnvironmentError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IOError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_IOError, CPythonLibraryInterface_CPyExc_IOError_Offset) = CPythonLibraryInterface_CPyExc_IOError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_OSError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_OSError, CPythonLibraryInterface_CPyExc_OSError_Offset) = CPythonLibraryInterface_CPyExc_OSError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ImportError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ImportError, CPythonLibraryInterface_CPyExc_ImportError_Offset) = CPythonLibraryInterface_CPyExc_ImportError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IndexError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_IndexError, CPythonLibraryInterface_CPyExc_IndexError_Offset) = CPythonLibraryInterface_CPyExc_IndexError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_KeyError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_KeyError, CPythonLibraryInterface_CPyExc_KeyError_Offset) = CPythonLibraryInterface_CPyExc_KeyError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_KeyboardInterrupt))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_KeyboardInterrupt, CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset) = CPythonLibraryInterface_CPyExc_KeyboardInterrupt_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_MemoryError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_MemoryError, CPythonLibraryInterface_CPyExc_MemoryError_Offset) = CPythonLibraryInterface_CPyExc_MemoryError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_NameError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_NameError, CPythonLibraryInterface_CPyExc_NameError_Offset) = CPythonLibraryInterface_CPyExc_NameError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_OverflowError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_OverflowError, CPythonLibraryInterface_CPyExc_OverflowError_Offset) = CPythonLibraryInterface_CPyExc_OverflowError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_RuntimeError, CPythonLibraryInterface_CPyExc_RuntimeError_Offset) = CPythonLibraryInterface_CPyExc_RuntimeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_NotImplementedError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_NotImplementedError, CPythonLibraryInterface_CPyExc_NotImplementedError_Offset) = CPythonLibraryInterface_CPyExc_NotImplementedError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_SyntaxError, CPythonLibraryInterface_CPyExc_SyntaxError_Offset) = CPythonLibraryInterface_CPyExc_SyntaxError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IndentationError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_IndentationError, CPythonLibraryInterface_CPyExc_IndentationError_Offset) = CPythonLibraryInterface_CPyExc_IndentationError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_TabError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_TabError, CPythonLibraryInterface_CPyExc_TabError_Offset) = CPythonLibraryInterface_CPyExc_TabError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ReferenceError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ReferenceError, CPythonLibraryInterface_CPyExc_ReferenceError_Offset) = CPythonLibraryInterface_CPyExc_ReferenceError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SystemError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_SystemError, CPythonLibraryInterface_CPyExc_SystemError_Offset) = CPythonLibraryInterface_CPyExc_SystemError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SystemExit))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_SystemExit, CPythonLibraryInterface_CPyExc_SystemExit_Offset) = CPythonLibraryInterface_CPyExc_SystemExit_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_TypeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_TypeError, CPythonLibraryInterface_CPyExc_TypeError_Offset) = CPythonLibraryInterface_CPyExc_TypeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnboundLocalError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnboundLocalError, CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset) = CPythonLibraryInterface_CPyExc_UnboundLocalError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnicodeError, CPythonLibraryInterface_CPyExc_UnicodeError_Offset) = CPythonLibraryInterface_CPyExc_UnicodeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeEncodeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnicodeEncodeError, CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset) = CPythonLibraryInterface_CPyExc_UnicodeEncodeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeDecodeError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnicodeDecodeError, CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset) = CPythonLibraryInterface_CPyExc_UnicodeDecodeError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeTranslateError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnicodeTranslateError, CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset) = CPythonLibraryInterface_CPyExc_UnicodeTranslateError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ValueError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ValueError, CPythonLibraryInterface_CPyExc_ValueError_Offset) = CPythonLibraryInterface_CPyExc_ValueError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ZeroDivisionError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ZeroDivisionError, CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset) = CPythonLibraryInterface_CPyExc_ZeroDivisionError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_WindowsError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_WindowsError, CPythonLibraryInterface_CPyExc_WindowsError_Offset) = CPythonLibraryInterface_CPyExc_WindowsError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BufferError))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_BufferError, CPythonLibraryInterface_CPyExc_BufferError_Offset) = CPythonLibraryInterface_CPyExc_BufferError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_MemoryErrorInst))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_MemoryErrorInst, CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset) = CPythonLibraryInterface_CPyExc_MemoryErrorInst_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_Warning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_Warning, CPythonLibraryInterface_CPyExc_Warning_Offset) = CPythonLibraryInterface_CPyExc_Warning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UserWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UserWarning, CPythonLibraryInterface_CPyExc_UserWarning_Offset) = CPythonLibraryInterface_CPyExc_UserWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_DeprecationWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_DeprecationWarning, CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset) = CPythonLibraryInterface_CPyExc_DeprecationWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_PendingDeprecationWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_PendingDeprecationWarning, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset) = CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_SyntaxWarning, CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset) = CPythonLibraryInterface_CPyExc_SyntaxWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_RuntimeWarning, CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset) = CPythonLibraryInterface_CPyExc_RuntimeWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_FutureWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_FutureWarning, CPythonLibraryInterface_CPyExc_FutureWarning_Offset) = CPythonLibraryInterface_CPyExc_FutureWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ImportWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_ImportWarning, CPythonLibraryInterface_CPyExc_ImportWarning_Offset) = CPythonLibraryInterface_CPyExc_ImportWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_UnicodeWarning, CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset) = CPythonLibraryInterface_CPyExc_UnicodeWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BytesWarning))
		{
			maxon::Tie(CPythonLibraryInterface_CPyExc_BytesWarning, CPythonLibraryInterface_CPyExc_BytesWarning_Offset) = CPythonLibraryInterface_CPyExc_BytesWarning_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyNullImporter_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyNullImporter_Type, CPythonLibraryInterface_CPyNullImporter_Type_Offset) = CPythonLibraryInterface_CPyNullImporter_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySuper_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPySuper_Type, CPythonLibraryInterface_CPySuper_Type_Offset) = CPythonLibraryInterface_CPySuper_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyBool_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyBool_Type, CPythonLibraryInterface_CPyBool_Type_Offset) = CPythonLibraryInterface_CPyBool_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_Type, CPythonLibraryInterface_CPyObject_Type_Offset) = CPythonLibraryInterface_CPyObject_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyModule_Type, CPythonLibraryInterface_CPyModule_Type_Offset) = CPythonLibraryInterface_CPyModule_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyUnicode_Type, CPythonLibraryInterface_CPyUnicode_Type_Offset) = CPythonLibraryInterface_CPyUnicode_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyLong_Type, CPythonLibraryInterface_CPyLong_Type_Offset) = CPythonLibraryInterface_CPyLong_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyFloat_Type, CPythonLibraryInterface_CPyFloat_Type_Offset) = CPythonLibraryInterface_CPyFloat_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTuple_Type, CPythonLibraryInterface_CPyTuple_Type_Offset) = CPythonLibraryInterface_CPyTuple_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyList_Type, CPythonLibraryInterface_CPyList_Type_Offset) = CPythonLibraryInterface_CPyList_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyDict_Type, CPythonLibraryInterface_CPyDict_Type_Offset) = CPythonLibraryInterface_CPyDict_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyClass_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyClass_Type, CPythonLibraryInterface_CPyClass_Type_Offset) = CPythonLibraryInterface_CPyClass_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTraceBack_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyTraceBack_Type, CPythonLibraryInterface_CPyTraceBack_Type_Offset) = CPythonLibraryInterface_CPyTraceBack_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySlice_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPySlice_Type, CPythonLibraryInterface_CPySlice_Type_Offset) = CPythonLibraryInterface_CPySlice_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyType_Type, CPythonLibraryInterface_CPyType_Type_Offset) = CPythonLibraryInterface_CPyType_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyMemoryView_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyMemoryView_Type, CPythonLibraryInterface_CPyMemoryView_Type_Offset) = CPythonLibraryInterface_CPyMemoryView_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ConvertAndCacheString))
		{
			maxon::Tie(CPythonLibraryInterface_ConvertAndCacheString, CPythonLibraryInterface_ConvertAndCacheString_Offset) = CPythonLibraryInterface_ConvertAndCacheString_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterSpecificPythonClass))
		{
			maxon::Tie(CPythonLibraryInterface_RegisterSpecificPythonClass, CPythonLibraryInterface_RegisterSpecificPythonClass_Offset) = CPythonLibraryInterface_RegisterSpecificPythonClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, PrivateRegisterBuiltinConverter))
		{
			maxon::Tie(CPythonLibraryInterface_PrivateRegisterBuiltinConverter, CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset) = CPythonLibraryInterface_PrivateRegisterBuiltinConverter_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetSpecialPath))
		{
			maxon::Tie(CPythonLibraryInterface_GetSpecialPath, CPythonLibraryInterface_GetSpecialPath_Offset) = CPythonLibraryInterface_GetSpecialPath_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterSpecialPath))
		{
			maxon::Tie(CPythonLibraryInterface_RegisterSpecialPath, CPythonLibraryInterface_RegisterSpecialPath_Offset) = CPythonLibraryInterface_RegisterSpecialPath_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataCapsule_Type))
		{
			maxon::Tie(CPythonLibraryInterface_MPyDataCapsule_Type, CPythonLibraryInterface_MPyDataCapsule_Type_Offset) = CPythonLibraryInterface_MPyDataCapsule_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyData_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyData_Type, CPythonLibraryInterface_CPyData_Type_Offset) = CPythonLibraryInterface_CPyData_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyCapsule_Type, CPythonLibraryInterface_CPyCapsule_Type_Offset) = CPythonLibraryInterface_CPyCapsule_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyId_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyId_Type, CPythonLibraryInterface_CPyId_Type_Offset) = CPythonLibraryInterface_CPyId_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyInternedId_Type))
		{
			maxon::Tie(CPythonLibraryInterface_CPyInternedId_Type, CPythonLibraryInterface_CPyInternedId_Type_Offset) = CPythonLibraryInterface_CPyInternedId_Type_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, PrivateGetCurrentCallerContext))
		{
			maxon::Tie(CPythonLibraryInterface_PrivateGetCurrentCallerContext, CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset) = CPythonLibraryInterface_PrivateGetCurrentCallerContext_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_ToMapperInstance))
		{
			maxon::Tie(CPythonLibraryInterface_MPyDataType_ToMapperInstance, CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset) = CPythonLibraryInterface_MPyDataType_ToMapperInstance_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_ToMapperInstance))
		{
			maxon::Tie(CPythonLibraryInterface_MPyData_ToMapperInstance, CPythonLibraryInterface_MPyData_ToMapperInstance_Offset) = CPythonLibraryInterface_MPyData_ToMapperInstance_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_ToMapperInstance))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_ToMapperInstance, CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset) = CPythonLibraryInterface_CPyObject_ToMapperInstance_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, AssociateDataTypeWithPythonTypes))
		{
			maxon::Tie(CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset) = CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetAssociatedDataType))
		{
			maxon::Tie(CPythonLibraryInterface_GetAssociatedDataType, CPythonLibraryInterface_GetAssociatedDataType_Offset) = CPythonLibraryInterface_GetAssociatedDataType_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetConverterPyObject_FromData))
		{
			maxon::Tie(CPythonLibraryInterface_GetConverterPyObject_FromData, CPythonLibraryInterface_GetConverterPyObject_FromData_Offset) = CPythonLibraryInterface_GetConverterPyObject_FromData_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyData_New, CPythonLibraryInterface_MPyData_New_Offset) = CPythonLibraryInterface_MPyData_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyData_New_1, CPythonLibraryInterface_MPyData_New_1_Offset) = CPythonLibraryInterface_MPyData_New_1_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_New))
		{
			maxon::Tie(CPythonLibraryInterface_MPyDataType_New, CPythonLibraryInterface_MPyDataType_New_Offset) = CPythonLibraryInterface_MPyDataType_New_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_CheckExact))
		{
			maxon::Tie(CPythonLibraryInterface_MPyDataType_CheckExact, CPythonLibraryInterface_MPyDataType_CheckExact_Offset) = CPythonLibraryInterface_MPyDataType_CheckExact_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_GetDataType))
		{
			maxon::Tie(CPythonLibraryInterface_MPyDataType_GetDataType, CPythonLibraryInterface_MPyDataType_GetDataType_Offset) = CPythonLibraryInterface_MPyDataType_GetDataType_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_CheckExact))
		{
			maxon::Tie(CPythonLibraryInterface_MPyData_CheckExact, CPythonLibraryInterface_MPyData_CheckExact_Offset) = CPythonLibraryInterface_MPyData_CheckExact_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_AsData))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_AsData, CPythonLibraryInterface_CPyObject_AsData_Offset) = CPythonLibraryInterface_CPyObject_AsData_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetRegisteredTypesWithConversions))
		{
			maxon::Tie(CPythonLibraryInterface_GetRegisteredTypesWithConversions, CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset) = CPythonLibraryInterface_GetRegisteredTypesWithConversions_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ParseDataType))
		{
			maxon::Tie(CPythonLibraryInterface_ParseDataType, CPythonLibraryInterface_ParseDataType_Offset) = CPythonLibraryInterface_ParseDataType_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, SetError))
		{
			maxon::Tie(CPythonLibraryInterface_SetError, CPythonLibraryInterface_SetError_Offset) = CPythonLibraryInterface_SetError_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, SetError))
		{
			maxon::Tie(CPythonLibraryInterface_SetError_1, CPythonLibraryInterface_SetError_1_Offset) = CPythonLibraryInterface_SetError_1_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MaxonConvertAuto))
		{
			maxon::Tie(CPythonLibraryInterface_MaxonConvertAuto, CPythonLibraryInterface_MaxonConvertAuto_Offset) = CPythonLibraryInterface_MaxonConvertAuto_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_FromGeneric))
		{
			maxon::Tie(CPythonLibraryInterface_CPyObject_FromGeneric, CPythonLibraryInterface_CPyObject_FromGeneric_Offset) = CPythonLibraryInterface_CPyObject_FromGeneric_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CreateGlobalDictionary))
		{
			maxon::Tie(CPythonLibraryInterface_CreateGlobalDictionary, CPythonLibraryInterface_CreateGlobalDictionary_Offset) = CPythonLibraryInterface_CreateGlobalDictionary_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCurrentTraceback))
		{
			maxon::Tie(CPythonLibraryInterface_GetCurrentTraceback, CPythonLibraryInterface_GetCurrentTraceback_Offset) = CPythonLibraryInterface_GetCurrentTraceback_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetCPyRefClass, CPythonLibraryInterface_GetCPyRefClass_Offset) = CPythonLibraryInterface_GetCPyRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyTypeRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetCPyTypeRefClass, CPythonLibraryInterface_GetCPyTypeRefClass_Offset) = CPythonLibraryInterface_GetCPyTypeRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyFrameRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetCPyFrameRefClass, CPythonLibraryInterface_GetCPyFrameRefClass_Offset) = CPythonLibraryInterface_GetCPyFrameRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyTracebackRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetCPyTracebackRefClass, CPythonLibraryInterface_GetCPyTracebackRefClass_Offset) = CPythonLibraryInterface_GetCPyTracebackRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyCodeRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetCPyCodeRefClass, CPythonLibraryInterface_GetCPyCodeRefClass_Offset) = CPythonLibraryInterface_GetCPyCodeRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyClassRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyClassRefClass, CPythonLibraryInterface_GetMPyClassRefClass_Offset) = CPythonLibraryInterface_GetMPyClassRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyMemberRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyMemberRefClass, CPythonLibraryInterface_GetMPyMemberRefClass_Offset) = CPythonLibraryInterface_GetMPyMemberRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyFunctionRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyFunctionRefClass, CPythonLibraryInterface_GetMPyFunctionRefClass_Offset) = CPythonLibraryInterface_GetMPyFunctionRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyHashMapRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyHashMapRefClass, CPythonLibraryInterface_GetMPyHashMapRefClass_Offset) = CPythonLibraryInterface_GetMPyHashMapRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyDataTypeRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyDataTypeRefClass, CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset) = CPythonLibraryInterface_GetMPyDataTypeRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyDataRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyDataRefClass, CPythonLibraryInterface_GetMPyDataRefClass_Offset) = CPythonLibraryInterface_GetMPyDataRefClass_GetPtr<W>(offset, true);
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyCallerContextRefClass))
		{
			maxon::Tie(CPythonLibraryInterface_GetMPyCallerContextRefClass, CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset) = CPythonLibraryInterface_GetMPyCallerContextRefClass_GetPtr<W>(offset, true);
		}
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<CPythonLibraryInterface, typename LibraryInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<CPythonLibraryInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct CPythonLibraryInterface::Hxx2
	{
		class Unresolved;
		struct StaticMTable
		{
			static StaticMTable _instance;
			static StaticMTable _unresolvedInstance;
			static maxon::Bool InitUnresolved(maxon::NonvirtualInterfaceReference::UnresolvedAssembler assembler, StaticMTable* tbl);
			static const maxon::Char* const _ids;
			static const maxon::NULL_RETURN_TYPE _returnTypes[];
		PRIVATE_MAXON_SF_POINTER(CPythonLibraryInterface_ParseCommandLine, ParseCommandLine, MAXON_EXPAND_VA_ARGS, (Result<PYSTARTOPERATION>), BaseArray<String>* args, Data* res, PYTHONFLAG* flags);
		PRIVATE_MAXON_SF_POINTER(CPythonLibraryInterface_GetUrl, GetUrl, MAXON_EXPAND_VA_ARGS, (Result<void>), DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome);
			StaticMTable() = default;
			template <typename IMPL> static void Init(StaticMTable* tbl)
			{
			tbl->CPythonLibraryInterface_ParseCommandLine = CPythonLibraryInterface_ParseCommandLine_GetPtr<IMPL>(true);
			tbl->CPythonLibraryInterface_GetUrl = CPythonLibraryInterface_GetUrl_GetPtr<IMPL>(true);
			}
		};
		template <typename S> class CWrapper : public LibraryInterface::Hxx2::template CWrapper<S>
		{
		public:
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(AssociateDataTypeWithPythonTypes);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_FromBool);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallable_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallerContext_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetPointer);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetPointer);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCode_Addr2Line);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyData_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Contains);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Copy);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Items);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Keys);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Next);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Values);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_ExceptionMatches);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Fetch);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_NormalizeException);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Occurred);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Print);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Restore);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetNone);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrno);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrnoAndFilename);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_AcquireThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_EvalCode);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_GetBuiltins);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_InitThreads);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ReleaseThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_RestoreThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_SaveThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ThreadsInitialized);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ArithmeticError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AssertionError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AttributeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BaseException);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BufferError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BytesWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_DeprecationWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EOFError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EnvironmentError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Exception);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FloatingPointError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FutureWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_GeneratorExit);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IOError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndentationError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndexError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyboardInterrupt);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_LookupError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryErrorInst);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NameError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NotImplementedError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OSError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OverflowError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_PendingDeprecationWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ReferenceError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StandardError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StopIteration);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemExit);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TabError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TypeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnboundLocalError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeDecodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeEncodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeTranslateError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UserWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ValueError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Warning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_WindowsError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ZeroDivisionError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExceptionClass_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_AsFloat64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGC_Collect);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGILState_GetThisThreadState);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Ensure);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Release);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyId_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_GetImporter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_GetModuleDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_ImportModule);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInternedId_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyIter_Next);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Append);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_AsTuple);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Insert);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Reverse);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Sort);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyMem_SetAllocator);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyMemoryView_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddIntConstant);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Create);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_GetDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNullImporter_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNumber_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_AsData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Call);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_CallFunction);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_DelItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Dir);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_FromGeneric);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemInt);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetIter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_HasAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Hash);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_IsTrue);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Length);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Not);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Repr);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_RichCompare);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Str);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_TypeCheck);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_FileExFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_InteractiveLoopFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleFileExFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleStringFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySite_AddSiteDir);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySlice_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySuper_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetArgvEx);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_GetDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_Swap);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_FastSubclass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_GetName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_HasFeature);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_IsSubtype);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Ready);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_AsCString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_AsString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_FromString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_FromStringAndSize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_GetLength);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_BytesWarningFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_CompileStringFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DebugFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Decref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DontWriteBytecodeFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_False);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Finalize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_FrozenFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetBuildInfo);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCompiler);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCopyright);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPlatform);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetProgramName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPythonHome);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetVersion);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IgnoreEnvironmentFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Incref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Initialize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InspectFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InteractiveFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IsInitialized);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoSiteFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoUserSiteDirectory);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_None);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NotImplemented);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_OptimizeFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeDecref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeIncref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetProgramName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetPythonHome);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_True);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_VerboseFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ConvertAndCacheString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CreateGlobalDictionary);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ExecuteModule);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(FopenNative);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Free);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetAssociatedDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyCodeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyFrameRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTracebackRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTypeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConverterPyObject_FromData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCurrentTraceback);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetDll);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetGilState);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyCallerContextRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyClassRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataTypeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyFunctionRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyHashMapRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyMemberRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetRegisteredTypesWithConversions);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetSpecialPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Init);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitBuiltinModules);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitTypes);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(LastPythonCallFailed);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyClass_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataCapsule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_GetDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyFunction_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyHashMap_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyMember_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MaxonConvertAuto);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ParseDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateGetCurrentCallerContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateRegisterBuiltinConverter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterComponentProxy);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecialPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecificPythonClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackDataType);
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename LibraryInterface::Hxx2::template CWrapper<S>;
				if constexpr (!S::Implementation::PROXY)
				{
					if (!(Super0::InitMTablesWithBases(info, offset))) return false;
				}
				auto* vt = (CPythonLibraryInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, CPythonLibraryInterface::_interface); if (!vt) return false;
				vt->template Init<CWrapper>(offset);
				return true;
			}
			static Result<PYSTARTOPERATION> CPythonLibraryInterface_ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) { return S::Implementation::ParseCommandLine(args, res, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_Init, maxon::GenericComponent,, (Result<void>), const Url& librarypath, Bool createSubLibrary) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->Init(librarypath, createSubLibrary); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_InitTypes, maxon::GenericComponent,, (Result<void>)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->InitTypes(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_InitBuiltinModules, maxon::GenericComponent,, (Result<void>)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->InitBuiltinModules(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_Initialize, maxon::GenericComponent,, (void)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_Initialize(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_Finalize, maxon::GenericComponent,, (void)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_Finalize(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_Create, maxon::GenericComponent,, (CPyRef), const ModuleDefinition& module) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_Create(module); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_Free, maxon::GenericComponent,, (void), const Delegate<void()>& shutdownEngine) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->Free(shutdownEngine); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetDll, maxon::GenericComponent, const, (const PythonDll&)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetDll(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_FopenNative, maxon::GenericComponent,, (FILE_native*), const Char* name, const Char* mode) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->FopenNative(name, mode); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_LastPythonCallFailed, maxon::GenericComponent,, (Error), const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->LastPythonCallFailed(allocLocation, withTraceback, restoreError); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_RegisterComponentProxy, maxon::GenericComponent,, (Result<MPyDataRef>), const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->RegisterComponentProxy(type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_IsInitialized, maxon::GenericComponent,, (Bool)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_IsInitialized(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetVersion, maxon::GenericComponent,, (const Char*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetVersion(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetPlatform, maxon::GenericComponent,, (const Char*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetPlatform(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetCopyright, maxon::GenericComponent,, (const Char*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetCopyright(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetCompiler, maxon::GenericComponent,, (const Char*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetCompiler(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetBuildInfo, maxon::GenericComponent,, (const Char*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetBuildInfo(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_SetProgramName, maxon::GenericComponent,, (Result<void>), const String& name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_SetProgramName(name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_SetPythonHome, maxon::GenericComponent,, (Result<void>), const Url& name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_SetPythonHome(name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetProgramName, maxon::GenericComponent,, (String)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetProgramName(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_GetPythonHome, maxon::GenericComponent,, (String)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_GetPythonHome(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_ExecuteModule, maxon::GenericComponent,, (Bool), const String& name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->ExecuteModule(name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCallerContext_New, maxon::GenericComponent,, (MPyCallerContextRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCallerContext_New(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyRun_SimpleFileExFlags, maxon::GenericComponent,, (Bool), FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyRun_SimpleFileExFlags(fp, filename, closeit, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, maxon::GenericComponent,, (Bool), const Url& url, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyRun_SimpleFileExFlags(url, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyRun_SimpleStringFlags, maxon::GenericComponent,, (CPyRef), const String& code, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyRun_SimpleStringFlags(code, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyRun_FileExFlags, maxon::GenericComponent,, (NativePyObject*), FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyRun_FileExFlags(fp, filename, start, globals, locals, closeit, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, maxon::GenericComponent,, (Result<void>), FILE* fp, const Char* filename, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyRun_InteractiveLoopFlags(fp, filename, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyGilState_Ensure, maxon::GenericComponent,, (PYGILSTATE)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyGilState_Ensure(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyGilState_Release, maxon::GenericComponent,, (void), PYGILSTATE state) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyGilState_Release(state); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetGilState, maxon::GenericComponent, const, (GILSTATE)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetGilState(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyGILState_GetThisThreadState, maxon::GenericComponent,, (NativePyThreadState*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyGILState_GetThisThreadState(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyThreadState_Swap, maxon::GenericComponent,, (NativePyThreadState*), NativePyThreadState* state) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyThreadState_Swap(state); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyThreadState_GetDict, maxon::GenericComponent,, (CPyRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyThreadState_GetDict(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_CompileStringFlags, maxon::GenericComponent,, (CPyCodeRef), const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_CompileStringFlags(code, filename, start, flags); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_Incref, maxon::GenericComponent, const, (void), NativePyObject* o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_Incref(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_Decref, maxon::GenericComponent, const, (void), NativePyObject* o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_Decref(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_SafeIncref, maxon::GenericComponent, const, (void), NativePyObject* o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_SafeIncref(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_SafeDecref, maxon::GenericComponent, const, (void), NativePyObject* o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_SafeDecref(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyGC_Collect, maxon::GenericComponent,, (Int64)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyGC_Collect(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCode_Addr2Line, maxon::GenericComponent,, (Int32), const CPyCodeRef& codeObject, Int32 x) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCode_Addr2Line(codeObject, x); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_UnpackDataType, maxon::GenericComponent,, (CPyRef), const CPyRef& obj) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->UnpackDataType(obj); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_UnpackData, maxon::GenericComponent,, (CPyRef), const CPyRef& obj) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->UnpackData(obj); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_None, maxon::GenericComponent, const, (CPyConstRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_None(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_True, maxon::GenericComponent, const, (CPyConstRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_True(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_False, maxon::GenericComponent, const, (CPyConstRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_False(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_NotImplemented, maxon::GenericComponent, const, (CPyConstRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPy_NotImplemented(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_Print, maxon::GenericComponent,, (void)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_Print(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_Clear, maxon::GenericComponent,, (void)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_Clear(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_Occurred, maxon::GenericComponent,, (Bool), CPyRef* type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_Occurred(type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_SetString, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, const Char* errorString) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_SetString(errorType, errorString); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, Int32 errorNumber, const Char* filename) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_SetWithErrnoAndFilename(errorType, errorNumber, filename); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_SetWithErrno, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, Int32 errorNumber) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_SetWithErrno(errorType, errorNumber); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_SetString_1, maxon::GenericComponent,, (CPyRef), const CPyRef& errorType, const String& errorString) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_SetString(errorType, errorString); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_SetNone, maxon::GenericComponent,, (void), const CPyRef& errorType) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_SetNone(errorType); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_Fetch, maxon::GenericComponent,, (void), CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_Fetch(type, value, traceback); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_NormalizeException, maxon::GenericComponent,, (void), CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_NormalizeException(type, value, traceback); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_Restore, maxon::GenericComponent,, (void), const CPyRef& type, const CPyRef& value, const CPyRef& traceback) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_Restore(type, value, traceback); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyErr_ExceptionMatches, maxon::GenericComponent,, (Bool), const CPyRef& exc) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyErr_ExceptionMatches(exc); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExceptionClass_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExceptionClass_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_New, maxon::GenericComponent, const, (CPyRef), void* pointer, const Char* name, CPyCapsule_Destructor* destructor) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyCapsule_New(pointer, name, destructor); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_SetPointer, maxon::GenericComponent,, (Bool), const CPyRef& capsule, void* pointer) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_SetPointer(capsule, pointer); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_GetPointer, maxon::GenericComponent,, (void*), const CPyRef& capsule, const Char* name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_GetPointer(capsule, name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_GetContext, maxon::GenericComponent,, (void*), const CPyRef& capsule) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_GetContext(capsule); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_SetContext, maxon::GenericComponent,, (Bool), const CPyRef& capsule, void* context) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_SetContext(capsule, context); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_CheckExact, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_CheckExact(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTraceBack_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTraceBack_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyClass_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyClass_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_New, maxon::GenericComponent, const, (CPyRef), UInt size) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyTuple_New(size); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_Size, maxon::GenericComponent,, (UInt), const CPyRef& tuple) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_Size(tuple); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_GetItem, maxon::GenericComponent,, (CPyRef), const CPyRef& tuple, UInt index) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_GetItem(tuple, index); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_SetItem, maxon::GenericComponent,, (Bool), const CPyRef& tuple, UInt index, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_SetItem(tuple, index, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_GetSlice, maxon::GenericComponent,, (CPyRef), const CPyRef& tuple, UInt from, UInt to) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_GetSlice(tuple, from, to); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_CheckExact, maxon::GenericComponent,, (Bool), const CPyRef& tuple) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_CheckExact(tuple); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_HasAttrString, maxon::GenericComponent,, (Bool), const CPyRef& o, const Char* attrName) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_HasAttrString(o, attrName); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_SetAttrString, maxon::GenericComponent,, (Bool), const CPyRef& o, const Char* name, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_SetAttrString(o, name, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_GetAttrString, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const Char* name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_GetAttrString(o, name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Call, maxon::GenericComponent,, (CPyRef), const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Call(callable_object, tupleArg, kw); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Str, maxon::GenericComponent,, (CPyRef), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Str(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Repr, maxon::GenericComponent,, (CPyRef), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Repr(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Dir, maxon::GenericComponent,, (CPyRef), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Dir(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_RichCompare, maxon::GenericComponent,, (CPyRef), const CPyRef& o1, const CPyRef& o2, Int32 opid) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_RichCompare(o1, o2, opid); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Hash, maxon::GenericComponent,, (Int64), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Hash(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_IsTrue, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_IsTrue(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Not, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Not(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCallable_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCallable_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Length, maxon::GenericComponent,, (Int), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Length(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_GetItem, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_GetItem(o, key); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_GetItemInt, maxon::GenericComponent,, (CPyRef), const CPyRef& o, Int index) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_GetItemInt(o, index); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_GetItemString, maxon::GenericComponent,, (CPyRef), const CPyRef& o, const Char* index) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_GetItemString(o, index); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_DelItem, maxon::GenericComponent,, (Bool), const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_DelItem(o, key); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_SetItem, maxon::GenericComponent,, (Bool), const CPyRef& o, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_SetItem(o, key, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_TypeCheck, maxon::GenericComponent,, (Bool), const CPyRef& object, const CPyTypeRef& type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_TypeCheck(object, type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_CallFunction, maxon::GenericComponent,, (CPyRef), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_CallFunction(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySys_GetObject, maxon::GenericComponent,, (CPyRef), const Char* name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySys_GetObject(name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySys_SetObject, maxon::GenericComponent,, (Bool), const Char* name, const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySys_SetObject(name, o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_SetPath, maxon::GenericComponent,, (Result<void>), const BaseArray<Url>& paths) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_SetPath(paths); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySys_SetPath, maxon::GenericComponent,, (Result<void>), const BaseArray<Url>& paths, PATHHANDLE add) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySys_SetPath(paths, add); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySys_SetArgvEx, maxon::GenericComponent,, (Result<void>), const BaseArray<String>& args, Bool updatepath) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySys_SetArgvEx(args, updatepath); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySys_GetPath, maxon::GenericComponent,, (BaseArray<Url>)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySys_GetPath(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySite_AddSiteDir, maxon::GenericComponent,, (Result<void>), const Url& siteDir) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySite_AddSiteDir(siteDir); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_FromString, maxon::GenericComponent, const, (CPyRef), const Char* str) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyUnicode_FromString(str); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_FromStringAndSize, maxon::GenericComponent,, (CPyRef), const Block<const Char>& block) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_FromStringAndSize(block); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_AsString, maxon::GenericComponent,, (Result<String>), const CPyRef& str) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_AsString(str); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_AsCString, maxon::GenericComponent,, (const Char*), const CPyRef& str) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_AsCString(str); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_GetLength, maxon::GenericComponent,, (Int), const CPyRef& str) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_GetLength(str); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_GetIter, maxon::GenericComponent, const, (CPyRef), const CPyRef& o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyObject_GetIter(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyIter_Next, maxon::GenericComponent, const, (CPyRef), const CPyRef& it) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyIter_Next(it); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_New, maxon::GenericComponent, const, (CPyRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyDict_New(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_GetItem, maxon::GenericComponent,, (CPyRef), const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_GetItem(dict, key, raiseKeyError); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_GetItemString, maxon::GenericComponent,, (CPyRef), const CPyRef& dict, const Char* key, Bool raiseKeyError) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_GetItemString(dict, key, raiseKeyError); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_SetItem, maxon::GenericComponent,, (Bool), const CPyRef& dict, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_SetItem(dict, key, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_DelItem, maxon::GenericComponent,, (Bool), const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_DelItem(dict, key); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Contains, maxon::GenericComponent,, (CONTAINS), const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Contains(dict, key); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Clear, maxon::GenericComponent,, (void), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Clear(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Next, maxon::GenericComponent,, (Bool), const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Next(dict, pos, key, value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Keys, maxon::GenericComponent,, (CPyRef), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Keys(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Values, maxon::GenericComponent,, (CPyRef), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Values(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Items, maxon::GenericComponent,, (CPyRef), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Items(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Size, maxon::GenericComponent,, (Int), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Size(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Copy, maxon::GenericComponent,, (CPyRef), const CPyRef& dict) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Copy(dict); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_SetItemString, maxon::GenericComponent, const, (Bool), const CPyRef& dict, const Char* key, const CPyRef& item) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyDict_SetItemString(dict, key, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Check, maxon::GenericComponent, const, (Bool), const CPyRef& o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyDict_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_New, maxon::GenericComponent,, (CPyRef), UInt size) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_New(size); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_CheckExact, maxon::GenericComponent,, (Bool), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_CheckExact(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Clear, maxon::GenericComponent,, (Bool), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Clear(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Size, maxon::GenericComponent,, (Int), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Size(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_GetItem, maxon::GenericComponent,, (CPyRef), const CPyRef& list, UInt index) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_GetItem(list, index); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_SetItem, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_SetItem(list, anonymous_param_2, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Insert, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Insert(list, anonymous_param_2, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Append, maxon::GenericComponent,, (Bool), const CPyRef& list, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Append(list, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_GetSlice, maxon::GenericComponent,, (CPyRef), const CPyRef& list, UInt from, UInt to) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_GetSlice(list, from, to); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_SetSlice, maxon::GenericComponent,, (Bool), const CPyRef& list, UInt from, UInt to, const CPyRef& item) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_SetSlice(list, from, to, item); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Sort, maxon::GenericComponent,, (Bool), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Sort(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Reverse, maxon::GenericComponent,, (Bool), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Reverse(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_AsTuple, maxon::GenericComponent,, (CPyRef), const CPyRef& list) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_AsTuple(list); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_DelItemString, maxon::GenericComponent,, (Bool), const CPyRef& p, const Char* key) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_DelItemString(p, key); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_AddObject, maxon::GenericComponent,, (Result<Bool>), const CPyRef& module, const Char* name, const CPyRef& value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_AddObject(module, name, value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_AddType, maxon::GenericComponent,, (Bool), const CPyRef& module, const CPyTypeRef& value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_AddType(module, value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_GetDict, maxon::GenericComponent,, (CPyRef), const CPyRef& module) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_GetDict(module); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_AddIntConstant, maxon::GenericComponent,, (Bool), const CPyRef& mod, const Char* name, long value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_AddIntConstant(mod, name, value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyImport_ImportModule, maxon::GenericComponent,, (CPyRef), const Char* name) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyImport_ImportModule(name); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyImport_GetImporter, maxon::GenericComponent,, (CPyRef), const CPyRef& path) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyImport_GetImporter(path); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyImport_GetModuleDict, maxon::GenericComponent,, (CPyRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyImport_GetModuleDict(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyType_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_IsSubtype, maxon::GenericComponent,, (Bool), const CPyTypeRef& a, const CPyTypeRef& b) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyType_IsSubtype(a, b); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_HasFeature, maxon::GenericComponent, const, (Bool), const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyType_HasFeature(type, f); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_FastSubclass, maxon::GenericComponent, const, (Bool), const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyType_FastSubclass(type, f); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_GetName, maxon::GenericComponent,, (Result<String>), const CPyTypeRef& type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyType_GetName(type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_Ready, maxon::GenericComponent,, (Bool), CPyTypeRef& type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyType_Ready(type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_SaveThread, maxon::GenericComponent,, (NativePyThreadState*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_SaveThread(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_RestoreThread, maxon::GenericComponent,, (void), NativePyThreadState* state) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_RestoreThread(state); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_ThreadsInitialized, maxon::GenericComponent,, (Bool)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_ThreadsInitialized(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_InitThreads, maxon::GenericComponent,, (void)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_InitThreads(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_AcquireThread, maxon::GenericComponent,, (void), NativePyThreadState* state) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_AcquireThread(state); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_ReleaseThread, maxon::GenericComponent,, (void), NativePyThreadState* state) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyEval_ReleaseThread(state); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_GetBuiltins, maxon::GenericComponent, const, (CPyRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyEval_GetBuiltins(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyEval_EvalCode, maxon::GenericComponent, const, (CPyRef), const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CPyEval_EvalCode(code, globals, locals); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyFloat_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyFloat_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyFloat_FromFloat32, maxon::GenericComponent,, (CPyRef), Float32 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyFloat_FromFloat32(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyFloat_FromFloat64, maxon::GenericComponent,, (CPyRef), Float64 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyFloat_FromFloat64(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyFloat_AsFloat64, maxon::GenericComponent,, (Float64), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyFloat_AsFloat64(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyBool_FromBool, maxon::GenericComponent,, (CPyRef), Bool value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyBool_FromBool(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromInt16, maxon::GenericComponent,, (CPyRef), Int16 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromInt16(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromUInt16, maxon::GenericComponent,, (CPyRef), UInt16 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromUInt16(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromInt32, maxon::GenericComponent,, (CPyRef), Int32 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromInt32(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromUInt32, maxon::GenericComponent,, (CPyRef), UInt32 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromUInt32(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromInt64, maxon::GenericComponent,, (CPyRef), Int64 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromInt64(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_FromUInt64, maxon::GenericComponent,, (CPyRef), UInt64 value) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_FromUInt64(value); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsInt16, maxon::GenericComponent,, (Int16), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsInt16(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsUInt16, maxon::GenericComponent,, (UInt16), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsUInt16(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsInt32, maxon::GenericComponent,, (Int32), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsInt32(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsUInt32, maxon::GenericComponent,, (UInt32), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsUInt32(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsInt64, maxon::GenericComponent,, (Int64), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsInt64(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_AsUInt64, maxon::GenericComponent,, (UInt64), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_AsUInt64(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyNumber_Check, maxon::GenericComponent,, (Bool), const CPyRef& o) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyNumber_Check(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyFunction_New, maxon::GenericComponent,, (MPyFunctionRef), const reflection::Function* func) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyFunction_New(func); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyHashMap_New, maxon::GenericComponent,, (MPyHashMapRef), const HashMap<Data, Data>& map) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyHashMap_New(map); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyHashMap_New_1, maxon::GenericComponent,, (MPyHashMapRef), HashMap<Data, Data>&& map) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyHashMap_New(std::forward<HashMap<Data, Data>>(map)); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyMember_New, maxon::GenericComponent,, (MPyMemberRef), const reflection::Member* member) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyMember_New(member); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyMem_SetAllocator, maxon::GenericComponent,, (Result<void>), CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyMem_SetAllocator(std::forward<CPyMemAllocatorDomain>(domain), allocator); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyClass_New, maxon::GenericComponent,, (MPyClassRef), const reflection::Class* cls) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyClass_New(cls); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_DebugFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_DebugFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_VerboseFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_VerboseFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_InteractiveFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_InteractiveFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_InspectFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_InspectFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_OptimizeFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_OptimizeFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_NoSiteFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_NoSiteFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_BytesWarningFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_BytesWarningFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_FrozenFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_FrozenFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_IgnoreEnvironmentFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_DontWriteBytecodeFlag, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_DontWriteBytecodeFlag(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPy_NoUserSiteDirectory, maxon::GenericComponent,, (Int32*)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPy_NoUserSiteDirectory(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_BaseException, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_BaseException(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_Exception, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_Exception(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_StopIteration, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_StopIteration(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_GeneratorExit, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_GeneratorExit(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_StandardError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_StandardError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ArithmeticError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ArithmeticError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_LookupError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_LookupError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_AssertionError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_AssertionError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_AttributeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_AttributeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_EOFError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_EOFError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_FloatingPointError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_FloatingPointError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_EnvironmentError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_EnvironmentError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_IOError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_IOError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_OSError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_OSError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ImportError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ImportError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_IndexError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_IndexError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_KeyError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_KeyError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_KeyboardInterrupt, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_KeyboardInterrupt(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_MemoryError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_MemoryError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_NameError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_NameError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_OverflowError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_OverflowError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_RuntimeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_RuntimeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_NotImplementedError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_NotImplementedError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_SyntaxError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_SyntaxError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_IndentationError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_IndentationError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_TabError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_TabError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ReferenceError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ReferenceError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_SystemError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_SystemError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_SystemExit, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_SystemExit(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_TypeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_TypeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnboundLocalError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnboundLocalError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnicodeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnicodeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnicodeEncodeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnicodeEncodeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnicodeDecodeError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnicodeDecodeError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnicodeTranslateError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnicodeTranslateError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ValueError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ValueError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ZeroDivisionError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ZeroDivisionError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_WindowsError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_WindowsError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_BufferError, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_BufferError(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_MemoryErrorInst, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_MemoryErrorInst(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_Warning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_Warning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UserWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UserWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_DeprecationWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_DeprecationWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_PendingDeprecationWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_PendingDeprecationWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_SyntaxWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_SyntaxWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_RuntimeWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_RuntimeWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_FutureWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_FutureWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_ImportWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_ImportWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_UnicodeWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_UnicodeWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyExc_BytesWarning, maxon::GenericComponent,, (CPyConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyExc_BytesWarning(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyNullImporter_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyNullImporter_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySuper_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySuper_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyBool_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyBool_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyModule_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyModule_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyUnicode_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyUnicode_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyLong_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyLong_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyFloat_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyFloat_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTuple_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTuple_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyList_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyList_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyDict_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyDict_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyClass_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyClass_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyTraceBack_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyTraceBack_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPySlice_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPySlice_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyType_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyType_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyMemoryView_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyMemoryView_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_ConvertAndCacheString, maxon::GenericComponent,, (const PyChar*), const String& str, PyStringEncodings encoding, UInt* size) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->ConvertAndCacheString(str, std::forward<PyStringEncodings>(encoding), size); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_RegisterSpecificPythonClass, maxon::GenericComponent,, (Result<void>), const Id& typeId, const CPyTypeRef& type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->RegisterSpecificPythonClass(typeId, type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_PrivateRegisterBuiltinConverter, maxon::GenericComponent,, (Result<void>), const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->PrivateRegisterBuiltinConverter(dt, f1, f2); }
			static Result<void> CPythonLibraryInterface_GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) { return S::Implementation::GetUrl(pythonPath, pythonLibrary, pythonHome); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetSpecialPath, maxon::GenericComponent,, (Url), SPECIALPATH anonymous_param_1) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetSpecialPath(anonymous_param_1); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_RegisterSpecialPath, maxon::GenericComponent,, (void), SPECIALPATH anonymous_param_1, const Url& path) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->RegisterSpecialPath(anonymous_param_1, path); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyDataCapsule_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyDataCapsule_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyData_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyData_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyCapsule_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyCapsule_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyId_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyId_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyInternedId_Type, maxon::GenericComponent,, (CPyTypeConstRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyInternedId_Type(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_PrivateGetCurrentCallerContext, maxon::GenericComponent,, (CPyRef)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->PrivateGetCurrentCallerContext(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyDataType_ToMapperInstance, maxon::GenericComponent,, (CPyRef), const CPyRef& capsule) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyDataType_ToMapperInstance(capsule); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyData_ToMapperInstance, maxon::GenericComponent,, (CPyRef), const MPyDataRef& capsule) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyData_ToMapperInstance(capsule); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_ToMapperInstance, maxon::GenericComponent,, (CPyRef), const DataType& dt, const CPyRef& capsule) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_ToMapperInstance(dt, capsule); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, maxon::GenericComponent,, (Result<void>), const DataType& dt, const CPyRef& type) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->AssociateDataTypeWithPythonTypes(dt, type); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetAssociatedDataType, maxon::GenericComponent,, (Result<CPyRef>), const DataType& dt) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetAssociatedDataType(dt); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetConverterPyObject_FromData, maxon::GenericComponent,, (DelegatePyObject_FromData<>*), const DataType& dt) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetConverterPyObject_FromData(dt); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyData_New, maxon::GenericComponent,, (MPyDataRef), Data& data) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyData_New(data); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyData_New_1, maxon::GenericComponent,, (MPyDataRef), const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyData_New(dt, data, owner, mapDt); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyDataType_New, maxon::GenericComponent,, (MPyDataTypeRef), const DataType& dt) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MPyDataType_New(dt); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyDataType_CheckExact, maxon::GenericComponent, const, (Bool), const CPyRef& o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->MPyDataType_CheckExact(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyDataType_GetDataType, maxon::GenericComponent, const, (const DataType&), const MPyDataTypeRef& o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->MPyDataType_GetDataType(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MPyData_CheckExact, maxon::GenericComponent, const, (Bool), const CPyRef& o) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->MPyData_CheckExact(o); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_AsData, maxon::GenericComponent,, (Result<Data*>), Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_AsData(stackDepth, obj, expected, k, n); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetRegisteredTypesWithConversions, maxon::GenericComponent,, (Result<BaseArray<TYPE_CONVERSION_TUPLE>>)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetRegisteredTypesWithConversions(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_ParseDataType, maxon::GenericComponent,, (Result<DataType>), const CPyRef& args, Int32 argIndex, Bool canBeNone) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->ParseDataType(args, argIndex, canBeNone); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_SetError, maxon::GenericComponent,, (void), const Error& err) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->SetError(err); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_SetError_1, maxon::GenericComponent,, (void), const ErrorPtr& err) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->SetError(err); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_MaxonConvertAuto, maxon::GenericComponent,, (CPyRef), const CPyRef& capsule) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->MaxonConvertAuto(capsule); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CPyObject_FromGeneric, maxon::GenericComponent,, (CPyRef), const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->CPyObject_FromGeneric(origDt, object, ownership, expected, count); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_CreateGlobalDictionary, maxon::GenericComponent, const, (CPyRef)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->CreateGlobalDictionary(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCurrentTraceback, maxon::GenericComponent,, (Result<BaseArray<SourceLocation>>)) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetCurrentTraceback(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCPyRefClass, maxon::GenericComponent, const, (Class<CPyRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetCPyRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCPyTypeRefClass, maxon::GenericComponent, const, (Class<CPyTypeRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetCPyTypeRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCPyFrameRefClass, maxon::GenericComponent, const, (Class<CPyFrameRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetCPyFrameRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCPyTracebackRefClass, maxon::GenericComponent, const, (Class<CPyTracebackRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetCPyTracebackRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetCPyCodeRefClass, maxon::GenericComponent, const, (Class<CPyCodeRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetCPyCodeRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyClassRefClass, maxon::GenericComponent, const, (Class<MPyClassRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyClassRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyMemberRefClass, maxon::GenericComponent, const, (Class<MPyMemberRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyMemberRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyFunctionRefClass, maxon::GenericComponent, const, (Class<MPyFunctionRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyFunctionRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyHashMapRefClass, maxon::GenericComponent, const, (Class<MPyHashMapRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyHashMapRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyDataTypeRefClass, maxon::GenericComponent, const, (Class<MPyDataTypeRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyDataTypeRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyDataRefClass, maxon::GenericComponent, const, (Class<MPyDataRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyDataRefClass(); }
			PRIVATE_MAXON_MF_WRAPPER(CPythonLibraryInterface_GetMPyCallerContextRefClass, maxon::GenericComponent, const, (Class<MPyCallerContextRef>)) { return ((const typename S::Implementation*) PRIVATE_MAXON_MF_THIS(const maxon::GenericComponent))->GetMPyCallerContextRefClass(); }
		};

	};
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION>
	{
		return Hxx2::StaticMTable::_instance.CPythonLibraryInterface_ParseCommandLine(args, res, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_Init_Offset), mt_.CPythonLibraryInterface_Init, librarypath, createSubLibrary);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitTypes() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_InitTypes_Offset), mt_.CPythonLibraryInterface_InitTypes);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitBuiltinModules() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset), mt_.CPythonLibraryInterface_InitBuiltinModules);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Initialize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Initialize_Offset), mt_.CPythonLibraryInterface_CPy_Initialize);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Finalize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Finalize_Offset), mt_.CPythonLibraryInterface_CPy_Finalize);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Create(const ModuleDefinition& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Create_Offset), mt_.CPythonLibraryInterface_CPyModule_Create, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Free(const Delegate<void()>& shutdownEngine) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_Free_Offset), mt_.CPythonLibraryInterface_Free, shutdownEngine);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetDll() const -> const PythonDll&
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetDll_Offset), mt_.CPythonLibraryInterface_GetDll);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::FopenNative(const Char* name, const Char* mode) -> FILE_native*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_FopenNative_Offset), mt_.CPythonLibraryInterface_FopenNative, name, mode);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> Error
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset), mt_.CPythonLibraryInterface_LastPythonCallFailed, allocLocation, withTraceback, restoreError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) -> Result<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset), mt_.CPythonLibraryInterface_RegisterComponentProxy, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset), mt_.CPythonLibraryInterface_CPy_IsInitialized);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetVersion() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset), mt_.CPythonLibraryInterface_CPy_GetVersion);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPlatform() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset), mt_.CPythonLibraryInterface_CPy_GetPlatform);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCopyright() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset), mt_.CPythonLibraryInterface_CPy_GetCopyright);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCompiler() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset), mt_.CPythonLibraryInterface_CPy_GetCompiler);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetBuildInfo() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset), mt_.CPythonLibraryInterface_CPy_GetBuildInfo);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetProgramName(const String& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_SetProgramName, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_SetPythonHome, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetProgramName() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_GetProgramName);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPythonHome() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_GetPythonHome);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ExecuteModule(const String& name) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ExecuteModule_Offset), mt_.CPythonLibraryInterface_ExecuteModule, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallerContext_New() -> MPyCallerContextRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset), mt_.CPythonLibraryInterface_CPyCallerContext_New);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags, fp, filename, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, url, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags, code, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> NativePyObject*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_FileExFlags, fp, filename, start, globals, locals, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, fp, filename, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Ensure() -> PYGILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset), mt_.CPythonLibraryInterface_CPyGilState_Ensure);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Release(PYGILSTATE state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset), mt_.CPythonLibraryInterface_CPyGilState_Release, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetGilState() const -> GILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetGilState_Offset), mt_.CPythonLibraryInterface_GetGilState);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGILState_GetThisThreadState() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset), mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_Swap(NativePyThreadState* state) -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset), mt_.CPythonLibraryInterface_CPyThreadState_Swap, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_GetDict() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset), mt_.CPythonLibraryInterface_CPyThreadState_GetDict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> CPyCodeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset), mt_.CPythonLibraryInterface_CPy_CompileStringFlags, code, filename, start, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Incref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Incref_Offset), mt_.CPythonLibraryInterface_CPy_Incref, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Decref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Decref_Offset), mt_.CPythonLibraryInterface_CPy_Decref, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeIncref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SafeIncref_Offset), mt_.CPythonLibraryInterface_CPy_SafeIncref, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeDecref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SafeDecref_Offset), mt_.CPythonLibraryInterface_CPy_SafeDecref, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGC_Collect() -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset), mt_.CPythonLibraryInterface_CPyGC_Collect);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset), mt_.CPythonLibraryInterface_CPyCode_Addr2Line, codeObject, x);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackDataType(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_UnpackDataType_Offset), mt_.CPythonLibraryInterface_UnpackDataType, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackData(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_UnpackData_Offset), mt_.CPythonLibraryInterface_UnpackData, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_None() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_None_Offset), mt_.CPythonLibraryInterface_CPy_None);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_True() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_True_Offset), mt_.CPythonLibraryInterface_CPy_True);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_False() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_False_Offset), mt_.CPythonLibraryInterface_CPy_False);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NotImplemented() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NotImplemented_Offset), mt_.CPythonLibraryInterface_CPy_NotImplemented);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Print() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Print_Offset), mt_.CPythonLibraryInterface_CPyErr_Print);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Clear() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset), mt_.CPythonLibraryInterface_CPyErr_Clear);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Occurred(CPyRef* type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset), mt_.CPythonLibraryInterface_CPyErr_Occurred, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, errorType, errorNumber, filename);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrno, errorType, errorNumber);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString_1, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetNone(const CPyRef& errorType) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset), mt_.CPythonLibraryInterface_CPyErr_SetNone, errorType);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset), mt_.CPythonLibraryInterface_CPyErr_Fetch, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset), mt_.CPythonLibraryInterface_CPyErr_NormalizeException, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset), mt_.CPythonLibraryInterface_CPyErr_Restore, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_ExceptionMatches(const CPyRef& exc) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset), mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches, exc);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExceptionClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset), mt_.CPythonLibraryInterface_CPyExceptionClass_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_New_Offset), mt_.CPythonLibraryInterface_CPyCapsule_New, pointer, name, destructor);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetPointer, capsule, pointer);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetPointer, capsule, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetContext(const CPyRef& capsule) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetContext, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetContext, capsule, context);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_CheckExact(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyCapsule_CheckExact, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyClass_Check_Offset), mt_.CPythonLibraryInterface_CPyClass_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_New(UInt size) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_New_Offset), mt_.CPythonLibraryInterface_CPyTuple_New, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Size(const CPyRef& tuple) -> UInt
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset), mt_.CPythonLibraryInterface_CPyTuple_Size, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetItem, tuple, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_SetItem, tuple, index, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetSlice, tuple, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_CheckExact(const CPyRef& tuple) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyTuple_CheckExact, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_HasAttrString, o, attrName);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_SetAttrString, o, name, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetAttrString, o, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Call_Offset), mt_.CPythonLibraryInterface_CPyObject_Call, callable_object, tupleArg, kw);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Str(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Str_Offset), mt_.CPythonLibraryInterface_CPyObject_Str, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Repr(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset), mt_.CPythonLibraryInterface_CPyObject_Repr, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Dir(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset), mt_.CPythonLibraryInterface_CPyObject_Dir, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset), mt_.CPythonLibraryInterface_CPyObject_RichCompare, o1, o2, opid);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Hash(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset), mt_.CPythonLibraryInterface_CPyObject_Hash, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_IsTrue(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset), mt_.CPythonLibraryInterface_CPyObject_IsTrue, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Not(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Not_Offset), mt_.CPythonLibraryInterface_CPyObject_Not, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallable_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset), mt_.CPythonLibraryInterface_CPyCallable_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Length(const CPyRef& o) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Length_Offset), mt_.CPythonLibraryInterface_CPyObject_Length, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItem, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemInt(const CPyRef& o, Int index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemInt, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemString, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset), mt_.CPythonLibraryInterface_CPyObject_DelItem, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_SetItem, o, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset), mt_.CPythonLibraryInterface_CPyObject_TypeCheck, object, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_CallFunction(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset), mt_.CPythonLibraryInterface_CPyObject_CallFunction, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetObject(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset), mt_.CPythonLibraryInterface_CPySys_GetObject, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetObject(const Char* name, const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset), mt_.CPythonLibraryInterface_CPySys_SetObject, name, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetPath(const BaseArray<Url>& paths) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetPath_Offset), mt_.CPythonLibraryInterface_CPy_SetPath, paths);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset), mt_.CPythonLibraryInterface_CPySys_SetPath, paths, add);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset), mt_.CPythonLibraryInterface_CPySys_SetArgvEx, args, updatepath);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetPath() -> BaseArray<Url>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset), mt_.CPythonLibraryInterface_CPySys_GetPath);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset), mt_.CPythonLibraryInterface_CPySite_AddSiteDir, siteDir);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_FromString(const Char* str) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_FromString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_FromString, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_FromStringAndSize(const Block<const Char>& block) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset), mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize, block);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_AsString(const CPyRef& str) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsString, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_AsCString(const CPyRef& str) -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsCString, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_GetLength(const CPyRef& str) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset), mt_.CPythonLibraryInterface_CPyUnicode_GetLength, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetIter(const CPyRef& o) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetIter_Offset), mt_.CPythonLibraryInterface_CPyObject_GetIter, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyIter_Next(const CPyRef& it) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyIter_Next_Offset), mt_.CPythonLibraryInterface_CPyIter_Next, it);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_New() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_New_Offset), mt_.CPythonLibraryInterface_CPyDict_New);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItem, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItemString, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_SetItem, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItem, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> CONTAINS
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset), mt_.CPythonLibraryInterface_CPyDict_Contains, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Clear(const CPyRef& dict) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset), mt_.CPythonLibraryInterface_CPyDict_Clear, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Next_Offset), mt_.CPythonLibraryInterface_CPyDict_Next, dict, pos, key, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Keys(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset), mt_.CPythonLibraryInterface_CPyDict_Keys, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Values(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Values_Offset), mt_.CPythonLibraryInterface_CPyDict_Values, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Items(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Items_Offset), mt_.CPythonLibraryInterface_CPyDict_Items, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Size(const CPyRef& dict) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Size_Offset), mt_.CPythonLibraryInterface_CPyDict_Size, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Copy(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset), mt_.CPythonLibraryInterface_CPyDict_Copy, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_SetItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_SetItemString, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Check(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Check_Offset), mt_.CPythonLibraryInterface_CPyDict_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_New(UInt size) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_New_Offset), mt_.CPythonLibraryInterface_CPyList_New, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_CheckExact(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyList_CheckExact, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Clear(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Clear_Offset), mt_.CPythonLibraryInterface_CPyList_Clear, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Size(const CPyRef& list) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Size_Offset), mt_.CPythonLibraryInterface_CPyList_Size, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetItem(const CPyRef& list, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset), mt_.CPythonLibraryInterface_CPyList_GetItem, list, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset), mt_.CPythonLibraryInterface_CPyList_SetItem, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Insert_Offset), mt_.CPythonLibraryInterface_CPyList_Insert, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Append(const CPyRef& list, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Append_Offset), mt_.CPythonLibraryInterface_CPyList_Append, list, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_GetSlice, list, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_SetSlice, list, from, to, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Sort(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Sort_Offset), mt_.CPythonLibraryInterface_CPyList_Sort, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Reverse(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset), mt_.CPythonLibraryInterface_CPyList_Reverse, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_AsTuple(const CPyRef& list) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset), mt_.CPythonLibraryInterface_CPyList_AsTuple, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItemString, p, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Check_Offset), mt_.CPythonLibraryInterface_CPyModule_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> Result<Bool>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset), mt_.CPythonLibraryInterface_CPyModule_AddObject, module, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset), mt_.CPythonLibraryInterface_CPyModule_AddType, module, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_GetDict(const CPyRef& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset), mt_.CPythonLibraryInterface_CPyModule_GetDict, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset), mt_.CPythonLibraryInterface_CPyModule_AddIntConstant, mod, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_ImportModule(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset), mt_.CPythonLibraryInterface_CPyImport_ImportModule, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_GetImporter(const CPyRef& path) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset), mt_.CPythonLibraryInterface_CPyImport_GetImporter, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_GetModuleDict() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset), mt_.CPythonLibraryInterface_CPyImport_GetModuleDict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Check_Offset), mt_.CPythonLibraryInterface_CPyType_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset), mt_.CPythonLibraryInterface_CPyType_IsSubtype, a, b);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_HasFeature_Offset), mt_.CPythonLibraryInterface_CPyType_HasFeature, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_FastSubclass_Offset), mt_.CPythonLibraryInterface_CPyType_FastSubclass, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_GetName_Offset), mt_.CPythonLibraryInterface_CPyType_GetName, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Ready(CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Ready_Offset), mt_.CPythonLibraryInterface_CPyType_Ready, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_SaveThread() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset), mt_.CPythonLibraryInterface_CPyEval_SaveThread);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_RestoreThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset), mt_.CPythonLibraryInterface_CPyEval_RestoreThread, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ThreadsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset), mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_InitThreads() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset), mt_.CPythonLibraryInterface_CPyEval_InitThreads);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_AcquireThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset), mt_.CPythonLibraryInterface_CPyEval_AcquireThread, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ReleaseThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset), mt_.CPythonLibraryInterface_CPyEval_ReleaseThread, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_GetBuiltins() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_GetBuiltins_Offset), mt_.CPythonLibraryInterface_CPyEval_GetBuiltins);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_EvalCode_Offset), mt_.CPythonLibraryInterface_CPyEval_EvalCode, code, globals, locals);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset), mt_.CPythonLibraryInterface_CPyFloat_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat32(Float32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat32, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat64(Float64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat64, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_AsFloat64(const CPyRef& o) -> Float64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_AsFloat64, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_Check_Offset), mt_.CPythonLibraryInterface_CPyLong_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_FromBool(Bool value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset), mt_.CPythonLibraryInterface_CPyBool_FromBool, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt16(Int16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt16, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt16(UInt16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt16, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt32(Int32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt32, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt32(UInt32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt32, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt64(Int64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt64, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt64(UInt64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt64, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt16(const CPyRef& o) -> Int16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt16, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt16(const CPyRef& o) -> UInt16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt16, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt32(const CPyRef& o) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt32, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt32(const CPyRef& o) -> UInt32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt32, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt64(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt64, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt64(const CPyRef& o) -> UInt64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt64, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNumber_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset), mt_.CPythonLibraryInterface_CPyNumber_Check, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyFunction_New(const reflection::Function* func) -> MPyFunctionRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyFunction_New_Offset), mt_.CPythonLibraryInterface_MPyFunction_New, func);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyHashMap_New(const HashMap<Data, Data>& map) -> MPyHashMapRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New, map);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyHashMap_New(HashMap<Data, Data>&& map) -> MPyHashMapRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New_1, std::forward<HashMap<Data, Data>>(map));
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyMember_New(const reflection::Member* member) -> MPyMemberRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyMember_New_Offset), mt_.CPythonLibraryInterface_MPyMember_New, member);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset), mt_.CPythonLibraryInterface_CPyMem_SetAllocator, std::forward<CPyMemAllocatorDomain>(domain), allocator);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyClass_New(const reflection::Class* cls) -> MPyClassRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyClass_New_Offset), mt_.CPythonLibraryInterface_MPyClass_New, cls);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DebugFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset), mt_.CPythonLibraryInterface_CPy_DebugFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_VerboseFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset), mt_.CPythonLibraryInterface_CPy_VerboseFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InteractiveFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset), mt_.CPythonLibraryInterface_CPy_InteractiveFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InspectFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset), mt_.CPythonLibraryInterface_CPy_InspectFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_OptimizeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset), mt_.CPythonLibraryInterface_CPy_OptimizeFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoSiteFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset), mt_.CPythonLibraryInterface_CPy_NoSiteFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_BytesWarningFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset), mt_.CPythonLibraryInterface_CPy_BytesWarningFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_FrozenFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset), mt_.CPythonLibraryInterface_CPy_FrozenFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IgnoreEnvironmentFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset), mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DontWriteBytecodeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset), mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoUserSiteDirectory() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset), mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BaseException() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset), mt_.CPythonLibraryInterface_CPyExc_BaseException);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Exception() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset), mt_.CPythonLibraryInterface_CPyExc_Exception);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StopIteration() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset), mt_.CPythonLibraryInterface_CPyExc_StopIteration);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_GeneratorExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset), mt_.CPythonLibraryInterface_CPyExc_GeneratorExit);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StandardError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset), mt_.CPythonLibraryInterface_CPyExc_StandardError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ArithmeticError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset), mt_.CPythonLibraryInterface_CPyExc_ArithmeticError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_LookupError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset), mt_.CPythonLibraryInterface_CPyExc_LookupError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AssertionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset), mt_.CPythonLibraryInterface_CPyExc_AssertionError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AttributeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset), mt_.CPythonLibraryInterface_CPyExc_AttributeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EOFError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset), mt_.CPythonLibraryInterface_CPyExc_EOFError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FloatingPointError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset), mt_.CPythonLibraryInterface_CPyExc_FloatingPointError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EnvironmentError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset), mt_.CPythonLibraryInterface_CPyExc_EnvironmentError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IOError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset), mt_.CPythonLibraryInterface_CPyExc_IOError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OSError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset), mt_.CPythonLibraryInterface_CPyExc_OSError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndexError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndexError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyboardInterrupt() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NameError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset), mt_.CPythonLibraryInterface_CPyExc_NameError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OverflowError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset), mt_.CPythonLibraryInterface_CPyExc_OverflowError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NotImplementedError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset), mt_.CPythonLibraryInterface_CPyExc_NotImplementedError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndentationError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndentationError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TabError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset), mt_.CPythonLibraryInterface_CPyExc_TabError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ReferenceError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset), mt_.CPythonLibraryInterface_CPyExc_ReferenceError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemExit);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TypeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset), mt_.CPythonLibraryInterface_CPyExc_TypeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnboundLocalError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeEncodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeDecodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeTranslateError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ValueError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset), mt_.CPythonLibraryInterface_CPyExc_ValueError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ZeroDivisionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset), mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_WindowsError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset), mt_.CPythonLibraryInterface_CPyExc_WindowsError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BufferError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset), mt_.CPythonLibraryInterface_CPyExc_BufferError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryErrorInst() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Warning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset), mt_.CPythonLibraryInterface_CPyExc_Warning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UserWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UserWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_DeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_PendingDeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FutureWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_FutureWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BytesWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_BytesWarning);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNullImporter_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset), mt_.CPythonLibraryInterface_CPyNullImporter_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySuper_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySuper_Type_Offset), mt_.CPythonLibraryInterface_CPySuper_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyBool_Type_Offset), mt_.CPythonLibraryInterface_CPyBool_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Type_Offset), mt_.CPythonLibraryInterface_CPyObject_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Type_Offset), mt_.CPythonLibraryInterface_CPyModule_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_Type_Offset), mt_.CPythonLibraryInterface_CPyLong_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset), mt_.CPythonLibraryInterface_CPyFloat_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset), mt_.CPythonLibraryInterface_CPyTuple_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Type_Offset), mt_.CPythonLibraryInterface_CPyList_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Type_Offset), mt_.CPythonLibraryInterface_CPyDict_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyClass_Type_Offset), mt_.CPythonLibraryInterface_CPyClass_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySlice_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySlice_Type_Offset), mt_.CPythonLibraryInterface_CPySlice_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Type_Offset), mt_.CPythonLibraryInterface_CPyType_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyMemoryView_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset), mt_.CPythonLibraryInterface_CPyMemoryView_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) -> const PyChar*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset), mt_.CPythonLibraryInterface_ConvertAndCacheString, str, std::forward<PyStringEncodings>(encoding), size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset), mt_.CPythonLibraryInterface_RegisterSpecificPythonClass, typeId, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset), mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter, dt, f1, f2);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void>
	{
		return Hxx2::StaticMTable::_instance.CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetSpecialPath(SPECIALPATH anonymous_param_1) -> Url
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetSpecialPath_Offset), mt_.CPythonLibraryInterface_GetSpecialPath, anonymous_param_1);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset), mt_.CPythonLibraryInterface_RegisterSpecialPath, anonymous_param_1, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset), mt_.CPythonLibraryInterface_MPyDataCapsule_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyData_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyData_Type_Offset), mt_.CPythonLibraryInterface_CPyData_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset), mt_.CPythonLibraryInterface_CPyCapsule_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyId_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyId_Type_Offset), mt_.CPythonLibraryInterface_CPyId_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInternedId_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyInternedId_Type_Offset), mt_.CPythonLibraryInterface_CPyInternedId_Type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateGetCurrentCallerContext() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset), mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyData_ToMapperInstance, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance, dt, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset), mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, dt, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetAssociatedDataType(const DataType& dt) -> Result<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset), mt_.CPythonLibraryInterface_GetAssociatedDataType, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetConverterPyObject_FromData(const DataType& dt) -> DelegatePyObject_FromData<>*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset), mt_.CPythonLibraryInterface_GetConverterPyObject_FromData, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(Data& data) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_New_Offset), mt_.CPythonLibraryInterface_MPyData_New, data);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_New_1_Offset), mt_.CPythonLibraryInterface_MPyData_New_1, dt, data, owner, mapDt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_New(const DataType& dt) -> MPyDataTypeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_New_Offset), mt_.CPythonLibraryInterface_MPyDataType_New, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_CheckExact_Offset), mt_.CPythonLibraryInterface_MPyDataType_CheckExact, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> const DataType&
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_GetDataType_Offset), mt_.CPythonLibraryInterface_MPyDataType_GetDataType, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_CheckExact_Offset), mt_.CPythonLibraryInterface_MPyData_CheckExact, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset), mt_.CPythonLibraryInterface_CPyObject_AsData, stackDepth, obj, expected, k, n);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset), mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<DataType>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ParseDataType_Offset), mt_.CPythonLibraryInterface_ParseDataType, args, argIndex, canBeNone);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const Error& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_SetError_Offset), mt_.CPythonLibraryInterface_SetError, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const ErrorPtr& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_SetError_1_Offset), mt_.CPythonLibraryInterface_SetError_1, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MaxonConvertAuto(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset), mt_.CPythonLibraryInterface_MaxonConvertAuto, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset), mt_.CPythonLibraryInterface_CPyObject_FromGeneric, origDt, object, ownership, expected, count);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CreateGlobalDictionary() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CreateGlobalDictionary_Offset), mt_.CPythonLibraryInterface_CreateGlobalDictionary);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset), mt_.CPythonLibraryInterface_GetCurrentTraceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyRefClass() const -> Class<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTypeRefClass() const -> Class<CPyTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyTypeRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyTypeRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyFrameRefClass() const -> Class<CPyFrameRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyFrameRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyFrameRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTracebackRefClass() const -> Class<CPyTracebackRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyTracebackRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyTracebackRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyCodeRefClass() const -> Class<CPyCodeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyCodeRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyCodeRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyClassRefClass() const -> Class<MPyClassRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyClassRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyClassRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyMemberRefClass() const -> Class<MPyMemberRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyMemberRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyMemberRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyFunctionRefClass() const -> Class<MPyFunctionRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyFunctionRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyFunctionRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyHashMapRefClass() const -> Class<MPyHashMapRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyHashMapRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyHashMapRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataTypeRefClass() const -> Class<MPyDataTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataRefClass() const -> Class<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyDataRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyDataRefClass);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyCallerContextRefClass() const -> Class<MPyCallerContextRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return PRIVATE_MAXON_MF_INVOKE(((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION>
	{
		return (Hxx2::StaticMTable::_instance.CPythonLibraryInterface_ParseCommandLine(args, res, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Init(const Url& librarypath, Bool createSubLibrary) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Init_Offset), mt_.CPythonLibraryInterface_Init, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Init_Offset), mt_.CPythonLibraryInterface_Init, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::InitTypes() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitTypes_Offset), mt_.CPythonLibraryInterface_InitTypes));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::InitTypes() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitTypes_Offset), mt_.CPythonLibraryInterface_InitTypes));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::InitBuiltinModules() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset), mt_.CPythonLibraryInterface_InitBuiltinModules));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::InitBuiltinModules() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset), mt_.CPythonLibraryInterface_InitBuiltinModules));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_Initialize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Initialize_Offset), mt_.CPythonLibraryInterface_CPy_Initialize);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_Initialize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Initialize_Offset), mt_.CPythonLibraryInterface_CPy_Initialize);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_Finalize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Finalize_Offset), mt_.CPythonLibraryInterface_CPy_Finalize);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_Finalize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Finalize_Offset), mt_.CPythonLibraryInterface_CPy_Finalize);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Create(const ModuleDefinition& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Create) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Create_Offset), mt_.CPythonLibraryInterface_CPyModule_Create, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Create(const ModuleDefinition& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Create) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Create_Offset), mt_.CPythonLibraryInterface_CPyModule_Create, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Free(const Delegate<void()>& shutdownEngine) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Free_Offset), mt_.CPythonLibraryInterface_Free, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Free(const Delegate<void()>& shutdownEngine) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Free_Offset), mt_.CPythonLibraryInterface_Free, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetDll() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const PythonDll&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetDll) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetDll_Offset), mt_.CPythonLibraryInterface_GetDll));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::FopenNative(const Char* name, const Char* mode) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_FopenNative_Offset), mt_.CPythonLibraryInterface_FopenNative, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::FopenNative(const Char* name, const Char* mode) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_FopenNative_Offset), mt_.CPythonLibraryInterface_FopenNative, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<Error>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset), mt_.CPythonLibraryInterface_LastPythonCallFailed, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset), mt_.CPythonLibraryInterface_LastPythonCallFailed, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) const -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<MPyDataRef>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset), mt_.CPythonLibraryInterface_RegisterComponentProxy, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<MPyDataRef>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset), mt_.CPythonLibraryInterface_RegisterComponentProxy, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_IsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset), mt_.CPythonLibraryInterface_CPy_IsInitialized));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_IsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset), mt_.CPythonLibraryInterface_CPy_IsInitialized));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetVersion() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset), mt_.CPythonLibraryInterface_CPy_GetVersion));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetVersion() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset), mt_.CPythonLibraryInterface_CPy_GetVersion));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetPlatform() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset), mt_.CPythonLibraryInterface_CPy_GetPlatform));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetPlatform() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset), mt_.CPythonLibraryInterface_CPy_GetPlatform));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetCopyright() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset), mt_.CPythonLibraryInterface_CPy_GetCopyright));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetCopyright() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset), mt_.CPythonLibraryInterface_CPy_GetCopyright));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetCompiler() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset), mt_.CPythonLibraryInterface_CPy_GetCompiler));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetCompiler() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset), mt_.CPythonLibraryInterface_CPy_GetCompiler));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetBuildInfo() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset), mt_.CPythonLibraryInterface_CPy_GetBuildInfo));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetBuildInfo() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset), mt_.CPythonLibraryInterface_CPy_GetBuildInfo));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetProgramName(const String& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_SetProgramName, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetProgramName(const String& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_SetProgramName, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetPythonHome(const Url& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_SetPythonHome, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_SetPythonHome, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetProgramName() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_GetProgramName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetProgramName() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset), mt_.CPythonLibraryInterface_CPy_GetProgramName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetPythonHome() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_GetPythonHome));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetPythonHome() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset), mt_.CPythonLibraryInterface_CPy_GetPythonHome));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ExecuteModule(const String& name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ExecuteModule_Offset), mt_.CPythonLibraryInterface_ExecuteModule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ExecuteModule(const String& name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ExecuteModule_Offset), mt_.CPythonLibraryInterface_ExecuteModule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCallerContext_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyCallerContextRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset), mt_.CPythonLibraryInterface_CPyCallerContext_New));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCallerContext_New() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset), mt_.CPythonLibraryInterface_CPyCallerContext_New));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_FileExFlags, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_FileExFlags, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset), mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGilState_Ensure() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<PYGILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset), mt_.CPythonLibraryInterface_CPyGilState_Ensure));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGilState_Ensure() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset), mt_.CPythonLibraryInterface_CPyGilState_Ensure));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGilState_Release(PYGILSTATE state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset), mt_.CPythonLibraryInterface_CPyGilState_Release, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGilState_Release(PYGILSTATE state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset), mt_.CPythonLibraryInterface_CPyGilState_Release, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetGilState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<GILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetGilState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetGilState_Offset), mt_.CPythonLibraryInterface_GetGilState));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGILState_GetThisThreadState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset), mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGILState_GetThisThreadState() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset), mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyThreadState_Swap(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset), mt_.CPythonLibraryInterface_CPyThreadState_Swap, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyThreadState_Swap(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset), mt_.CPythonLibraryInterface_CPyThreadState_Swap, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyThreadState_GetDict() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset), mt_.CPythonLibraryInterface_CPyThreadState_GetDict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyThreadState_GetDict() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset), mt_.CPythonLibraryInterface_CPyThreadState_GetDict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyCodeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset), mt_.CPythonLibraryInterface_CPy_CompileStringFlags, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset), mt_.CPythonLibraryInterface_CPy_CompileStringFlags, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_Incref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Incref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Incref_Offset), mt_.CPythonLibraryInterface_CPy_Incref, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_Decref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Decref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Decref_Offset), mt_.CPythonLibraryInterface_CPy_Decref, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeIncref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeIncref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SafeIncref_Offset), mt_.CPythonLibraryInterface_CPy_SafeIncref, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeDecref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeDecref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SafeDecref_Offset), mt_.CPythonLibraryInterface_CPy_SafeDecref, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeClear(T*& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPy_SafeClear on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } 
		o_->CPy_SafeClear<T>(o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGC_Collect() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset), mt_.CPythonLibraryInterface_CPyGC_Collect));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGC_Collect() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset), mt_.CPythonLibraryInterface_CPyGC_Collect));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset), mt_.CPythonLibraryInterface_CPyCode_Addr2Line, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset), mt_.CPythonLibraryInterface_CPyCode_Addr2Line, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::UnpackDataType(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackDataType_Offset), mt_.CPythonLibraryInterface_UnpackDataType, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::UnpackDataType(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackDataType_Offset), mt_.CPythonLibraryInterface_UnpackDataType, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::UnpackData(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackData_Offset), mt_.CPythonLibraryInterface_UnpackData, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::UnpackData(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackData_Offset), mt_.CPythonLibraryInterface_UnpackData, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_None() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_None) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_None_Offset), mt_.CPythonLibraryInterface_CPy_None));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_True() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_True) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_True_Offset), mt_.CPythonLibraryInterface_CPy_True));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_False() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_False) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_False_Offset), mt_.CPythonLibraryInterface_CPy_False));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_NotImplemented() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NotImplemented) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NotImplemented_Offset), mt_.CPythonLibraryInterface_CPy_NotImplemented));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Print() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Print_Offset), mt_.CPythonLibraryInterface_CPyErr_Print);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Print() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Print_Offset), mt_.CPythonLibraryInterface_CPyErr_Print);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Clear() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset), mt_.CPythonLibraryInterface_CPyErr_Clear);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Clear() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset), mt_.CPythonLibraryInterface_CPyErr_Clear);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Occurred(CPyRef* type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset), mt_.CPythonLibraryInterface_CPyErr_Occurred, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Occurred(CPyRef* type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset), mt_.CPythonLibraryInterface_CPyErr_Occurred, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrno, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset), mt_.CPythonLibraryInterface_CPyErr_SetWithErrno, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString_1, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset), mt_.CPythonLibraryInterface_CPyErr_SetString_1, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetNone(const CPyRef& errorType) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset), mt_.CPythonLibraryInterface_CPyErr_SetNone, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetNone(const CPyRef& errorType) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset), mt_.CPythonLibraryInterface_CPyErr_SetNone, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset), mt_.CPythonLibraryInterface_CPyErr_Fetch, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset), mt_.CPythonLibraryInterface_CPyErr_Fetch, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset), mt_.CPythonLibraryInterface_CPyErr_NormalizeException, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset), mt_.CPythonLibraryInterface_CPyErr_NormalizeException, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset), mt_.CPythonLibraryInterface_CPyErr_Restore, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset), mt_.CPythonLibraryInterface_CPyErr_Restore, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_ExceptionMatches(const CPyRef& exc) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset), mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_ExceptionMatches(const CPyRef& exc) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset), mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExceptionClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset), mt_.CPythonLibraryInterface_CPyExceptionClass_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExceptionClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset), mt_.CPythonLibraryInterface_CPyExceptionClass_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_New_Offset), mt_.CPythonLibraryInterface_CPyCapsule_New, pointer, name, destructor));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetPointer, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetPointer, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetPointer, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetPointer, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_GetContext(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetContext, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_GetContext(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_GetContext, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetContext, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset), mt_.CPythonLibraryInterface_CPyCapsule_SetContext, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyCapsule_CheckExact, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_CheckExact(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyCapsule_CheckExact, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTraceBack_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTraceBack_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Check_Offset), mt_.CPythonLibraryInterface_CPyClass_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Check_Offset), mt_.CPythonLibraryInterface_CPyClass_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyTuple_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_New_Offset), mt_.CPythonLibraryInterface_CPyTuple_New, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_Size(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset), mt_.CPythonLibraryInterface_CPyTuple_Size, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_Size(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset), mt_.CPythonLibraryInterface_CPyTuple_Size, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetItem, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetItem, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_SetItem, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset), mt_.CPythonLibraryInterface_CPyTuple_SetItem, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetSlice, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyTuple_GetSlice, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_CheckExact(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyTuple_CheckExact, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_CheckExact(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyTuple_CheckExact, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_HasAttrString, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_HasAttrString, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_SetAttrString, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_SetAttrString, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetAttrString, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetAttrString, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Call_Offset), mt_.CPythonLibraryInterface_CPyObject_Call, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Call_Offset), mt_.CPythonLibraryInterface_CPyObject_Call, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Str(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Str_Offset), mt_.CPythonLibraryInterface_CPyObject_Str, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Str(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Str_Offset), mt_.CPythonLibraryInterface_CPyObject_Str, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Repr(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset), mt_.CPythonLibraryInterface_CPyObject_Repr, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Repr(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset), mt_.CPythonLibraryInterface_CPyObject_Repr, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Dir(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset), mt_.CPythonLibraryInterface_CPyObject_Dir, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Dir(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset), mt_.CPythonLibraryInterface_CPyObject_Dir, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset), mt_.CPythonLibraryInterface_CPyObject_RichCompare, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset), mt_.CPythonLibraryInterface_CPyObject_RichCompare, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Hash(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset), mt_.CPythonLibraryInterface_CPyObject_Hash, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Hash(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset), mt_.CPythonLibraryInterface_CPyObject_Hash, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_IsTrue(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset), mt_.CPythonLibraryInterface_CPyObject_IsTrue, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_IsTrue(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset), mt_.CPythonLibraryInterface_CPyObject_IsTrue, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Not(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Not_Offset), mt_.CPythonLibraryInterface_CPyObject_Not, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Not(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Not_Offset), mt_.CPythonLibraryInterface_CPyObject_Not, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCallable_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset), mt_.CPythonLibraryInterface_CPyCallable_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCallable_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset), mt_.CPythonLibraryInterface_CPyCallable_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Length(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Length_Offset), mt_.CPythonLibraryInterface_CPyObject_Length, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Length(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Length_Offset), mt_.CPythonLibraryInterface_CPyObject_Length, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItem, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItem, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemInt, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemInt, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemString, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyObject_GetItemString, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset), mt_.CPythonLibraryInterface_CPyObject_DelItem, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset), mt_.CPythonLibraryInterface_CPyObject_DelItem, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_SetItem, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset), mt_.CPythonLibraryInterface_CPyObject_SetItem, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset), mt_.CPythonLibraryInterface_CPyObject_TypeCheck, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset), mt_.CPythonLibraryInterface_CPyObject_TypeCheck, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_CallFunction(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset), mt_.CPythonLibraryInterface_CPyObject_CallFunction, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_CallFunction(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset), mt_.CPythonLibraryInterface_CPyObject_CallFunction, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_GetObject(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset), mt_.CPythonLibraryInterface_CPySys_GetObject, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_GetObject(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset), mt_.CPythonLibraryInterface_CPySys_GetObject, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetObject(const Char* name, const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset), mt_.CPythonLibraryInterface_CPySys_SetObject, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetObject(const Char* name, const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset), mt_.CPythonLibraryInterface_CPySys_SetObject, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetPath(const BaseArray<Url>& paths) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPath_Offset), mt_.CPythonLibraryInterface_CPy_SetPath, paths));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetPath(const BaseArray<Url>& paths) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPath_Offset), mt_.CPythonLibraryInterface_CPy_SetPath, paths));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset), mt_.CPythonLibraryInterface_CPySys_SetPath, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset), mt_.CPythonLibraryInterface_CPySys_SetPath, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset), mt_.CPythonLibraryInterface_CPySys_SetArgvEx, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset), mt_.CPythonLibraryInterface_CPySys_SetArgvEx, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_GetPath() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<BaseArray<Url>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset), mt_.CPythonLibraryInterface_CPySys_GetPath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_GetPath() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset), mt_.CPythonLibraryInterface_CPySys_GetPath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySite_AddSiteDir(const Url& siteDir) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset), mt_.CPythonLibraryInterface_CPySite_AddSiteDir, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset), mt_.CPythonLibraryInterface_CPySite_AddSiteDir, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyUnicode_FromString(const Char* str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_FromString, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_FromStringAndSize(const Block<const Char>& block) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset), mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_FromStringAndSize(const Block<const Char>& block) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset), mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_AsString(const CPyRef& str) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsString, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_AsString(const CPyRef& str) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsString, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_AsCString(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsCString, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_AsCString(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset), mt_.CPythonLibraryInterface_CPyUnicode_AsCString, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_GetLength(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_GetLength) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset), mt_.CPythonLibraryInterface_CPyUnicode_GetLength, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_GetLength(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_GetLength) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset), mt_.CPythonLibraryInterface_CPyUnicode_GetLength, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyObject_GetIter(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetIter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetIter_Offset), mt_.CPythonLibraryInterface_CPyObject_GetIter, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyIter_Next(const CPyRef& it) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyIter_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyIter_Next_Offset), mt_.CPythonLibraryInterface_CPyIter_Next, it));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_New_Offset), mt_.CPythonLibraryInterface_CPyDict_New));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItem, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItem, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItemString, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_GetItemString, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_SetItem, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset), mt_.CPythonLibraryInterface_CPyDict_SetItem, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItem, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItem, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CONTAINS>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset), mt_.CPythonLibraryInterface_CPyDict_Contains, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset), mt_.CPythonLibraryInterface_CPyDict_Contains, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Clear(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset), mt_.CPythonLibraryInterface_CPyDict_Clear, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Clear(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset), mt_.CPythonLibraryInterface_CPyDict_Clear, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Next_Offset), mt_.CPythonLibraryInterface_CPyDict_Next, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Next_Offset), mt_.CPythonLibraryInterface_CPyDict_Next, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Keys(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset), mt_.CPythonLibraryInterface_CPyDict_Keys, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Keys(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset), mt_.CPythonLibraryInterface_CPyDict_Keys, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Values(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Values_Offset), mt_.CPythonLibraryInterface_CPyDict_Values, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Values(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Values_Offset), mt_.CPythonLibraryInterface_CPyDict_Values, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Items(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Items_Offset), mt_.CPythonLibraryInterface_CPyDict_Items, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Items(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Items_Offset), mt_.CPythonLibraryInterface_CPyDict_Items, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Size(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Size_Offset), mt_.CPythonLibraryInterface_CPyDict_Size, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Size(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Size_Offset), mt_.CPythonLibraryInterface_CPyDict_Size, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Copy(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset), mt_.CPythonLibraryInterface_CPyDict_Copy, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Copy(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset), mt_.CPythonLibraryInterface_CPyDict_Copy, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_SetItemString, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Check_Offset), mt_.CPythonLibraryInterface_CPyDict_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_New_Offset), mt_.CPythonLibraryInterface_CPyList_New, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_New(UInt size) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_New_Offset), mt_.CPythonLibraryInterface_CPyList_New, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_CheckExact(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyList_CheckExact, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_CheckExact(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset), mt_.CPythonLibraryInterface_CPyList_CheckExact, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Clear(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Clear_Offset), mt_.CPythonLibraryInterface_CPyList_Clear, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Clear(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Clear_Offset), mt_.CPythonLibraryInterface_CPyList_Clear, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Size(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Size_Offset), mt_.CPythonLibraryInterface_CPyList_Size, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Size(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Size_Offset), mt_.CPythonLibraryInterface_CPyList_Size, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_GetItem(const CPyRef& list, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset), mt_.CPythonLibraryInterface_CPyList_GetItem, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_GetItem(const CPyRef& list, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset), mt_.CPythonLibraryInterface_CPyList_GetItem, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset), mt_.CPythonLibraryInterface_CPyList_SetItem, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset), mt_.CPythonLibraryInterface_CPyList_SetItem, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Insert_Offset), mt_.CPythonLibraryInterface_CPyList_Insert, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Insert_Offset), mt_.CPythonLibraryInterface_CPyList_Insert, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Append_Offset), mt_.CPythonLibraryInterface_CPyList_Append, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Append_Offset), mt_.CPythonLibraryInterface_CPyList_Append, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_GetSlice, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_GetSlice, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_SetSlice, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset), mt_.CPythonLibraryInterface_CPyList_SetSlice, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Sort(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Sort_Offset), mt_.CPythonLibraryInterface_CPyList_Sort, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Sort(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Sort_Offset), mt_.CPythonLibraryInterface_CPyList_Sort, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Reverse(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset), mt_.CPythonLibraryInterface_CPyList_Reverse, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Reverse(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset), mt_.CPythonLibraryInterface_CPyList_Reverse, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_AsTuple(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset), mt_.CPythonLibraryInterface_CPyList_AsTuple, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_AsTuple(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset), mt_.CPythonLibraryInterface_CPyList_AsTuple, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItemString, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset), mt_.CPythonLibraryInterface_CPyDict_DelItemString, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Check_Offset), mt_.CPythonLibraryInterface_CPyModule_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Check_Offset), mt_.CPythonLibraryInterface_CPyModule_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) const -> Result<Bool>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Bool>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset), mt_.CPythonLibraryInterface_CPyModule_AddObject, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> Result<Bool>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Bool>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset), mt_.CPythonLibraryInterface_CPyModule_AddObject, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset), mt_.CPythonLibraryInterface_CPyModule_AddType, module, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset), mt_.CPythonLibraryInterface_CPyModule_AddType, module, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_GetDict(const CPyRef& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset), mt_.CPythonLibraryInterface_CPyModule_GetDict, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_GetDict(const CPyRef& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset), mt_.CPythonLibraryInterface_CPyModule_GetDict, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset), mt_.CPythonLibraryInterface_CPyModule_AddIntConstant, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset), mt_.CPythonLibraryInterface_CPyModule_AddIntConstant, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_ImportModule(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset), mt_.CPythonLibraryInterface_CPyImport_ImportModule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_ImportModule(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset), mt_.CPythonLibraryInterface_CPyImport_ImportModule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_GetImporter(const CPyRef& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset), mt_.CPythonLibraryInterface_CPyImport_GetImporter, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_GetImporter(const CPyRef& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset), mt_.CPythonLibraryInterface_CPyImport_GetImporter, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_GetModuleDict() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetModuleDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset), mt_.CPythonLibraryInterface_CPyImport_GetModuleDict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_GetModuleDict() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetModuleDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset), mt_.CPythonLibraryInterface_CPyImport_GetModuleDict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Check_Offset), mt_.CPythonLibraryInterface_CPyType_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Check_Offset), mt_.CPythonLibraryInterface_CPyType_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset), mt_.CPythonLibraryInterface_CPyType_IsSubtype, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset), mt_.CPythonLibraryInterface_CPyType_IsSubtype, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_HasFeature) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_HasFeature_Offset), mt_.CPythonLibraryInterface_CPyType_HasFeature, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_FastSubclass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_FastSubclass_Offset), mt_.CPythonLibraryInterface_CPyType_FastSubclass, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_GetName(const CPyTypeRef& type) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_GetName_Offset), mt_.CPythonLibraryInterface_CPyType_GetName, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_GetName_Offset), mt_.CPythonLibraryInterface_CPyType_GetName, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Ready(CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Ready_Offset), mt_.CPythonLibraryInterface_CPyType_Ready, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Ready(CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Ready_Offset), mt_.CPythonLibraryInterface_CPyType_Ready, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_SaveThread() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset), mt_.CPythonLibraryInterface_CPyEval_SaveThread));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_SaveThread() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset), mt_.CPythonLibraryInterface_CPyEval_SaveThread));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_RestoreThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset), mt_.CPythonLibraryInterface_CPyEval_RestoreThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_RestoreThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset), mt_.CPythonLibraryInterface_CPyEval_RestoreThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_ThreadsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset), mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_ThreadsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset), mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_InitThreads() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset), mt_.CPythonLibraryInterface_CPyEval_InitThreads);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_InitThreads() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset), mt_.CPythonLibraryInterface_CPyEval_InitThreads);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_AcquireThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset), mt_.CPythonLibraryInterface_CPyEval_AcquireThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_AcquireThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset), mt_.CPythonLibraryInterface_CPyEval_AcquireThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_ReleaseThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset), mt_.CPythonLibraryInterface_CPyEval_ReleaseThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_ReleaseThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset), mt_.CPythonLibraryInterface_CPyEval_ReleaseThread, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyEval_GetBuiltins() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_GetBuiltins) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_GetBuiltins_Offset), mt_.CPythonLibraryInterface_CPyEval_GetBuiltins));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_EvalCode) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_EvalCode_Offset), mt_.CPythonLibraryInterface_CPyEval_EvalCode, code, globals, locals));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset), mt_.CPythonLibraryInterface_CPyFloat_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset), mt_.CPythonLibraryInterface_CPyFloat_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_FromFloat32(Float32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_FromFloat32(Float32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_FromFloat64(Float64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_FromFloat64(Float64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_FromFloat64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_AsFloat64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_AsFloat64, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_AsFloat64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset), mt_.CPythonLibraryInterface_CPyFloat_AsFloat64, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_As on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Check_Offset), mt_.CPythonLibraryInterface_CPyLong_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Check_Offset), mt_.CPythonLibraryInterface_CPyLong_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyBool_FromBool(Bool value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset), mt_.CPythonLibraryInterface_CPyBool_FromBool, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyBool_FromBool(Bool value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset), mt_.CPythonLibraryInterface_CPyBool_FromBool, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt16(Int16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt16, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt16(Int16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt16, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt16(UInt16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt16, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt16(UInt16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt16, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt32(Int32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt32(Int32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt32(UInt32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt32(UInt32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt32, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt64(Int64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt64(Int64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromInt64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt64(UInt64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt64(UInt64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_FromUInt64, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt16, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt16, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt16, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt16, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt32, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt32, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt32, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt32, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt64, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsInt64, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt64, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset), mt_.CPythonLibraryInterface_CPyLong_AsUInt64, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_As on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_From on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_From on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyNumber_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset), mt_.CPythonLibraryInterface_CPyNumber_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyNumber_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset), mt_.CPythonLibraryInterface_CPyNumber_Check, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyFunction_New(const reflection::Function* func) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyFunctionRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyFunction_New_Offset), mt_.CPythonLibraryInterface_MPyFunction_New, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyFunction_New(const reflection::Function* func) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyFunction_New_Offset), mt_.CPythonLibraryInterface_MPyFunction_New, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(const HashMap<Data, Data>& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New, map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(const HashMap<Data, Data>& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New, map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(HashMap<Data, Data>&& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New_1, std::forward<HashMap<Data, Data>>(map)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(HashMap<Data, Data>&& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset), mt_.CPythonLibraryInterface_MPyHashMap_New_1, std::forward<HashMap<Data, Data>>(map)));
	}
	template <typename S> template <typename KEY, typename VALUE> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(HashMap<KEY, VALUE>& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->MPyHashMap_New<KEY, VALUE>(map));
	}
	template <typename S> template <typename KEY, typename VALUE> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(HashMap<KEY, VALUE>& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::MPyHashMap_New on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->MPyHashMap_New<KEY, VALUE>(map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyMember_New(const reflection::Member* member) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyMemberRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyMember_New_Offset), mt_.CPythonLibraryInterface_MPyMember_New, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyMember_New(const reflection::Member* member) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyMember_New_Offset), mt_.CPythonLibraryInterface_MPyMember_New, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMem_SetAllocator) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset), mt_.CPythonLibraryInterface_CPyMem_SetAllocator, std::forward<CPyMemAllocatorDomain>(domain), allocator));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMem_SetAllocator) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset), mt_.CPythonLibraryInterface_CPyMem_SetAllocator, std::forward<CPyMemAllocatorDomain>(domain), allocator));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyClass_New(const reflection::Class* cls) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyClassRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyClass_New_Offset), mt_.CPythonLibraryInterface_MPyClass_New, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyClass_New(const reflection::Class* cls) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyClass_New_Offset), mt_.CPythonLibraryInterface_MPyClass_New, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_DebugFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset), mt_.CPythonLibraryInterface_CPy_DebugFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_DebugFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset), mt_.CPythonLibraryInterface_CPy_DebugFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_VerboseFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset), mt_.CPythonLibraryInterface_CPy_VerboseFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_VerboseFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset), mt_.CPythonLibraryInterface_CPy_VerboseFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_InteractiveFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset), mt_.CPythonLibraryInterface_CPy_InteractiveFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_InteractiveFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset), mt_.CPythonLibraryInterface_CPy_InteractiveFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_InspectFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset), mt_.CPythonLibraryInterface_CPy_InspectFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_InspectFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset), mt_.CPythonLibraryInterface_CPy_InspectFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_OptimizeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset), mt_.CPythonLibraryInterface_CPy_OptimizeFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_OptimizeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset), mt_.CPythonLibraryInterface_CPy_OptimizeFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_NoSiteFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset), mt_.CPythonLibraryInterface_CPy_NoSiteFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_NoSiteFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset), mt_.CPythonLibraryInterface_CPy_NoSiteFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_BytesWarningFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset), mt_.CPythonLibraryInterface_CPy_BytesWarningFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_BytesWarningFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset), mt_.CPythonLibraryInterface_CPy_BytesWarningFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_FrozenFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset), mt_.CPythonLibraryInterface_CPy_FrozenFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_FrozenFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset), mt_.CPythonLibraryInterface_CPy_FrozenFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_IgnoreEnvironmentFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset), mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_IgnoreEnvironmentFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset), mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_DontWriteBytecodeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset), mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_DontWriteBytecodeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset), mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_NoUserSiteDirectory() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset), mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_NoUserSiteDirectory() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset), mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BaseException() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset), mt_.CPythonLibraryInterface_CPyExc_BaseException));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BaseException() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset), mt_.CPythonLibraryInterface_CPyExc_BaseException));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_Exception() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset), mt_.CPythonLibraryInterface_CPyExc_Exception));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_Exception() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset), mt_.CPythonLibraryInterface_CPyExc_Exception));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_StopIteration() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset), mt_.CPythonLibraryInterface_CPyExc_StopIteration));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_StopIteration() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset), mt_.CPythonLibraryInterface_CPyExc_StopIteration));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_GeneratorExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset), mt_.CPythonLibraryInterface_CPyExc_GeneratorExit));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_GeneratorExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset), mt_.CPythonLibraryInterface_CPyExc_GeneratorExit));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_StandardError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset), mt_.CPythonLibraryInterface_CPyExc_StandardError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_StandardError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset), mt_.CPythonLibraryInterface_CPyExc_StandardError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ArithmeticError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset), mt_.CPythonLibraryInterface_CPyExc_ArithmeticError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ArithmeticError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset), mt_.CPythonLibraryInterface_CPyExc_ArithmeticError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_LookupError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset), mt_.CPythonLibraryInterface_CPyExc_LookupError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_LookupError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset), mt_.CPythonLibraryInterface_CPyExc_LookupError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_AssertionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset), mt_.CPythonLibraryInterface_CPyExc_AssertionError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_AssertionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset), mt_.CPythonLibraryInterface_CPyExc_AssertionError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_AttributeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset), mt_.CPythonLibraryInterface_CPyExc_AttributeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_AttributeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset), mt_.CPythonLibraryInterface_CPyExc_AttributeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_EOFError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset), mt_.CPythonLibraryInterface_CPyExc_EOFError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_EOFError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset), mt_.CPythonLibraryInterface_CPyExc_EOFError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_FloatingPointError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset), mt_.CPythonLibraryInterface_CPyExc_FloatingPointError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_FloatingPointError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset), mt_.CPythonLibraryInterface_CPyExc_FloatingPointError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_EnvironmentError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset), mt_.CPythonLibraryInterface_CPyExc_EnvironmentError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_EnvironmentError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset), mt_.CPythonLibraryInterface_CPyExc_EnvironmentError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IOError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset), mt_.CPythonLibraryInterface_CPyExc_IOError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IOError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset), mt_.CPythonLibraryInterface_CPyExc_IOError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_OSError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset), mt_.CPythonLibraryInterface_CPyExc_OSError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_OSError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset), mt_.CPythonLibraryInterface_CPyExc_OSError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ImportError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ImportError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IndexError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndexError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IndexError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndexError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_KeyError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_KeyError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_KeyboardInterrupt() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_KeyboardInterrupt() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset), mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_MemoryError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_MemoryError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_NameError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset), mt_.CPythonLibraryInterface_CPyExc_NameError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_NameError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset), mt_.CPythonLibraryInterface_CPyExc_NameError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_OverflowError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset), mt_.CPythonLibraryInterface_CPyExc_OverflowError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_OverflowError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset), mt_.CPythonLibraryInterface_CPyExc_OverflowError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_RuntimeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_RuntimeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_NotImplementedError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset), mt_.CPythonLibraryInterface_CPyExc_NotImplementedError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_NotImplementedError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset), mt_.CPythonLibraryInterface_CPyExc_NotImplementedError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SyntaxError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SyntaxError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IndentationError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndentationError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IndentationError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset), mt_.CPythonLibraryInterface_CPyExc_IndentationError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_TabError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset), mt_.CPythonLibraryInterface_CPyExc_TabError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_TabError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset), mt_.CPythonLibraryInterface_CPyExc_TabError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ReferenceError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset), mt_.CPythonLibraryInterface_CPyExc_ReferenceError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ReferenceError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset), mt_.CPythonLibraryInterface_CPyExc_ReferenceError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SystemError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SystemError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SystemExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemExit));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SystemExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset), mt_.CPythonLibraryInterface_CPyExc_SystemExit));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_TypeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset), mt_.CPythonLibraryInterface_CPyExc_TypeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_TypeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset), mt_.CPythonLibraryInterface_CPyExc_TypeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnboundLocalError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnboundLocalError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeEncodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeEncodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeDecodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeDecodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeTranslateError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeTranslateError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ValueError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset), mt_.CPythonLibraryInterface_CPyExc_ValueError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ValueError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset), mt_.CPythonLibraryInterface_CPyExc_ValueError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ZeroDivisionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset), mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ZeroDivisionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset), mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_WindowsError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset), mt_.CPythonLibraryInterface_CPyExc_WindowsError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_WindowsError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset), mt_.CPythonLibraryInterface_CPyExc_WindowsError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BufferError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset), mt_.CPythonLibraryInterface_CPyExc_BufferError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BufferError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset), mt_.CPythonLibraryInterface_CPyExc_BufferError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_MemoryErrorInst() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_MemoryErrorInst() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset), mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_Warning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset), mt_.CPythonLibraryInterface_CPyExc_Warning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_Warning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset), mt_.CPythonLibraryInterface_CPyExc_Warning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UserWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UserWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UserWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UserWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_DeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_DeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_PendingDeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_PendingDeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SyntaxWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SyntaxWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_RuntimeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_RuntimeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_FutureWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_FutureWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_FutureWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_FutureWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ImportWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ImportWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_ImportWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BytesWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_BytesWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BytesWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset), mt_.CPythonLibraryInterface_CPyExc_BytesWarning));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyNullImporter_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset), mt_.CPythonLibraryInterface_CPyNullImporter_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyNullImporter_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset), mt_.CPythonLibraryInterface_CPyNullImporter_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySuper_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySuper_Type_Offset), mt_.CPythonLibraryInterface_CPySuper_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySuper_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySuper_Type_Offset), mt_.CPythonLibraryInterface_CPySuper_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyBool_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_Type_Offset), mt_.CPythonLibraryInterface_CPyBool_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyBool_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_Type_Offset), mt_.CPythonLibraryInterface_CPyBool_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Type_Offset), mt_.CPythonLibraryInterface_CPyObject_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Type_Offset), mt_.CPythonLibraryInterface_CPyObject_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Type_Offset), mt_.CPythonLibraryInterface_CPyModule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Type_Offset), mt_.CPythonLibraryInterface_CPyModule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset), mt_.CPythonLibraryInterface_CPyUnicode_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Type_Offset), mt_.CPythonLibraryInterface_CPyLong_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Type_Offset), mt_.CPythonLibraryInterface_CPyLong_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset), mt_.CPythonLibraryInterface_CPyFloat_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset), mt_.CPythonLibraryInterface_CPyFloat_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset), mt_.CPythonLibraryInterface_CPyTuple_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset), mt_.CPythonLibraryInterface_CPyTuple_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Type_Offset), mt_.CPythonLibraryInterface_CPyList_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Type_Offset), mt_.CPythonLibraryInterface_CPyList_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Type_Offset), mt_.CPythonLibraryInterface_CPyDict_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Type_Offset), mt_.CPythonLibraryInterface_CPyDict_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyClass_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Type_Offset), mt_.CPythonLibraryInterface_CPyClass_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyClass_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Type_Offset), mt_.CPythonLibraryInterface_CPyClass_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTraceBack_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTraceBack_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset), mt_.CPythonLibraryInterface_CPyTraceBack_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySlice_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySlice_Type_Offset), mt_.CPythonLibraryInterface_CPySlice_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySlice_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySlice_Type_Offset), mt_.CPythonLibraryInterface_CPySlice_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Type_Offset), mt_.CPythonLibraryInterface_CPyType_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Type_Offset), mt_.CPythonLibraryInterface_CPyType_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyMemoryView_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset), mt_.CPythonLibraryInterface_CPyMemoryView_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyMemoryView_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset), mt_.CPythonLibraryInterface_CPyMemoryView_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset), mt_.CPythonLibraryInterface_ConvertAndCacheString, str, std::forward<PyStringEncodings>(encoding), size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset), mt_.CPythonLibraryInterface_ConvertAndCacheString, str, std::forward<PyStringEncodings>(encoding), size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset), mt_.CPythonLibraryInterface_RegisterSpecificPythonClass, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset), mt_.CPythonLibraryInterface_RegisterSpecificPythonClass, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset), mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter, dt, f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset), mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter, dt, f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::RegisterBuiltinConverter on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void>
	{
		return (Hxx2::StaticMTable::_instance.CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<Url>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetSpecialPath_Offset), mt_.CPythonLibraryInterface_GetSpecialPath, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetSpecialPath_Offset), mt_.CPythonLibraryInterface_GetSpecialPath, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset), mt_.CPythonLibraryInterface_RegisterSpecialPath, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset), mt_.CPythonLibraryInterface_RegisterSpecialPath, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset), mt_.CPythonLibraryInterface_MPyDataCapsule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset), mt_.CPythonLibraryInterface_MPyDataCapsule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyData_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyData_Type_Offset), mt_.CPythonLibraryInterface_CPyData_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyData_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyData_Type_Offset), mt_.CPythonLibraryInterface_CPyData_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset), mt_.CPythonLibraryInterface_CPyCapsule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset), mt_.CPythonLibraryInterface_CPyCapsule_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyId_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyId_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyId_Type_Offset), mt_.CPythonLibraryInterface_CPyId_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyId_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyId_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyId_Type_Offset), mt_.CPythonLibraryInterface_CPyId_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyInternedId_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInternedId_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyInternedId_Type_Offset), mt_.CPythonLibraryInterface_CPyInternedId_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyInternedId_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInternedId_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyInternedId_Type_Offset), mt_.CPythonLibraryInterface_CPyInternedId_Type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::PrivateGetCurrentCallerContext() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset), mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::PrivateGetCurrentCallerContext() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset), mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyData_ToMapperInstance, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_MPyData_ToMapperInstance, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset), mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset), mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset), mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetAssociatedDataType(const DataType& dt) const -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<CPyRef>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset), mt_.CPythonLibraryInterface_GetAssociatedDataType, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetAssociatedDataType(const DataType& dt) -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<CPyRef>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset), mt_.CPythonLibraryInterface_GetAssociatedDataType, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetConverterPyObject_FromData(const DataType& dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset), mt_.CPythonLibraryInterface_GetConverterPyObject_FromData, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetConverterPyObject_FromData(const DataType& dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset), mt_.CPythonLibraryInterface_GetConverterPyObject_FromData, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_New(Data& data) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_Offset), mt_.CPythonLibraryInterface_MPyData_New, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_New(Data& data) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_Offset), mt_.CPythonLibraryInterface_MPyData_New, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_1_Offset), mt_.CPythonLibraryInterface_MPyData_New_1, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_1_Offset), mt_.CPythonLibraryInterface_MPyData_New_1, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataType_New(const DataType& dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataTypeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_New_Offset), mt_.CPythonLibraryInterface_MPyDataType_New, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataType_New(const DataType& dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_New_Offset), mt_.CPythonLibraryInterface_MPyDataType_New, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyDataType_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_CheckExact_Offset), mt_.CPythonLibraryInterface_MPyDataType_CheckExact, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType&>, const DataType&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType&>, const DataType&>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const DataType&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_GetDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_GetDataType_Offset), mt_.CPythonLibraryInterface_MPyDataType_GetDataType, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyData_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_CheckExact_Offset), mt_.CPythonLibraryInterface_MPyData_CheckExact, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) const -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Data*>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset), mt_.CPythonLibraryInterface_CPyObject_AsData, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Data*>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset), mt_.CPythonLibraryInterface_CPyObject_AsData, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetRegisteredTypesWithConversions() const -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset), mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset), mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseRef on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) const -> Result<DataType>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<DataType>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ParseDataType_Offset), mt_.CPythonLibraryInterface_ParseDataType, args, argIndex, canBeNone));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<DataType>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<DataType>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ParseDataType_Offset), mt_.CPythonLibraryInterface_ParseDataType, args, argIndex, canBeNone));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, DataType& dt, Bool unpackData) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, DataType& dt, Bool unpackData) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseGeneric on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::SetError(const Error& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_Offset), mt_.CPythonLibraryInterface_SetError, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::SetError(const Error& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_Offset), mt_.CPythonLibraryInterface_SetError, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::SetError(const ErrorPtr& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_1_Offset), mt_.CPythonLibraryInterface_SetError_1, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::SetError(const ErrorPtr& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_1_Offset), mt_.CPythonLibraryInterface_SetError_1, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MaxonConvertAuto(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset), mt_.CPythonLibraryInterface_MaxonConvertAuto, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MaxonConvertAuto(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset), mt_.CPythonLibraryInterface_MaxonConvertAuto, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset), mt_.CPythonLibraryInterface_CPyObject_FromGeneric, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset), mt_.CPythonLibraryInterface_CPyObject_FromGeneric, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CreateGlobalDictionary() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CreateGlobalDictionary) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CreateGlobalDictionary_Offset), mt_.CPythonLibraryInterface_CreateGlobalDictionary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetCurrentTraceback() const -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset), mt_.CPythonLibraryInterface_GetCurrentTraceback));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset), mt_.CPythonLibraryInterface_GetCurrentTraceback));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Enum_ToMapperInstance(T enumm) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Enum_ToMapperInstance(T enumm) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::Enum_ToMapperInstance on super."); if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyTypeRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyTypeRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyFrameRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyFrameRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyFrameRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyFrameRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyFrameRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyTracebackRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTracebackRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTracebackRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyTracebackRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyTracebackRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyCodeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyCodeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyCodeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyCodeRefClass_Offset), mt_.CPythonLibraryInterface_GetCPyCodeRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyClassRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyClassRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyClassRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyClassRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyClassRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyMemberRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyMemberRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyMemberRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyMemberRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyMemberRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyFunctionRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyFunctionRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyFunctionRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyFunctionRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyFunctionRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyHashMapRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyHashMapRef>>, Class<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyHashMapRef>>, Class<MPyHashMapRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyHashMapRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyHashMapRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyHashMapRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyHashMapRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyDataTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyDataRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyDataRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyDataRefClass));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyCallerContextRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyCallerContextRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyCallerContextRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset), mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass));
	}
	auto CPythonLibraryInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto CPythonLibraryInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_CPythonLibraryInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_CPythonLibraryInterface() { new (s_ui_maxon_py_CPythonLibraryInterface) maxon::EntityUse(CPythonLibraryInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_usi_maxon_py_CPythonLibraryInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_usi_maxon_py_CPythonLibraryInterface() { new (s_usi_maxon_py_CPythonLibraryInterface) maxon::EntityUse(CPythonLibraryInterface::_staticInterface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_usi_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_staticInterface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
}

struct PyModuleInterface::MTable
{
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConstants);
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetFunctions3);
	static const maxon::Char* const _ids;
	static const maxon::METHOD_FLAGS _flags[];
	static const maxon::Bool HAS_NONSTATIC = false;
	PRIVATE_MAXON_MF_POINTER(PyModuleInterface_GetFunctions3, GetFunctions3, true, maxon::GenericComponent,, (Result<void>), BaseArray<NativePyCFunctionTable>& functions);
	maxon::Int PyModuleInterface_GetFunctions3_Offset;
	PRIVATE_MAXON_MF_POINTER(PyModuleInterface_GetConstants, GetConstants, true, maxon::GenericComponent,, (Result<void>), BaseArray<Tuple<const Char*, Int32>>& constants);
	maxon::Int PyModuleInterface_GetConstants_Offset;
	template <typename W> void Init(maxon::Int offset)
	{
	if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PyModuleInterface, GetFunctions3))
	{
		maxon::Tie(PyModuleInterface_GetFunctions3, PyModuleInterface_GetFunctions3_Offset) = PyModuleInterface_GetFunctions3_GetPtr<W>(offset, true);
	}
	if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PyModuleInterface, GetConstants))
	{
		maxon::Tie(PyModuleInterface_GetConstants, PyModuleInterface_GetConstants_Offset) = PyModuleInterface_GetConstants_GetPtr<W>(offset, true);
	}
	}
	template <typename S> using CombinedMTable = maxon::CombinedMTable<PyModuleInterface, typename LibraryInterface::MTable::template CombinedMTable<S>>;
	template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PyModuleInterface, SUPER>;
	template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
};

struct PyModuleInterface::Hxx2
{
	template <typename S> class CWrapper : public LibraryInterface::Hxx2::template CWrapper<S>
	{
	public:
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConstants);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetFunctions3);
		static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			using Super0 = typename LibraryInterface::Hxx2::template CWrapper<S>;
			if constexpr (!S::Implementation::PROXY)
			{
				if (!(Super0::InitMTablesWithBases(info, offset))) return false;
			}
			auto* vt = (PyModuleInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PyModuleInterface::_interface); if (!vt) return false;
			vt->template Init<CWrapper>(offset);
			return true;
		}
		PRIVATE_MAXON_MF_WRAPPER(PyModuleInterface_GetFunctions3, maxon::GenericComponent,, (Result<void>), BaseArray<NativePyCFunctionTable>& functions) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetFunctions3(functions); }
		PRIVATE_MAXON_MF_WRAPPER(PyModuleInterface_GetConstants, maxon::GenericComponent,, (Result<void>), BaseArray<Tuple<const Char*, Int32>>& constants) { return ((typename S::Implementation*) PRIVATE_MAXON_MF_THIS(maxon::GenericComponent))->GetConstants(constants); }
	};

};
MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.PyModuleInterface_GetFunctions3_Offset), mt_.PyModuleInterface_GetFunctions3, functions);
}
MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return PRIVATE_MAXON_MF_INVOKE(((maxon::GenericComponent*) this + mt_.PyModuleInterface_GetConstants_Offset), mt_.PyModuleInterface_GetConstants, constants);
}

template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::Fn<S>::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions3) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetFunctions3_Offset), mt_.PyModuleInterface_GetFunctions3, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::COWFn<S>::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions3) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetFunctions3_Offset), mt_.PyModuleInterface_GetFunctions3, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::Fn<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetConstants_Offset), mt_.PyModuleInterface_GetConstants, constants));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::COWFn<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (PRIVATE_MAXON_MF_INVOKE((reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetConstants_Offset), mt_.PyModuleInterface_GetConstants, constants));
}
auto PyModuleInterface::GetPtr() -> Ptr { return Ptr(this); }
auto PyModuleInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_PyModuleInterface); \
MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_PyModuleInterface() { new (s_ui_maxon_PyModuleInterface) maxon::EntityUse(PyModuleInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
static maxon::EntityUse s_ui_maxon_PyModuleInterface(PyModuleInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
#ifndef MAXON_COMPILER_GCC
#else
#endif
#endif

#ifdef MAXON_COMPILER_GCC
	#pragma GCC diagnostic pop
#endif

#endif

