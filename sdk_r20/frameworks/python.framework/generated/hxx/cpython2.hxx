
#ifndef DOXYGEN

#ifdef MAXON_COMPILER_GCC
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wmisleading-indentation"
#endif

#if 1
namespace py
{
#ifdef MAXON_TARGET_WINDOWS
#endif

	struct PythonErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename W> void Init(maxon::Int offset)
		{
		}
		template <typename W> static maxon::Bool InitWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			if (!W::Implementation::PROXY && (!ErrorInterface::MTable::InitWithBases<W>(info, offset))) return false;
			MTable* vt = (MTable*) maxon::Object::PrivateGetOrCreateMTable(info, _interface); if (!vt) return false;
			vt->Init<W>(offset); return true;
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonErrorInterface, ErrorInterface::MTable::CombinedMTable<S>>;
		PRIVATE_MAXON_COMPBASE(PythonErrorInterface);
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	template <typename S> class PythonErrorInterface::Wrapper : public ErrorInterface::Wrapper<S>
	{
	public:
	};


	auto PythonErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
	static maxon::EntityUse s_ui_maxon_py_PythonErrorInterface(PythonErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif

	struct PythonTracebackErrorInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetUrl);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetUrl);
		static const maxon::Char* const _ids;
		static const maxon::Bool HAS_NONSTATIC = false;
		void (*_PythonTracebackErrorInterface_SetUrl) (maxon::GenericComponent* this_, const Url& url);
		maxon::Int _PythonTracebackErrorInterface_SetUrl_Offset;
		const Url& (*_PythonTracebackErrorInterface_GetUrl) (const maxon::GenericComponent* this_);
		maxon::Int _PythonTracebackErrorInterface_GetUrl_Offset;
		void (*_PythonTracebackErrorInterface_SetLineNumber) (maxon::GenericComponent* this_, Int line);
		maxon::Int _PythonTracebackErrorInterface_SetLineNumber_Offset;
		Int (*_PythonTracebackErrorInterface_GetLineNumber) (const maxon::GenericComponent* this_);
		maxon::Int _PythonTracebackErrorInterface_GetLineNumber_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, SetUrl))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, SetUrl), W, MTable>::type::_PythonTracebackErrorInterface_SetUrl;
				_PythonTracebackErrorInterface_SetUrl = reinterpret_cast<const decltype(_PythonTracebackErrorInterface_SetUrl)&>(ptr);
				_PythonTracebackErrorInterface_SetUrl_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, GetUrl))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, GetUrl), W, MTable>::type::_PythonTracebackErrorInterface_GetUrl;
				_PythonTracebackErrorInterface_GetUrl = reinterpret_cast<const decltype(_PythonTracebackErrorInterface_GetUrl)&>(ptr);
				_PythonTracebackErrorInterface_GetUrl_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, SetLineNumber))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, SetLineNumber), W, MTable>::type::_PythonTracebackErrorInterface_SetLineNumber;
				_PythonTracebackErrorInterface_SetLineNumber = reinterpret_cast<const decltype(_PythonTracebackErrorInterface_SetLineNumber)&>(ptr);
				_PythonTracebackErrorInterface_SetLineNumber_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, GetLineNumber))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PythonTracebackErrorInterface, GetLineNumber), W, MTable>::type::_PythonTracebackErrorInterface_GetLineNumber;
				_PythonTracebackErrorInterface_GetLineNumber = reinterpret_cast<const decltype(_PythonTracebackErrorInterface_GetLineNumber)&>(ptr);
				_PythonTracebackErrorInterface_GetLineNumber_Offset = offset;
			}
		}
		template <typename W> static maxon::Bool InitWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			if (!W::Implementation::PROXY && (!ErrorInterface::MTable::InitWithBases<W>(info, offset))) return false;
			MTable* vt = (MTable*) maxon::Object::PrivateGetOrCreateMTable(info, _interface); if (!vt) return false;
			vt->Init<W>(offset); return true;
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonTracebackErrorInterface, ErrorInterface::MTable::CombinedMTable<S>>;
		PRIVATE_MAXON_COMPBASE(PythonTracebackErrorInterface);
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	template <typename S> class PythonTracebackErrorInterface::Wrapper : public ErrorInterface::Wrapper<S>
	{
	public:
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetUrl);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetUrl);
		static void _PythonTracebackErrorInterface_SetUrl(maxon::GenericComponent* this_, const Url& url) { return ((typename S::Implementation*) this_)->SetUrl(url); }
		static const Url& _PythonTracebackErrorInterface_GetUrl(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetUrl(); }
		static void _PythonTracebackErrorInterface_SetLineNumber(maxon::GenericComponent* this_, Int line) { return ((typename S::Implementation*) this_)->SetLineNumber(line); }
		static Int _PythonTracebackErrorInterface_GetLineNumber(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetLineNumber(); }
	};

	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetUrl(const Url& url) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_._PythonTracebackErrorInterface_SetUrl((maxon::GenericComponent*) this + mt_._PythonTracebackErrorInterface_SetUrl_Offset, url);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetUrl() const -> const Url&
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_._PythonTracebackErrorInterface_GetUrl((const maxon::GenericComponent*) this + mt_._PythonTracebackErrorInterface_GetUrl_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetLineNumber(Int line) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_._PythonTracebackErrorInterface_SetLineNumber((maxon::GenericComponent*) this + mt_._PythonTracebackErrorInterface_SetLineNumber_Offset, line);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetLineNumber() const -> Int
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_._PythonTracebackErrorInterface_GetLineNumber((const maxon::GenericComponent*) this + mt_._PythonTracebackErrorInterface_GetLineNumber_Offset);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::ReferenceFunctionsImpl<S>::SetUrl(const Url& url) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_._PythonTracebackErrorInterface_SetUrl(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_SetUrl_Offset, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::COWReferenceFunctionsImpl<S>::SetUrl(const Url& url) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_._PythonTracebackErrorInterface_SetUrl(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_SetUrl_Offset, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::ConstReferenceFunctionsImpl<S>::GetUrl() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const Url&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (mt_._PythonTracebackErrorInterface_GetUrl(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_GetUrl_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::ReferenceFunctionsImpl<S>::SetLineNumber(Int line) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_._PythonTracebackErrorInterface_SetLineNumber(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_SetLineNumber_Offset, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::COWReferenceFunctionsImpl<S>::SetLineNumber(Int line) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_._PythonTracebackErrorInterface_SetLineNumber(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_SetLineNumber_Offset, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::ConstReferenceFunctionsImpl<S>::GetLineNumber() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (mt_._PythonTracebackErrorInterface_GetLineNumber(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._PythonTracebackErrorInterface_GetLineNumber_Offset));
	}
	auto PythonTracebackErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonTracebackErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
	static maxon::EntityUse s_ui_maxon_py_PythonTracebackErrorInterface(PythonTracebackErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif

	struct PythonSystemExitErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename W> void Init(maxon::Int offset)
		{
		}
		template <typename W> static maxon::Bool InitWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			if (!W::Implementation::PROXY && (!ErrorInterface::MTable::InitWithBases<W>(info, offset))) return false;
			MTable* vt = (MTable*) maxon::Object::PrivateGetOrCreateMTable(info, _interface); if (!vt) return false;
			vt->Init<W>(offset); return true;
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonSystemExitErrorInterface, ErrorInterface::MTable::CombinedMTable<S>>;
		PRIVATE_MAXON_COMPBASE(PythonSystemExitErrorInterface);
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	template <typename S> class PythonSystemExitErrorInterface::Wrapper : public ErrorInterface::Wrapper<S>
	{
	public:
	};


	auto PythonSystemExitErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonSystemExitErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
	static maxon::EntityUse s_ui_maxon_py_PythonSystemExitErrorInterface(PythonSystemExitErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif

	struct CPythonLibraryInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(AssociateDataTypeWithPythonTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_FromBool);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallable_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallerContext_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCode_Addr2Line);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyData_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Contains);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Copy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Items);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Keys);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Values);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_ExceptionMatches);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Fetch);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_NormalizeException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Occurred);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Print);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Restore);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetNone);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrno);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrnoAndFilename);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_AcquireLock);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_AcquireThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_EvalCode);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_GetBuiltins);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_InitThreads);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ReInitThreads);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ReleaseLock);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ReleaseThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_RestoreThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_SaveThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ThreadsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ArithmeticError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AssertionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AttributeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BaseException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BufferError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BytesWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_DeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EOFError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EnvironmentError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Exception);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FloatingPointError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FutureWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_GeneratorExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IOError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndentationError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndexError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyboardInterrupt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_LookupError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NameError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NotImplementedError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OSError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OverflowError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_PendingDeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RecursionErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ReferenceError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StandardError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StopIteration);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TabError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TypeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnboundLocalError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeDecodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeEncodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeTranslateError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UserWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ValueError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Warning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_WindowsError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ZeroDivisionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExceptionClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_AsFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGC_Collect);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGILState_GetThisThreadState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Ensure);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Release);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_GetImporter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_ImportModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_AsUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_FromUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyInt_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyIter_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Append);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_AsTuple);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Insert);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Reverse);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Sort);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyMemoryView_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddIntConstant);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNullImporter_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNumber_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_AsData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Call);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_CallFunction);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Dir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_FromGeneric);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemInt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetIter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_HasAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Hash);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_IsTrue);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Length);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Not);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Repr);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_RichCompare);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Str);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_TypeCheck);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_FileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_InteractiveLoopFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleFileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySite_AddSiteDir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySlice_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_AsCString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_AsString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_FromString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_FromStringAndSize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyString_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySuper_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetArgvEx);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_Swap);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_FastSubclass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_GetName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_HasFeature);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_IsSubtype);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Ready);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_BytesWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_CheckInterval);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_CompileStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DebugFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Decref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DivisionWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DontWriteBytecodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_False);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Finalize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_FrozenFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetBuildInfo);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCompiler);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCopyright);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPlatform);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetVersion);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IgnoreEnvironmentFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Incref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InitModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Initialize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InspectFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InteractiveFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoSiteFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoUserSiteDirectory);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_None);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NotImplemented);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_OptimizeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Py3kWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_QnewFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeDecref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeIncref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_TabcheckFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_True);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_UnicodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_UseClassExceptionsFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_VerboseFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ConvertAndCacheString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CreateGlobalDictionary);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ExecuteModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(FopenNative);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Free);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetAssociatedDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyCodeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyFrameRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTracebackRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConverterPyObject_FromData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCurrentTraceback);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetDll);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetGilState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyCallerContextRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyClassRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyFunctionRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyMemberRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetRegisteredTypesWithConversions);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Init);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitBuiltinModules);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(LastPythonCallFailed);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyClass_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_GetDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyFunction_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyMember_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MaxonConvertAuto);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ParseDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateCPyRandom_Init);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateGetCurrentCallerContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateRegisterBuiltinConverter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterComponentProxy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecificPythonClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackDataType);
		static const maxon::Char* const _ids;
		static const maxon::Bool HAS_NONSTATIC = false;
		Result<void> (*_CPythonLibraryInterface_Init) (maxon::GenericComponent* this_, const Url& librarypath, Bool createSubLibrary);
		maxon::Int _CPythonLibraryInterface_Init_Offset;
		Result<void> (*_CPythonLibraryInterface_InitTypes) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_InitTypes_Offset;
		Result<void> (*_CPythonLibraryInterface_InitBuiltinModules) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_InitBuiltinModules_Offset;
		void (*_CPythonLibraryInterface_CPy_Initialize) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_Initialize_Offset;
		void (*_CPythonLibraryInterface_CPy_Finalize) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_Finalize_Offset;
		void (*_CPythonLibraryInterface_PrivateCPyRandom_Init) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_PrivateCPyRandom_Init_Offset;
		CPyRef (*_CPythonLibraryInterface_CPy_InitModule) (maxon::GenericComponent* this_, const ModuleDefinition& module);
		maxon::Int _CPythonLibraryInterface_CPy_InitModule_Offset;
		void (*_CPythonLibraryInterface_Free) (maxon::GenericComponent* this_, const Delegate<void()>& shutdownEngine);
		maxon::Int _CPythonLibraryInterface_Free_Offset;
		const PythonDll& (*_CPythonLibraryInterface_GetDll) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetDll_Offset;
		FILE_native* (*_CPythonLibraryInterface_FopenNative) (maxon::GenericComponent* this_, const Char* name, const Char* mode);
		maxon::Int _CPythonLibraryInterface_FopenNative_Offset;
		Error (*_CPythonLibraryInterface_LastPythonCallFailed) (maxon::GenericComponent* this_, const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError);
		maxon::Int _CPythonLibraryInterface_LastPythonCallFailed_Offset;
		Result<MPyDataRef> (*_CPythonLibraryInterface_RegisterComponentProxy) (maxon::GenericComponent* this_, const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType* dtOfObject);
		maxon::Int _CPythonLibraryInterface_RegisterComponentProxy_Offset;
		Bool (*_CPythonLibraryInterface_CPy_IsInitialized) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_IsInitialized_Offset;
		const Char* (*_CPythonLibraryInterface_CPy_GetVersion) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetVersion_Offset;
		const Char* (*_CPythonLibraryInterface_CPy_GetPlatform) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetPlatform_Offset;
		const Char* (*_CPythonLibraryInterface_CPy_GetCopyright) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetCopyright_Offset;
		const Char* (*_CPythonLibraryInterface_CPy_GetCompiler) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetCompiler_Offset;
		const Char* (*_CPythonLibraryInterface_CPy_GetBuildInfo) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetBuildInfo_Offset;
		Result<void> (*_CPythonLibraryInterface_CPy_SetProgramName) (maxon::GenericComponent* this_, const String& name);
		maxon::Int _CPythonLibraryInterface_CPy_SetProgramName_Offset;
		Result<void> (*_CPythonLibraryInterface_CPy_SetPythonHome) (maxon::GenericComponent* this_, const Url& name);
		maxon::Int _CPythonLibraryInterface_CPy_SetPythonHome_Offset;
		String (*_CPythonLibraryInterface_CPy_GetProgramName) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetProgramName_Offset;
		String (*_CPythonLibraryInterface_CPy_GetPythonHome) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_GetPythonHome_Offset;
		Bool (*_CPythonLibraryInterface_ExecuteModule) (maxon::GenericComponent* this_, const String& name);
		maxon::Int _CPythonLibraryInterface_ExecuteModule_Offset;
		MPyCallerContextRef (*_CPythonLibraryInterface_CPyCallerContext_New) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyCallerContext_New_Offset;
		Bool (*_CPythonLibraryInterface_CPyRun_SimpleFileExFlags) (maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset;
		Bool (*_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) (maxon::GenericComponent* this_, const Url& url, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyRun_SimpleStringFlags) (maxon::GenericComponent* this_, const String& code, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset;
		NativePyObject* (*_CPythonLibraryInterface_CPyRun_FileExFlags) (maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPyRun_FileExFlags_Offset;
		Result<void> (*_CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) (maxon::GenericComponent* this_, FILE* fp, const Char* filename, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset;
		PYGILSTATE (*_CPythonLibraryInterface_CPyGilState_Ensure) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyGilState_Ensure_Offset;
		void (*_CPythonLibraryInterface_CPyGilState_Release) (maxon::GenericComponent* this_, PYGILSTATE state);
		maxon::Int _CPythonLibraryInterface_CPyGilState_Release_Offset;
		GILSTATE (*_CPythonLibraryInterface_GetGilState) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetGilState_Offset;
		NativePyThreadState* (*_CPythonLibraryInterface_CPyGILState_GetThisThreadState) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset;
		NativePyThreadState* (*_CPythonLibraryInterface_CPyThreadState_Swap) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int _CPythonLibraryInterface_CPyThreadState_Swap_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyThreadState_GetDict) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyThreadState_GetDict_Offset;
		CPyCodeRef (*_CPythonLibraryInterface_CPy_CompileStringFlags) (maxon::GenericComponent* this_, const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags);
		maxon::Int _CPythonLibraryInterface_CPy_CompileStringFlags_Offset;
		void (*_CPythonLibraryInterface_CPy_Incref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int _CPythonLibraryInterface_CPy_Incref_Offset;
		void (*_CPythonLibraryInterface_CPy_Decref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int _CPythonLibraryInterface_CPy_Decref_Offset;
		void (*_CPythonLibraryInterface_CPy_SafeIncref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int _CPythonLibraryInterface_CPy_SafeIncref_Offset;
		void (*_CPythonLibraryInterface_CPy_SafeDecref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int _CPythonLibraryInterface_CPy_SafeDecref_Offset;
		Int64 (*_CPythonLibraryInterface_CPyGC_Collect) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyGC_Collect_Offset;
		Int32 (*_CPythonLibraryInterface_CPyCode_Addr2Line) (maxon::GenericComponent* this_, const CPyCodeRef& codeObject, Int32 x);
		maxon::Int _CPythonLibraryInterface_CPyCode_Addr2Line_Offset;
		CPyRef (*_CPythonLibraryInterface_UnpackDataType) (maxon::GenericComponent* this_, const CPyRef& obj);
		maxon::Int _CPythonLibraryInterface_UnpackDataType_Offset;
		CPyRef (*_CPythonLibraryInterface_UnpackData) (maxon::GenericComponent* this_, const CPyRef& obj);
		maxon::Int _CPythonLibraryInterface_UnpackData_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPy_None) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_None_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPy_True) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_True_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPy_False) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_False_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPy_NotImplemented) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_NotImplemented_Offset;
		void (*_CPythonLibraryInterface_CPyErr_Print) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyErr_Print_Offset;
		void (*_CPythonLibraryInterface_CPyErr_Clear) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyErr_Clear_Offset;
		Bool (*_CPythonLibraryInterface_CPyErr_Occurred) (maxon::GenericComponent* this_, CPyRef* type);
		maxon::Int _CPythonLibraryInterface_CPyErr_Occurred_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyErr_SetString) (maxon::GenericComponent* this_, const CPyRef& errorType, const Char* errorString);
		maxon::Int _CPythonLibraryInterface_CPyErr_SetString_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) (maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber, const Char* filename);
		maxon::Int _CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyErr_SetWithErrno) (maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber);
		maxon::Int _CPythonLibraryInterface_CPyErr_SetWithErrno_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyErr_SetString_1) (maxon::GenericComponent* this_, const CPyRef& errorType, const String& errorString);
		maxon::Int _CPythonLibraryInterface_CPyErr_SetString_1_Offset;
		void (*_CPythonLibraryInterface_CPyErr_SetNone) (maxon::GenericComponent* this_, const CPyRef& errorType);
		maxon::Int _CPythonLibraryInterface_CPyErr_SetNone_Offset;
		void (*_CPythonLibraryInterface_CPyErr_Fetch) (maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int _CPythonLibraryInterface_CPyErr_Fetch_Offset;
		void (*_CPythonLibraryInterface_CPyErr_NormalizeException) (maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int _CPythonLibraryInterface_CPyErr_NormalizeException_Offset;
		void (*_CPythonLibraryInterface_CPyErr_Restore) (maxon::GenericComponent* this_, const CPyRef& type, const CPyRef& value, const CPyRef& traceback);
		maxon::Int _CPythonLibraryInterface_CPyErr_Restore_Offset;
		Bool (*_CPythonLibraryInterface_CPyErr_ExceptionMatches) (maxon::GenericComponent* this_, const CPyRef& exc);
		maxon::Int _CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset;
		Bool (*_CPythonLibraryInterface_CPyExceptionClass_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyExceptionClass_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyCapsule_New) (const maxon::GenericComponent* this_, void* pointer, const Char* name, CPyCapsule_Destructor* destructor);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_New_Offset;
		Bool (*_CPythonLibraryInterface_CPyCapsule_SetPointer) (maxon::GenericComponent* this_, const CPyRef& capsule, void* pointer);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_SetPointer_Offset;
		void* (*_CPythonLibraryInterface_CPyCapsule_GetPointer) (maxon::GenericComponent* this_, const CPyRef& capsule, const Char* name);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_GetPointer_Offset;
		void* (*_CPythonLibraryInterface_CPyCapsule_GetContext) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_GetContext_Offset;
		Bool (*_CPythonLibraryInterface_CPyCapsule_SetContext) (maxon::GenericComponent* this_, const CPyRef& capsule, void* context);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_SetContext_Offset;
		Bool (*_CPythonLibraryInterface_CPyCapsule_CheckExact) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_CheckExact_Offset;
		Bool (*_CPythonLibraryInterface_CPyTraceBack_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyTraceBack_Check_Offset;
		Bool (*_CPythonLibraryInterface_CPyClass_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyClass_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyTuple_New) (const maxon::GenericComponent* this_, UInt size);
		maxon::Int _CPythonLibraryInterface_CPyTuple_New_Offset;
		UInt (*_CPythonLibraryInterface_CPyTuple_Size) (maxon::GenericComponent* this_, const CPyRef& tuple);
		maxon::Int _CPythonLibraryInterface_CPyTuple_Size_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyTuple_GetItem) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt index);
		maxon::Int _CPythonLibraryInterface_CPyTuple_GetItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyTuple_SetItem) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt index, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyTuple_SetItem_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyTuple_GetSlice) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt from, UInt to);
		maxon::Int _CPythonLibraryInterface_CPyTuple_GetSlice_Offset;
		Bool (*_CPythonLibraryInterface_CPyTuple_CheckExact) (maxon::GenericComponent* this_, const CPyRef& tuple);
		maxon::Int _CPythonLibraryInterface_CPyTuple_CheckExact_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_HasAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* attrName);
		maxon::Int _CPythonLibraryInterface_CPyObject_HasAttrString_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_SetAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* name, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyObject_SetAttrString_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_GetAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* name);
		maxon::Int _CPythonLibraryInterface_CPyObject_GetAttrString_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_Call) (maxon::GenericComponent* this_, const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw);
		maxon::Int _CPythonLibraryInterface_CPyObject_Call_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_Str) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Str_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_Repr) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Repr_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_Dir) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Dir_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_RichCompare) (maxon::GenericComponent* this_, const CPyRef& o1, const CPyRef& o2, Int32 opid);
		maxon::Int _CPythonLibraryInterface_CPyObject_RichCompare_Offset;
		Int64 (*_CPythonLibraryInterface_CPyObject_Hash) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Hash_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_IsTrue) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_IsTrue_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_Not) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Not_Offset;
		Bool (*_CPythonLibraryInterface_CPyCallable_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyCallable_Check_Offset;
		Int (*_CPythonLibraryInterface_CPyObject_Length) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_Length_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_GetItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key);
		maxon::Int _CPythonLibraryInterface_CPyObject_GetItem_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_GetItemInt) (maxon::GenericComponent* this_, const CPyRef& o, Int index);
		maxon::Int _CPythonLibraryInterface_CPyObject_GetItemInt_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_GetItemString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* index);
		maxon::Int _CPythonLibraryInterface_CPyObject_GetItemString_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_DelItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key);
		maxon::Int _CPythonLibraryInterface_CPyObject_DelItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_SetItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyObject_SetItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyObject_TypeCheck) (maxon::GenericComponent* this_, const CPyRef& object, const CPyTypeRef& type);
		maxon::Int _CPythonLibraryInterface_CPyObject_TypeCheck_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_CallFunction) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_CallFunction_Offset;
		CPyRef (*_CPythonLibraryInterface_CPySys_GetObject) (maxon::GenericComponent* this_, const Char* name);
		maxon::Int _CPythonLibraryInterface_CPySys_GetObject_Offset;
		Bool (*_CPythonLibraryInterface_CPySys_SetObject) (maxon::GenericComponent* this_, const Char* name, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPySys_SetObject_Offset;
		Result<void> (*_CPythonLibraryInterface_CPySys_SetPath) (maxon::GenericComponent* this_, const BaseArray<Url>& paths, PATHHANDLE add);
		maxon::Int _CPythonLibraryInterface_CPySys_SetPath_Offset;
		Result<void> (*_CPythonLibraryInterface_CPySys_SetArgvEx) (maxon::GenericComponent* this_, const BaseArray<String>& args, Bool updatepath);
		maxon::Int _CPythonLibraryInterface_CPySys_SetArgvEx_Offset;
		BaseArray<Url> (*_CPythonLibraryInterface_CPySys_GetPath) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPySys_GetPath_Offset;
		Result<void> (*_CPythonLibraryInterface_CPySite_AddSiteDir) (maxon::GenericComponent* this_, const Url& siteDir);
		maxon::Int _CPythonLibraryInterface_CPySite_AddSiteDir_Offset;
		Bool (*_CPythonLibraryInterface_CPyString_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyString_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyString_FromString) (const maxon::GenericComponent* this_, const Char* str);
		maxon::Int _CPythonLibraryInterface_CPyString_FromString_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyString_FromStringAndSize) (maxon::GenericComponent* this_, const Block<const Char>& block);
		maxon::Int _CPythonLibraryInterface_CPyString_FromStringAndSize_Offset;
		Result<String> (*_CPythonLibraryInterface_CPyString_AsString) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int _CPythonLibraryInterface_CPyString_AsString_Offset;
		const Char* (*_CPythonLibraryInterface_CPyString_AsCString) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int _CPythonLibraryInterface_CPyString_AsCString_Offset;
		Int (*_CPythonLibraryInterface_CPyString_Size) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int _CPythonLibraryInterface_CPyString_Size_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_GetIter) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyObject_GetIter_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyIter_Next) (const maxon::GenericComponent* this_, const CPyRef& it);
		maxon::Int _CPythonLibraryInterface_CPyIter_Next_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_New) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyDict_New_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_GetItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, Bool raiseKeyError);
		maxon::Int _CPythonLibraryInterface_CPyDict_GetItem_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_GetItemString) (maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, Bool raiseKeyError);
		maxon::Int _CPythonLibraryInterface_CPyDict_GetItemString_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_SetItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyDict_SetItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_DelItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key);
		maxon::Int _CPythonLibraryInterface_CPyDict_DelItem_Offset;
		CONTAINS (*_CPythonLibraryInterface_CPyDict_Contains) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key);
		maxon::Int _CPythonLibraryInterface_CPyDict_Contains_Offset;
		void (*_CPythonLibraryInterface_CPyDict_Clear) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Clear_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_Next) (maxon::GenericComponent* this_, const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value);
		maxon::Int _CPythonLibraryInterface_CPyDict_Next_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_Keys) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Keys_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_Values) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Values_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_Items) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Items_Offset;
		Int (*_CPythonLibraryInterface_CPyDict_Size) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Size_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyDict_Copy) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int _CPythonLibraryInterface_CPyDict_Copy_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_SetItemString) (const maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyDict_SetItemString_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_Check) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyDict_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyList_New) (maxon::GenericComponent* this_, UInt size);
		maxon::Int _CPythonLibraryInterface_CPyList_New_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_CheckExact) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int _CPythonLibraryInterface_CPyList_CheckExact_Offset;
		Int (*_CPythonLibraryInterface_CPyList_Size) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int _CPythonLibraryInterface_CPyList_Size_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyList_GetItem) (maxon::GenericComponent* this_, const CPyRef& list, UInt index);
		maxon::Int _CPythonLibraryInterface_CPyList_GetItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_SetItem) (maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyList_SetItem_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_Insert) (maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyList_Insert_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_Append) (maxon::GenericComponent* this_, const CPyRef& list, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyList_Append_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyList_GetSlice) (maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to);
		maxon::Int _CPythonLibraryInterface_CPyList_GetSlice_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_SetSlice) (maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to, const CPyRef& item);
		maxon::Int _CPythonLibraryInterface_CPyList_SetSlice_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_Sort) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int _CPythonLibraryInterface_CPyList_Sort_Offset;
		Bool (*_CPythonLibraryInterface_CPyList_Reverse) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int _CPythonLibraryInterface_CPyList_Reverse_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyList_AsTuple) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int _CPythonLibraryInterface_CPyList_AsTuple_Offset;
		Bool (*_CPythonLibraryInterface_CPyDict_DelItemString) (maxon::GenericComponent* this_, const CPyRef& p, const Char* key);
		maxon::Int _CPythonLibraryInterface_CPyDict_DelItemString_Offset;
		Bool (*_CPythonLibraryInterface_CPyModule_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyModule_Check_Offset;
		Bool (*_CPythonLibraryInterface_CPyModule_AddObject) (maxon::GenericComponent* this_, const CPyRef& module, const Char* name, const CPyRef& value);
		maxon::Int _CPythonLibraryInterface_CPyModule_AddObject_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyModule_GetDict) (maxon::GenericComponent* this_, const CPyRef& module);
		maxon::Int _CPythonLibraryInterface_CPyModule_GetDict_Offset;
		Bool (*_CPythonLibraryInterface_CPyModule_AddIntConstant) (maxon::GenericComponent* this_, const CPyRef& mod, const Char* name, long value);
		maxon::Int _CPythonLibraryInterface_CPyModule_AddIntConstant_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyImport_ImportModule) (maxon::GenericComponent* this_, const Char* name);
		maxon::Int _CPythonLibraryInterface_CPyImport_ImportModule_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyImport_GetImporter) (maxon::GenericComponent* this_, const CPyRef& path);
		maxon::Int _CPythonLibraryInterface_CPyImport_GetImporter_Offset;
		Bool (*_CPythonLibraryInterface_CPyType_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyType_Check_Offset;
		Bool (*_CPythonLibraryInterface_CPyType_IsSubtype) (maxon::GenericComponent* this_, const CPyTypeRef& a, const CPyTypeRef& b);
		maxon::Int _CPythonLibraryInterface_CPyType_IsSubtype_Offset;
		Bool (*_CPythonLibraryInterface_CPyType_HasFeature) (const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f);
		maxon::Int _CPythonLibraryInterface_CPyType_HasFeature_Offset;
		Bool (*_CPythonLibraryInterface_CPyType_FastSubclass) (const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f);
		maxon::Int _CPythonLibraryInterface_CPyType_FastSubclass_Offset;
		Result<String> (*_CPythonLibraryInterface_CPyType_GetName) (maxon::GenericComponent* this_, const CPyTypeRef& type);
		maxon::Int _CPythonLibraryInterface_CPyType_GetName_Offset;
		Bool (*_CPythonLibraryInterface_CPyType_Ready) (maxon::GenericComponent* this_, CPyTypeRef& type);
		maxon::Int _CPythonLibraryInterface_CPyType_Ready_Offset;
		NativePyThreadState* (*_CPythonLibraryInterface_CPyEval_SaveThread) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_SaveThread_Offset;
		void (*_CPythonLibraryInterface_CPyEval_RestoreThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int _CPythonLibraryInterface_CPyEval_RestoreThread_Offset;
		Bool (*_CPythonLibraryInterface_CPyEval_ThreadsInitialized) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset;
		void (*_CPythonLibraryInterface_CPyEval_InitThreads) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_InitThreads_Offset;
		void (*_CPythonLibraryInterface_CPyEval_AcquireLock) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_AcquireLock_Offset;
		void (*_CPythonLibraryInterface_CPyEval_ReleaseLock) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_ReleaseLock_Offset;
		void (*_CPythonLibraryInterface_CPyEval_AcquireThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int _CPythonLibraryInterface_CPyEval_AcquireThread_Offset;
		void (*_CPythonLibraryInterface_CPyEval_ReleaseThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int _CPythonLibraryInterface_CPyEval_ReleaseThread_Offset;
		void (*_CPythonLibraryInterface_CPyEval_ReInitThreads) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_ReInitThreads_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyEval_GetBuiltins) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyEval_GetBuiltins_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyEval_EvalCode) (const maxon::GenericComponent* this_, const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals);
		maxon::Int _CPythonLibraryInterface_CPyEval_EvalCode_Offset;
		Bool (*_CPythonLibraryInterface_CPyFloat_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyFloat_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyFloat_FromFloat32) (maxon::GenericComponent* this_, Float32 value);
		maxon::Int _CPythonLibraryInterface_CPyFloat_FromFloat32_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyFloat_FromFloat64) (maxon::GenericComponent* this_, Float64 value);
		maxon::Int _CPythonLibraryInterface_CPyFloat_FromFloat64_Offset;
		Float64 (*_CPythonLibraryInterface_CPyFloat_AsFloat64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyFloat_AsFloat64_Offset;
		Bool (*_CPythonLibraryInterface_CPyInt_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_Check_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyBool_FromBool) (maxon::GenericComponent* this_, Bool value);
		maxon::Int _CPythonLibraryInterface_CPyBool_FromBool_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromInt16) (maxon::GenericComponent* this_, Int16 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromInt16_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromUInt16) (maxon::GenericComponent* this_, UInt16 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromUInt16_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromInt32) (maxon::GenericComponent* this_, Int32 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromInt32_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromUInt32) (maxon::GenericComponent* this_, UInt32 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromUInt32_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromInt64) (maxon::GenericComponent* this_, Int64 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromInt64_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyInt_FromUInt64) (maxon::GenericComponent* this_, UInt64 value);
		maxon::Int _CPythonLibraryInterface_CPyInt_FromUInt64_Offset;
		Int16 (*_CPythonLibraryInterface_CPyInt_AsInt16) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsInt16_Offset;
		UInt16 (*_CPythonLibraryInterface_CPyInt_AsUInt16) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsUInt16_Offset;
		Int32 (*_CPythonLibraryInterface_CPyInt_AsInt32) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsInt32_Offset;
		UInt32 (*_CPythonLibraryInterface_CPyInt_AsUInt32) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsUInt32_Offset;
		Int64 (*_CPythonLibraryInterface_CPyInt_AsInt64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsInt64_Offset;
		UInt64 (*_CPythonLibraryInterface_CPyInt_AsUInt64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyInt_AsUInt64_Offset;
		Bool (*_CPythonLibraryInterface_CPyNumber_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_CPyNumber_Check_Offset;
		MPyFunctionRef (*_CPythonLibraryInterface_MPyFunction_New) (maxon::GenericComponent* this_, const reflection::Function* func);
		maxon::Int _CPythonLibraryInterface_MPyFunction_New_Offset;
		MPyMemberRef (*_CPythonLibraryInterface_MPyMember_New) (maxon::GenericComponent* this_, const reflection::Member* member);
		maxon::Int _CPythonLibraryInterface_MPyMember_New_Offset;
		MPyClassRef (*_CPythonLibraryInterface_MPyClass_New) (maxon::GenericComponent* this_, const reflection::Class* cls);
		maxon::Int _CPythonLibraryInterface_MPyClass_New_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_DebugFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_DebugFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_VerboseFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_VerboseFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_InteractiveFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_InteractiveFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_InspectFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_InspectFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_OptimizeFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_OptimizeFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_NoSiteFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_NoSiteFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_BytesWarningFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_BytesWarningFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_UseClassExceptionsFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_UseClassExceptionsFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_FrozenFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_FrozenFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_TabcheckFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_TabcheckFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_UnicodeFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_UnicodeFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_DivisionWarningFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_DivisionWarningFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_NoUserSiteDirectory) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_QnewFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_QnewFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_Py3kWarningFlag) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_Py3kWarningFlag_Offset;
		Int32* (*_CPythonLibraryInterface_CPy_CheckInterval) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPy_CheckInterval_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_BaseException) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_BaseException_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_Exception) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_Exception_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_StopIteration) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_StopIteration_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_GeneratorExit) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_GeneratorExit_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_StandardError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_StandardError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ArithmeticError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ArithmeticError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_LookupError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_LookupError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_AssertionError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_AssertionError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_AttributeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_AttributeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_EOFError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_EOFError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_FloatingPointError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_FloatingPointError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_EnvironmentError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_EnvironmentError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_IOError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_IOError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_OSError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_OSError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ImportError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ImportError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_IndexError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_IndexError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_KeyError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_KeyError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_KeyboardInterrupt) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_MemoryError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_MemoryError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_NameError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_NameError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_OverflowError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_OverflowError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_RuntimeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_RuntimeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_NotImplementedError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_NotImplementedError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_SyntaxError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_SyntaxError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_IndentationError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_IndentationError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_TabError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_TabError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ReferenceError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ReferenceError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_SystemError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_SystemError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_SystemExit) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_SystemExit_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_TypeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_TypeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnboundLocalError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnicodeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnicodeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnicodeEncodeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnicodeDecodeError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnicodeTranslateError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ValueError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ValueError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ZeroDivisionError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_WindowsError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_WindowsError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_BufferError) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_BufferError_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_MemoryErrorInst) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_RecursionErrorInst) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_RecursionErrorInst_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_Warning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_Warning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UserWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UserWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_DeprecationWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_SyntaxWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_RuntimeWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_FutureWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_FutureWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_ImportWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_ImportWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_UnicodeWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset;
		CPyConstRef (*_CPythonLibraryInterface_CPyExc_BytesWarning) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyExc_BytesWarning_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyNullImporter_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyNullImporter_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPySuper_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPySuper_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyBool_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyBool_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyObject_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyObject_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyModule_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyModule_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyString_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyString_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyInt_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyInt_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyLong_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyLong_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyFloat_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyFloat_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyTuple_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyTuple_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyList_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyList_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyDict_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyDict_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyClass_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyClass_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyTraceBack_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyTraceBack_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPySlice_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPySlice_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyType_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyType_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyMemoryView_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyMemoryView_Type_Offset;
		const PyChar* (*_CPythonLibraryInterface_ConvertAndCacheString) (maxon::GenericComponent* this_, const String& str, const StringEncodingRef& encoding);
		maxon::Int _CPythonLibraryInterface_ConvertAndCacheString_Offset;
		Result<void> (*_CPythonLibraryInterface_RegisterSpecificPythonClass) (maxon::GenericComponent* this_, const Id& typeId, const CPyTypeRef& type);
		maxon::Int _CPythonLibraryInterface_RegisterSpecificPythonClass_Offset;
		Result<void> (*_CPythonLibraryInterface_PrivateRegisterBuiltinConverter) (maxon::GenericComponent* this_, const DataType* dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2);
		maxon::Int _CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset;
		Url (*_CPythonLibraryInterface_GetSpecialPath) (maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1);
		maxon::Int _CPythonLibraryInterface_GetSpecialPath_Offset;
		void (*_CPythonLibraryInterface_RegisterSpecialPath) (maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1, const Url& path);
		maxon::Int _CPythonLibraryInterface_RegisterSpecialPath_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_MPyDataCapsule_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_MPyDataCapsule_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyData_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyData_Type_Offset;
		CPyTypeConstRef (*_CPythonLibraryInterface_CPyCapsule_Type) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CPyCapsule_Type_Offset;
		CPyRef (*_CPythonLibraryInterface_PrivateGetCurrentCallerContext) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset;
		CPyRef (*_CPythonLibraryInterface_MPyDataType_ToMapperInstance) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int _CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset;
		CPyRef (*_CPythonLibraryInterface_MPyData_ToMapperInstance) (maxon::GenericComponent* this_, const MPyDataRef& capsule);
		maxon::Int _CPythonLibraryInterface_MPyData_ToMapperInstance_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_ToMapperInstance) (maxon::GenericComponent* this_, const DataType* dt, const CPyRef& capsule);
		maxon::Int _CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset;
		Result<void> (*_CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) (maxon::GenericComponent* this_, const DataType* dt, const CPyRef& type);
		maxon::Int _CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset;
		Result<CPyRef> (*_CPythonLibraryInterface_GetAssociatedDataType) (maxon::GenericComponent* this_, const DataType* dt);
		maxon::Int _CPythonLibraryInterface_GetAssociatedDataType_Offset;
		DelegatePyObject_FromData<>* (*_CPythonLibraryInterface_GetConverterPyObject_FromData) (maxon::GenericComponent* this_, const DataType* dt);
		maxon::Int _CPythonLibraryInterface_GetConverterPyObject_FromData_Offset;
		MPyDataRef (*_CPythonLibraryInterface_MPyData_New) (maxon::GenericComponent* this_, Data& data);
		maxon::Int _CPythonLibraryInterface_MPyData_New_Offset;
		MPyDataRef (*_CPythonLibraryInterface_MPyData_New_1) (maxon::GenericComponent* this_, const DataType* dt, Generic* data, Bool owner, const DataType* mapDt);
		maxon::Int _CPythonLibraryInterface_MPyData_New_1_Offset;
		MPyDataTypeRef (*_CPythonLibraryInterface_MPyDataType_New) (maxon::GenericComponent* this_, const DataType* dt);
		maxon::Int _CPythonLibraryInterface_MPyDataType_New_Offset;
		Bool (*_CPythonLibraryInterface_MPyDataType_CheckExact) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_MPyDataType_CheckExact_Offset;
		const DataType* (*_CPythonLibraryInterface_MPyDataType_GetDataType) (const maxon::GenericComponent* this_, const MPyDataTypeRef& o);
		maxon::Int _CPythonLibraryInterface_MPyDataType_GetDataType_Offset;
		Bool (*_CPythonLibraryInterface_MPyData_CheckExact) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int _CPythonLibraryInterface_MPyData_CheckExact_Offset;
		Result<Data*> (*_CPythonLibraryInterface_CPyObject_AsData) (maxon::GenericComponent* this_, Int stackDepth, const CPyRef& obj, const DataType* expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n);
		maxon::Int _CPythonLibraryInterface_CPyObject_AsData_Offset;
		Result<BaseArray<TYPE_CONVERSION_TUPLE>> (*_CPythonLibraryInterface_GetRegisteredTypesWithConversions) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset;
		Result<const DataType*> (*_CPythonLibraryInterface_ParseDataType) (maxon::GenericComponent* this_, const CPyRef& args, Int32 argIndex, Bool canBeNone);
		maxon::Int _CPythonLibraryInterface_ParseDataType_Offset;
		void (*_CPythonLibraryInterface_SetError) (maxon::GenericComponent* this_, const Error& err);
		maxon::Int _CPythonLibraryInterface_SetError_Offset;
		void (*_CPythonLibraryInterface_SetError_1) (maxon::GenericComponent* this_, const ErrorPtr& err);
		maxon::Int _CPythonLibraryInterface_SetError_1_Offset;
		CPyRef (*_CPythonLibraryInterface_MaxonConvertAuto) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int _CPythonLibraryInterface_MaxonConvertAuto_Offset;
		CPyRef (*_CPythonLibraryInterface_CPyObject_FromGeneric) (maxon::GenericComponent* this_, const DataType* origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count);
		maxon::Int _CPythonLibraryInterface_CPyObject_FromGeneric_Offset;
		CPyRef (*_CPythonLibraryInterface_CreateGlobalDictionary) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_CreateGlobalDictionary_Offset;
		Result<BaseArray<SourceLocation>> (*_CPythonLibraryInterface_GetCurrentTraceback) (maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCurrentTraceback_Offset;
		Class<CPyRef> (*_CPythonLibraryInterface_GetCPyRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCPyRefClass_Offset;
		Class<CPyTypeRef> (*_CPythonLibraryInterface_GetCPyTypeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCPyTypeRefClass_Offset;
		Class<CPyFrameRef> (*_CPythonLibraryInterface_GetCPyFrameRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCPyFrameRefClass_Offset;
		Class<CPyTracebackRef> (*_CPythonLibraryInterface_GetCPyTracebackRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCPyTracebackRefClass_Offset;
		Class<CPyCodeRef> (*_CPythonLibraryInterface_GetCPyCodeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetCPyCodeRefClass_Offset;
		Class<MPyClassRef> (*_CPythonLibraryInterface_GetMPyClassRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyClassRefClass_Offset;
		Class<MPyMemberRef> (*_CPythonLibraryInterface_GetMPyMemberRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyMemberRefClass_Offset;
		Class<MPyFunctionRef> (*_CPythonLibraryInterface_GetMPyFunctionRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyFunctionRefClass_Offset;
		Class<MPyDataTypeRef> (*_CPythonLibraryInterface_GetMPyDataTypeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset;
		Class<MPyDataRef> (*_CPythonLibraryInterface_GetMPyDataRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyDataRefClass_Offset;
		Class<MPyCallerContextRef> (*_CPythonLibraryInterface_GetMPyCallerContextRefClass) (const maxon::GenericComponent* this_);
		maxon::Int _CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, Init))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, Init), W, MTable>::type::_CPythonLibraryInterface_Init;
				_CPythonLibraryInterface_Init = reinterpret_cast<const decltype(_CPythonLibraryInterface_Init)&>(ptr);
				_CPythonLibraryInterface_Init_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, InitTypes))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, InitTypes), W, MTable>::type::_CPythonLibraryInterface_InitTypes;
				_CPythonLibraryInterface_InitTypes = reinterpret_cast<const decltype(_CPythonLibraryInterface_InitTypes)&>(ptr);
				_CPythonLibraryInterface_InitTypes_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, InitBuiltinModules))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, InitBuiltinModules), W, MTable>::type::_CPythonLibraryInterface_InitBuiltinModules;
				_CPythonLibraryInterface_InitBuiltinModules = reinterpret_cast<const decltype(_CPythonLibraryInterface_InitBuiltinModules)&>(ptr);
				_CPythonLibraryInterface_InitBuiltinModules_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Initialize))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Initialize), W, MTable>::type::_CPythonLibraryInterface_CPy_Initialize;
				_CPythonLibraryInterface_CPy_Initialize = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_Initialize)&>(ptr);
				_CPythonLibraryInterface_CPy_Initialize_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Finalize))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Finalize), W, MTable>::type::_CPythonLibraryInterface_CPy_Finalize;
				_CPythonLibraryInterface_CPy_Finalize = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_Finalize)&>(ptr);
				_CPythonLibraryInterface_CPy_Finalize_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateCPyRandom_Init))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateCPyRandom_Init), W, MTable>::type::_CPythonLibraryInterface_PrivateCPyRandom_Init;
				_CPythonLibraryInterface_PrivateCPyRandom_Init = reinterpret_cast<const decltype(_CPythonLibraryInterface_PrivateCPyRandom_Init)&>(ptr);
				_CPythonLibraryInterface_PrivateCPyRandom_Init_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InitModule))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InitModule), W, MTable>::type::_CPythonLibraryInterface_CPy_InitModule;
				_CPythonLibraryInterface_CPy_InitModule = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_InitModule)&>(ptr);
				_CPythonLibraryInterface_CPy_InitModule_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, Free))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, Free), W, MTable>::type::_CPythonLibraryInterface_Free;
				_CPythonLibraryInterface_Free = reinterpret_cast<const decltype(_CPythonLibraryInterface_Free)&>(ptr);
				_CPythonLibraryInterface_Free_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetDll))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetDll), W, MTable>::type::_CPythonLibraryInterface_GetDll;
				_CPythonLibraryInterface_GetDll = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetDll)&>(ptr);
				_CPythonLibraryInterface_GetDll_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, FopenNative))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, FopenNative), W, MTable>::type::_CPythonLibraryInterface_FopenNative;
				_CPythonLibraryInterface_FopenNative = reinterpret_cast<const decltype(_CPythonLibraryInterface_FopenNative)&>(ptr);
				_CPythonLibraryInterface_FopenNative_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, LastPythonCallFailed))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, LastPythonCallFailed), W, MTable>::type::_CPythonLibraryInterface_LastPythonCallFailed;
				_CPythonLibraryInterface_LastPythonCallFailed = reinterpret_cast<const decltype(_CPythonLibraryInterface_LastPythonCallFailed)&>(ptr);
				_CPythonLibraryInterface_LastPythonCallFailed_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterComponentProxy))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterComponentProxy), W, MTable>::type::_CPythonLibraryInterface_RegisterComponentProxy;
				_CPythonLibraryInterface_RegisterComponentProxy = reinterpret_cast<const decltype(_CPythonLibraryInterface_RegisterComponentProxy)&>(ptr);
				_CPythonLibraryInterface_RegisterComponentProxy_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_IsInitialized))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_IsInitialized), W, MTable>::type::_CPythonLibraryInterface_CPy_IsInitialized;
				_CPythonLibraryInterface_CPy_IsInitialized = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_IsInitialized)&>(ptr);
				_CPythonLibraryInterface_CPy_IsInitialized_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetVersion))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetVersion), W, MTable>::type::_CPythonLibraryInterface_CPy_GetVersion;
				_CPythonLibraryInterface_CPy_GetVersion = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetVersion)&>(ptr);
				_CPythonLibraryInterface_CPy_GetVersion_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetPlatform))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetPlatform), W, MTable>::type::_CPythonLibraryInterface_CPy_GetPlatform;
				_CPythonLibraryInterface_CPy_GetPlatform = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetPlatform)&>(ptr);
				_CPythonLibraryInterface_CPy_GetPlatform_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetCopyright))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetCopyright), W, MTable>::type::_CPythonLibraryInterface_CPy_GetCopyright;
				_CPythonLibraryInterface_CPy_GetCopyright = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetCopyright)&>(ptr);
				_CPythonLibraryInterface_CPy_GetCopyright_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetCompiler))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetCompiler), W, MTable>::type::_CPythonLibraryInterface_CPy_GetCompiler;
				_CPythonLibraryInterface_CPy_GetCompiler = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetCompiler)&>(ptr);
				_CPythonLibraryInterface_CPy_GetCompiler_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetBuildInfo))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetBuildInfo), W, MTable>::type::_CPythonLibraryInterface_CPy_GetBuildInfo;
				_CPythonLibraryInterface_CPy_GetBuildInfo = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetBuildInfo)&>(ptr);
				_CPythonLibraryInterface_CPy_GetBuildInfo_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SetProgramName))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SetProgramName), W, MTable>::type::_CPythonLibraryInterface_CPy_SetProgramName;
				_CPythonLibraryInterface_CPy_SetProgramName = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_SetProgramName)&>(ptr);
				_CPythonLibraryInterface_CPy_SetProgramName_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SetPythonHome))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SetPythonHome), W, MTable>::type::_CPythonLibraryInterface_CPy_SetPythonHome;
				_CPythonLibraryInterface_CPy_SetPythonHome = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_SetPythonHome)&>(ptr);
				_CPythonLibraryInterface_CPy_SetPythonHome_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetProgramName))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetProgramName), W, MTable>::type::_CPythonLibraryInterface_CPy_GetProgramName;
				_CPythonLibraryInterface_CPy_GetProgramName = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetProgramName)&>(ptr);
				_CPythonLibraryInterface_CPy_GetProgramName_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetPythonHome))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_GetPythonHome), W, MTable>::type::_CPythonLibraryInterface_CPy_GetPythonHome;
				_CPythonLibraryInterface_CPy_GetPythonHome = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_GetPythonHome)&>(ptr);
				_CPythonLibraryInterface_CPy_GetPythonHome_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ExecuteModule))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ExecuteModule), W, MTable>::type::_CPythonLibraryInterface_ExecuteModule;
				_CPythonLibraryInterface_ExecuteModule = reinterpret_cast<const decltype(_CPythonLibraryInterface_ExecuteModule)&>(ptr);
				_CPythonLibraryInterface_ExecuteModule_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCallerContext_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCallerContext_New), W, MTable>::type::_CPythonLibraryInterface_CPyCallerContext_New;
				_CPythonLibraryInterface_CPyCallerContext_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCallerContext_New)&>(ptr);
				_CPythonLibraryInterface_CPyCallerContext_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags), W, MTable>::type::_CPythonLibraryInterface_CPyRun_SimpleFileExFlags;
				_CPythonLibraryInterface_CPyRun_SimpleFileExFlags = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyRun_SimpleFileExFlags)&>(ptr);
				_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags), W, MTable>::type::_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1;
				_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1)&>(ptr);
				_CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleStringFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_SimpleStringFlags), W, MTable>::type::_CPythonLibraryInterface_CPyRun_SimpleStringFlags;
				_CPythonLibraryInterface_CPyRun_SimpleStringFlags = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyRun_SimpleStringFlags)&>(ptr);
				_CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_FileExFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_FileExFlags), W, MTable>::type::_CPythonLibraryInterface_CPyRun_FileExFlags;
				_CPythonLibraryInterface_CPyRun_FileExFlags = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyRun_FileExFlags)&>(ptr);
				_CPythonLibraryInterface_CPyRun_FileExFlags_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_InteractiveLoopFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyRun_InteractiveLoopFlags), W, MTable>::type::_CPythonLibraryInterface_CPyRun_InteractiveLoopFlags;
				_CPythonLibraryInterface_CPyRun_InteractiveLoopFlags = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyRun_InteractiveLoopFlags)&>(ptr);
				_CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGilState_Ensure))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGilState_Ensure), W, MTable>::type::_CPythonLibraryInterface_CPyGilState_Ensure;
				_CPythonLibraryInterface_CPyGilState_Ensure = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyGilState_Ensure)&>(ptr);
				_CPythonLibraryInterface_CPyGilState_Ensure_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGilState_Release))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGilState_Release), W, MTable>::type::_CPythonLibraryInterface_CPyGilState_Release;
				_CPythonLibraryInterface_CPyGilState_Release = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyGilState_Release)&>(ptr);
				_CPythonLibraryInterface_CPyGilState_Release_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetGilState))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetGilState), W, MTable>::type::_CPythonLibraryInterface_GetGilState;
				_CPythonLibraryInterface_GetGilState = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetGilState)&>(ptr);
				_CPythonLibraryInterface_GetGilState_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGILState_GetThisThreadState))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGILState_GetThisThreadState), W, MTable>::type::_CPythonLibraryInterface_CPyGILState_GetThisThreadState;
				_CPythonLibraryInterface_CPyGILState_GetThisThreadState = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyGILState_GetThisThreadState)&>(ptr);
				_CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyThreadState_Swap))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyThreadState_Swap), W, MTable>::type::_CPythonLibraryInterface_CPyThreadState_Swap;
				_CPythonLibraryInterface_CPyThreadState_Swap = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyThreadState_Swap)&>(ptr);
				_CPythonLibraryInterface_CPyThreadState_Swap_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyThreadState_GetDict))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyThreadState_GetDict), W, MTable>::type::_CPythonLibraryInterface_CPyThreadState_GetDict;
				_CPythonLibraryInterface_CPyThreadState_GetDict = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyThreadState_GetDict)&>(ptr);
				_CPythonLibraryInterface_CPyThreadState_GetDict_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_CompileStringFlags))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_CompileStringFlags), W, MTable>::type::_CPythonLibraryInterface_CPy_CompileStringFlags;
				_CPythonLibraryInterface_CPy_CompileStringFlags = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_CompileStringFlags)&>(ptr);
				_CPythonLibraryInterface_CPy_CompileStringFlags_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Incref))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Incref), W, MTable>::type::_CPythonLibraryInterface_CPy_Incref;
				_CPythonLibraryInterface_CPy_Incref = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_Incref)&>(ptr);
				_CPythonLibraryInterface_CPy_Incref_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Decref))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Decref), W, MTable>::type::_CPythonLibraryInterface_CPy_Decref;
				_CPythonLibraryInterface_CPy_Decref = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_Decref)&>(ptr);
				_CPythonLibraryInterface_CPy_Decref_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SafeIncref))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SafeIncref), W, MTable>::type::_CPythonLibraryInterface_CPy_SafeIncref;
				_CPythonLibraryInterface_CPy_SafeIncref = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_SafeIncref)&>(ptr);
				_CPythonLibraryInterface_CPy_SafeIncref_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SafeDecref))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_SafeDecref), W, MTable>::type::_CPythonLibraryInterface_CPy_SafeDecref;
				_CPythonLibraryInterface_CPy_SafeDecref = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_SafeDecref)&>(ptr);
				_CPythonLibraryInterface_CPy_SafeDecref_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGC_Collect))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyGC_Collect), W, MTable>::type::_CPythonLibraryInterface_CPyGC_Collect;
				_CPythonLibraryInterface_CPyGC_Collect = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyGC_Collect)&>(ptr);
				_CPythonLibraryInterface_CPyGC_Collect_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCode_Addr2Line))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCode_Addr2Line), W, MTable>::type::_CPythonLibraryInterface_CPyCode_Addr2Line;
				_CPythonLibraryInterface_CPyCode_Addr2Line = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCode_Addr2Line)&>(ptr);
				_CPythonLibraryInterface_CPyCode_Addr2Line_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, UnpackDataType))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, UnpackDataType), W, MTable>::type::_CPythonLibraryInterface_UnpackDataType;
				_CPythonLibraryInterface_UnpackDataType = reinterpret_cast<const decltype(_CPythonLibraryInterface_UnpackDataType)&>(ptr);
				_CPythonLibraryInterface_UnpackDataType_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, UnpackData))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, UnpackData), W, MTable>::type::_CPythonLibraryInterface_UnpackData;
				_CPythonLibraryInterface_UnpackData = reinterpret_cast<const decltype(_CPythonLibraryInterface_UnpackData)&>(ptr);
				_CPythonLibraryInterface_UnpackData_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_None))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_None), W, MTable>::type::_CPythonLibraryInterface_CPy_None;
				_CPythonLibraryInterface_CPy_None = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_None)&>(ptr);
				_CPythonLibraryInterface_CPy_None_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_True))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_True), W, MTable>::type::_CPythonLibraryInterface_CPy_True;
				_CPythonLibraryInterface_CPy_True = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_True)&>(ptr);
				_CPythonLibraryInterface_CPy_True_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_False))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_False), W, MTable>::type::_CPythonLibraryInterface_CPy_False;
				_CPythonLibraryInterface_CPy_False = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_False)&>(ptr);
				_CPythonLibraryInterface_CPy_False_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NotImplemented))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NotImplemented), W, MTable>::type::_CPythonLibraryInterface_CPy_NotImplemented;
				_CPythonLibraryInterface_CPy_NotImplemented = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_NotImplemented)&>(ptr);
				_CPythonLibraryInterface_CPy_NotImplemented_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Print))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Print), W, MTable>::type::_CPythonLibraryInterface_CPyErr_Print;
				_CPythonLibraryInterface_CPyErr_Print = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_Print)&>(ptr);
				_CPythonLibraryInterface_CPyErr_Print_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Clear))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Clear), W, MTable>::type::_CPythonLibraryInterface_CPyErr_Clear;
				_CPythonLibraryInterface_CPyErr_Clear = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_Clear)&>(ptr);
				_CPythonLibraryInterface_CPyErr_Clear_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Occurred))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Occurred), W, MTable>::type::_CPythonLibraryInterface_CPyErr_Occurred;
				_CPythonLibraryInterface_CPyErr_Occurred = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_Occurred)&>(ptr);
				_CPythonLibraryInterface_CPyErr_Occurred_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetString), W, MTable>::type::_CPythonLibraryInterface_CPyErr_SetString;
				_CPythonLibraryInterface_CPyErr_SetString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_SetString)&>(ptr);
				_CPythonLibraryInterface_CPyErr_SetString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrnoAndFilename))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrnoAndFilename), W, MTable>::type::_CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename;
				_CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename)&>(ptr);
				_CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrno))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrno), W, MTable>::type::_CPythonLibraryInterface_CPyErr_SetWithErrno;
				_CPythonLibraryInterface_CPyErr_SetWithErrno = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_SetWithErrno)&>(ptr);
				_CPythonLibraryInterface_CPyErr_SetWithErrno_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetString), W, MTable>::type::_CPythonLibraryInterface_CPyErr_SetString_1;
				_CPythonLibraryInterface_CPyErr_SetString_1 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_SetString_1)&>(ptr);
				_CPythonLibraryInterface_CPyErr_SetString_1_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetNone))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_SetNone), W, MTable>::type::_CPythonLibraryInterface_CPyErr_SetNone;
				_CPythonLibraryInterface_CPyErr_SetNone = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_SetNone)&>(ptr);
				_CPythonLibraryInterface_CPyErr_SetNone_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Fetch))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Fetch), W, MTable>::type::_CPythonLibraryInterface_CPyErr_Fetch;
				_CPythonLibraryInterface_CPyErr_Fetch = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_Fetch)&>(ptr);
				_CPythonLibraryInterface_CPyErr_Fetch_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_NormalizeException))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_NormalizeException), W, MTable>::type::_CPythonLibraryInterface_CPyErr_NormalizeException;
				_CPythonLibraryInterface_CPyErr_NormalizeException = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_NormalizeException)&>(ptr);
				_CPythonLibraryInterface_CPyErr_NormalizeException_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Restore))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_Restore), W, MTable>::type::_CPythonLibraryInterface_CPyErr_Restore;
				_CPythonLibraryInterface_CPyErr_Restore = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_Restore)&>(ptr);
				_CPythonLibraryInterface_CPyErr_Restore_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_ExceptionMatches))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyErr_ExceptionMatches), W, MTable>::type::_CPythonLibraryInterface_CPyErr_ExceptionMatches;
				_CPythonLibraryInterface_CPyErr_ExceptionMatches = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyErr_ExceptionMatches)&>(ptr);
				_CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExceptionClass_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExceptionClass_Check), W, MTable>::type::_CPythonLibraryInterface_CPyExceptionClass_Check;
				_CPythonLibraryInterface_CPyExceptionClass_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExceptionClass_Check)&>(ptr);
				_CPythonLibraryInterface_CPyExceptionClass_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_New), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_New;
				_CPythonLibraryInterface_CPyCapsule_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_New)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_SetPointer))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_SetPointer), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_SetPointer;
				_CPythonLibraryInterface_CPyCapsule_SetPointer = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_SetPointer)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_SetPointer_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_GetPointer))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_GetPointer), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_GetPointer;
				_CPythonLibraryInterface_CPyCapsule_GetPointer = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_GetPointer)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_GetPointer_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_GetContext))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_GetContext), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_GetContext;
				_CPythonLibraryInterface_CPyCapsule_GetContext = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_GetContext)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_GetContext_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_SetContext))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_SetContext), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_SetContext;
				_CPythonLibraryInterface_CPyCapsule_SetContext = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_SetContext)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_SetContext_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_CheckExact))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_CheckExact), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_CheckExact;
				_CPythonLibraryInterface_CPyCapsule_CheckExact = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_CheckExact)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_CheckExact_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTraceBack_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTraceBack_Check), W, MTable>::type::_CPythonLibraryInterface_CPyTraceBack_Check;
				_CPythonLibraryInterface_CPyTraceBack_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTraceBack_Check)&>(ptr);
				_CPythonLibraryInterface_CPyTraceBack_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyClass_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyClass_Check), W, MTable>::type::_CPythonLibraryInterface_CPyClass_Check;
				_CPythonLibraryInterface_CPyClass_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyClass_Check)&>(ptr);
				_CPythonLibraryInterface_CPyClass_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_New), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_New;
				_CPythonLibraryInterface_CPyTuple_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_New)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_Size))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_Size), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_Size;
				_CPythonLibraryInterface_CPyTuple_Size = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_Size)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_Size_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_GetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_GetItem), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_GetItem;
				_CPythonLibraryInterface_CPyTuple_GetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_GetItem)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_GetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_SetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_SetItem), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_SetItem;
				_CPythonLibraryInterface_CPyTuple_SetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_SetItem)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_SetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_GetSlice))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_GetSlice), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_GetSlice;
				_CPythonLibraryInterface_CPyTuple_GetSlice = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_GetSlice)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_GetSlice_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_CheckExact))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_CheckExact), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_CheckExact;
				_CPythonLibraryInterface_CPyTuple_CheckExact = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_CheckExact)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_CheckExact_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_HasAttrString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_HasAttrString), W, MTable>::type::_CPythonLibraryInterface_CPyObject_HasAttrString;
				_CPythonLibraryInterface_CPyObject_HasAttrString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_HasAttrString)&>(ptr);
				_CPythonLibraryInterface_CPyObject_HasAttrString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_SetAttrString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_SetAttrString), W, MTable>::type::_CPythonLibraryInterface_CPyObject_SetAttrString;
				_CPythonLibraryInterface_CPyObject_SetAttrString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_SetAttrString)&>(ptr);
				_CPythonLibraryInterface_CPyObject_SetAttrString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetAttrString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetAttrString), W, MTable>::type::_CPythonLibraryInterface_CPyObject_GetAttrString;
				_CPythonLibraryInterface_CPyObject_GetAttrString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_GetAttrString)&>(ptr);
				_CPythonLibraryInterface_CPyObject_GetAttrString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Call))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Call), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Call;
				_CPythonLibraryInterface_CPyObject_Call = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Call)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Call_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Str))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Str), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Str;
				_CPythonLibraryInterface_CPyObject_Str = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Str)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Str_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Repr))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Repr), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Repr;
				_CPythonLibraryInterface_CPyObject_Repr = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Repr)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Repr_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Dir))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Dir), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Dir;
				_CPythonLibraryInterface_CPyObject_Dir = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Dir)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Dir_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_RichCompare))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_RichCompare), W, MTable>::type::_CPythonLibraryInterface_CPyObject_RichCompare;
				_CPythonLibraryInterface_CPyObject_RichCompare = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_RichCompare)&>(ptr);
				_CPythonLibraryInterface_CPyObject_RichCompare_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Hash))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Hash), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Hash;
				_CPythonLibraryInterface_CPyObject_Hash = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Hash)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Hash_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_IsTrue))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_IsTrue), W, MTable>::type::_CPythonLibraryInterface_CPyObject_IsTrue;
				_CPythonLibraryInterface_CPyObject_IsTrue = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_IsTrue)&>(ptr);
				_CPythonLibraryInterface_CPyObject_IsTrue_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Not))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Not), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Not;
				_CPythonLibraryInterface_CPyObject_Not = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Not)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Not_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCallable_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCallable_Check), W, MTable>::type::_CPythonLibraryInterface_CPyCallable_Check;
				_CPythonLibraryInterface_CPyCallable_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCallable_Check)&>(ptr);
				_CPythonLibraryInterface_CPyCallable_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Length))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Length), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Length;
				_CPythonLibraryInterface_CPyObject_Length = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Length)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Length_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItem), W, MTable>::type::_CPythonLibraryInterface_CPyObject_GetItem;
				_CPythonLibraryInterface_CPyObject_GetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_GetItem)&>(ptr);
				_CPythonLibraryInterface_CPyObject_GetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItemInt))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItemInt), W, MTable>::type::_CPythonLibraryInterface_CPyObject_GetItemInt;
				_CPythonLibraryInterface_CPyObject_GetItemInt = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_GetItemInt)&>(ptr);
				_CPythonLibraryInterface_CPyObject_GetItemInt_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItemString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetItemString), W, MTable>::type::_CPythonLibraryInterface_CPyObject_GetItemString;
				_CPythonLibraryInterface_CPyObject_GetItemString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_GetItemString)&>(ptr);
				_CPythonLibraryInterface_CPyObject_GetItemString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_DelItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_DelItem), W, MTable>::type::_CPythonLibraryInterface_CPyObject_DelItem;
				_CPythonLibraryInterface_CPyObject_DelItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_DelItem)&>(ptr);
				_CPythonLibraryInterface_CPyObject_DelItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_SetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_SetItem), W, MTable>::type::_CPythonLibraryInterface_CPyObject_SetItem;
				_CPythonLibraryInterface_CPyObject_SetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_SetItem)&>(ptr);
				_CPythonLibraryInterface_CPyObject_SetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_TypeCheck))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_TypeCheck), W, MTable>::type::_CPythonLibraryInterface_CPyObject_TypeCheck;
				_CPythonLibraryInterface_CPyObject_TypeCheck = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_TypeCheck)&>(ptr);
				_CPythonLibraryInterface_CPyObject_TypeCheck_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_CallFunction))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_CallFunction), W, MTable>::type::_CPythonLibraryInterface_CPyObject_CallFunction;
				_CPythonLibraryInterface_CPyObject_CallFunction = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_CallFunction)&>(ptr);
				_CPythonLibraryInterface_CPyObject_CallFunction_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_GetObject))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_GetObject), W, MTable>::type::_CPythonLibraryInterface_CPySys_GetObject;
				_CPythonLibraryInterface_CPySys_GetObject = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySys_GetObject)&>(ptr);
				_CPythonLibraryInterface_CPySys_GetObject_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetObject))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetObject), W, MTable>::type::_CPythonLibraryInterface_CPySys_SetObject;
				_CPythonLibraryInterface_CPySys_SetObject = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySys_SetObject)&>(ptr);
				_CPythonLibraryInterface_CPySys_SetObject_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetPath))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetPath), W, MTable>::type::_CPythonLibraryInterface_CPySys_SetPath;
				_CPythonLibraryInterface_CPySys_SetPath = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySys_SetPath)&>(ptr);
				_CPythonLibraryInterface_CPySys_SetPath_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetArgvEx))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_SetArgvEx), W, MTable>::type::_CPythonLibraryInterface_CPySys_SetArgvEx;
				_CPythonLibraryInterface_CPySys_SetArgvEx = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySys_SetArgvEx)&>(ptr);
				_CPythonLibraryInterface_CPySys_SetArgvEx_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_GetPath))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySys_GetPath), W, MTable>::type::_CPythonLibraryInterface_CPySys_GetPath;
				_CPythonLibraryInterface_CPySys_GetPath = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySys_GetPath)&>(ptr);
				_CPythonLibraryInterface_CPySys_GetPath_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySite_AddSiteDir))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySite_AddSiteDir), W, MTable>::type::_CPythonLibraryInterface_CPySite_AddSiteDir;
				_CPythonLibraryInterface_CPySite_AddSiteDir = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySite_AddSiteDir)&>(ptr);
				_CPythonLibraryInterface_CPySite_AddSiteDir_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Check), W, MTable>::type::_CPythonLibraryInterface_CPyString_Check;
				_CPythonLibraryInterface_CPyString_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_Check)&>(ptr);
				_CPythonLibraryInterface_CPyString_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_FromString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_FromString), W, MTable>::type::_CPythonLibraryInterface_CPyString_FromString;
				_CPythonLibraryInterface_CPyString_FromString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_FromString)&>(ptr);
				_CPythonLibraryInterface_CPyString_FromString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_FromStringAndSize))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_FromStringAndSize), W, MTable>::type::_CPythonLibraryInterface_CPyString_FromStringAndSize;
				_CPythonLibraryInterface_CPyString_FromStringAndSize = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_FromStringAndSize)&>(ptr);
				_CPythonLibraryInterface_CPyString_FromStringAndSize_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_AsString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_AsString), W, MTable>::type::_CPythonLibraryInterface_CPyString_AsString;
				_CPythonLibraryInterface_CPyString_AsString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_AsString)&>(ptr);
				_CPythonLibraryInterface_CPyString_AsString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_AsCString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_AsCString), W, MTable>::type::_CPythonLibraryInterface_CPyString_AsCString;
				_CPythonLibraryInterface_CPyString_AsCString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_AsCString)&>(ptr);
				_CPythonLibraryInterface_CPyString_AsCString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Size))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Size), W, MTable>::type::_CPythonLibraryInterface_CPyString_Size;
				_CPythonLibraryInterface_CPyString_Size = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_Size)&>(ptr);
				_CPythonLibraryInterface_CPyString_Size_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetIter))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_GetIter), W, MTable>::type::_CPythonLibraryInterface_CPyObject_GetIter;
				_CPythonLibraryInterface_CPyObject_GetIter = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_GetIter)&>(ptr);
				_CPythonLibraryInterface_CPyObject_GetIter_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyIter_Next))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyIter_Next), W, MTable>::type::_CPythonLibraryInterface_CPyIter_Next;
				_CPythonLibraryInterface_CPyIter_Next = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyIter_Next)&>(ptr);
				_CPythonLibraryInterface_CPyIter_Next_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_New), W, MTable>::type::_CPythonLibraryInterface_CPyDict_New;
				_CPythonLibraryInterface_CPyDict_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_New)&>(ptr);
				_CPythonLibraryInterface_CPyDict_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_GetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_GetItem), W, MTable>::type::_CPythonLibraryInterface_CPyDict_GetItem;
				_CPythonLibraryInterface_CPyDict_GetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_GetItem)&>(ptr);
				_CPythonLibraryInterface_CPyDict_GetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_GetItemString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_GetItemString), W, MTable>::type::_CPythonLibraryInterface_CPyDict_GetItemString;
				_CPythonLibraryInterface_CPyDict_GetItemString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_GetItemString)&>(ptr);
				_CPythonLibraryInterface_CPyDict_GetItemString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_SetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_SetItem), W, MTable>::type::_CPythonLibraryInterface_CPyDict_SetItem;
				_CPythonLibraryInterface_CPyDict_SetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_SetItem)&>(ptr);
				_CPythonLibraryInterface_CPyDict_SetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_DelItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_DelItem), W, MTable>::type::_CPythonLibraryInterface_CPyDict_DelItem;
				_CPythonLibraryInterface_CPyDict_DelItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_DelItem)&>(ptr);
				_CPythonLibraryInterface_CPyDict_DelItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Contains))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Contains), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Contains;
				_CPythonLibraryInterface_CPyDict_Contains = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Contains)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Contains_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Clear))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Clear), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Clear;
				_CPythonLibraryInterface_CPyDict_Clear = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Clear)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Clear_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Next))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Next), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Next;
				_CPythonLibraryInterface_CPyDict_Next = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Next)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Next_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Keys))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Keys), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Keys;
				_CPythonLibraryInterface_CPyDict_Keys = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Keys)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Keys_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Values))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Values), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Values;
				_CPythonLibraryInterface_CPyDict_Values = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Values)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Values_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Items))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Items), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Items;
				_CPythonLibraryInterface_CPyDict_Items = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Items)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Items_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Size))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Size), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Size;
				_CPythonLibraryInterface_CPyDict_Size = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Size)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Size_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Copy))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Copy), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Copy;
				_CPythonLibraryInterface_CPyDict_Copy = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Copy)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Copy_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_SetItemString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_SetItemString), W, MTable>::type::_CPythonLibraryInterface_CPyDict_SetItemString;
				_CPythonLibraryInterface_CPyDict_SetItemString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_SetItemString)&>(ptr);
				_CPythonLibraryInterface_CPyDict_SetItemString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Check), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Check;
				_CPythonLibraryInterface_CPyDict_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Check)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_New), W, MTable>::type::_CPythonLibraryInterface_CPyList_New;
				_CPythonLibraryInterface_CPyList_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_New)&>(ptr);
				_CPythonLibraryInterface_CPyList_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_CheckExact))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_CheckExact), W, MTable>::type::_CPythonLibraryInterface_CPyList_CheckExact;
				_CPythonLibraryInterface_CPyList_CheckExact = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_CheckExact)&>(ptr);
				_CPythonLibraryInterface_CPyList_CheckExact_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Size))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Size), W, MTable>::type::_CPythonLibraryInterface_CPyList_Size;
				_CPythonLibraryInterface_CPyList_Size = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Size)&>(ptr);
				_CPythonLibraryInterface_CPyList_Size_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_GetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_GetItem), W, MTable>::type::_CPythonLibraryInterface_CPyList_GetItem;
				_CPythonLibraryInterface_CPyList_GetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_GetItem)&>(ptr);
				_CPythonLibraryInterface_CPyList_GetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_SetItem))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_SetItem), W, MTable>::type::_CPythonLibraryInterface_CPyList_SetItem;
				_CPythonLibraryInterface_CPyList_SetItem = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_SetItem)&>(ptr);
				_CPythonLibraryInterface_CPyList_SetItem_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Insert))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Insert), W, MTable>::type::_CPythonLibraryInterface_CPyList_Insert;
				_CPythonLibraryInterface_CPyList_Insert = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Insert)&>(ptr);
				_CPythonLibraryInterface_CPyList_Insert_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Append))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Append), W, MTable>::type::_CPythonLibraryInterface_CPyList_Append;
				_CPythonLibraryInterface_CPyList_Append = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Append)&>(ptr);
				_CPythonLibraryInterface_CPyList_Append_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_GetSlice))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_GetSlice), W, MTable>::type::_CPythonLibraryInterface_CPyList_GetSlice;
				_CPythonLibraryInterface_CPyList_GetSlice = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_GetSlice)&>(ptr);
				_CPythonLibraryInterface_CPyList_GetSlice_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_SetSlice))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_SetSlice), W, MTable>::type::_CPythonLibraryInterface_CPyList_SetSlice;
				_CPythonLibraryInterface_CPyList_SetSlice = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_SetSlice)&>(ptr);
				_CPythonLibraryInterface_CPyList_SetSlice_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Sort))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Sort), W, MTable>::type::_CPythonLibraryInterface_CPyList_Sort;
				_CPythonLibraryInterface_CPyList_Sort = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Sort)&>(ptr);
				_CPythonLibraryInterface_CPyList_Sort_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Reverse))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Reverse), W, MTable>::type::_CPythonLibraryInterface_CPyList_Reverse;
				_CPythonLibraryInterface_CPyList_Reverse = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Reverse)&>(ptr);
				_CPythonLibraryInterface_CPyList_Reverse_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_AsTuple))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_AsTuple), W, MTable>::type::_CPythonLibraryInterface_CPyList_AsTuple;
				_CPythonLibraryInterface_CPyList_AsTuple = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_AsTuple)&>(ptr);
				_CPythonLibraryInterface_CPyList_AsTuple_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_DelItemString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_DelItemString), W, MTable>::type::_CPythonLibraryInterface_CPyDict_DelItemString;
				_CPythonLibraryInterface_CPyDict_DelItemString = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_DelItemString)&>(ptr);
				_CPythonLibraryInterface_CPyDict_DelItemString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_Check), W, MTable>::type::_CPythonLibraryInterface_CPyModule_Check;
				_CPythonLibraryInterface_CPyModule_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyModule_Check)&>(ptr);
				_CPythonLibraryInterface_CPyModule_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_AddObject))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_AddObject), W, MTable>::type::_CPythonLibraryInterface_CPyModule_AddObject;
				_CPythonLibraryInterface_CPyModule_AddObject = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyModule_AddObject)&>(ptr);
				_CPythonLibraryInterface_CPyModule_AddObject_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_GetDict))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_GetDict), W, MTable>::type::_CPythonLibraryInterface_CPyModule_GetDict;
				_CPythonLibraryInterface_CPyModule_GetDict = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyModule_GetDict)&>(ptr);
				_CPythonLibraryInterface_CPyModule_GetDict_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_AddIntConstant))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_AddIntConstant), W, MTable>::type::_CPythonLibraryInterface_CPyModule_AddIntConstant;
				_CPythonLibraryInterface_CPyModule_AddIntConstant = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyModule_AddIntConstant)&>(ptr);
				_CPythonLibraryInterface_CPyModule_AddIntConstant_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyImport_ImportModule))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyImport_ImportModule), W, MTable>::type::_CPythonLibraryInterface_CPyImport_ImportModule;
				_CPythonLibraryInterface_CPyImport_ImportModule = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyImport_ImportModule)&>(ptr);
				_CPythonLibraryInterface_CPyImport_ImportModule_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyImport_GetImporter))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyImport_GetImporter), W, MTable>::type::_CPythonLibraryInterface_CPyImport_GetImporter;
				_CPythonLibraryInterface_CPyImport_GetImporter = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyImport_GetImporter)&>(ptr);
				_CPythonLibraryInterface_CPyImport_GetImporter_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Check), W, MTable>::type::_CPythonLibraryInterface_CPyType_Check;
				_CPythonLibraryInterface_CPyType_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_Check)&>(ptr);
				_CPythonLibraryInterface_CPyType_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_IsSubtype))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_IsSubtype), W, MTable>::type::_CPythonLibraryInterface_CPyType_IsSubtype;
				_CPythonLibraryInterface_CPyType_IsSubtype = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_IsSubtype)&>(ptr);
				_CPythonLibraryInterface_CPyType_IsSubtype_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_HasFeature))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_HasFeature), W, MTable>::type::_CPythonLibraryInterface_CPyType_HasFeature;
				_CPythonLibraryInterface_CPyType_HasFeature = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_HasFeature)&>(ptr);
				_CPythonLibraryInterface_CPyType_HasFeature_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_FastSubclass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_FastSubclass), W, MTable>::type::_CPythonLibraryInterface_CPyType_FastSubclass;
				_CPythonLibraryInterface_CPyType_FastSubclass = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_FastSubclass)&>(ptr);
				_CPythonLibraryInterface_CPyType_FastSubclass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_GetName))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_GetName), W, MTable>::type::_CPythonLibraryInterface_CPyType_GetName;
				_CPythonLibraryInterface_CPyType_GetName = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_GetName)&>(ptr);
				_CPythonLibraryInterface_CPyType_GetName_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Ready))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Ready), W, MTable>::type::_CPythonLibraryInterface_CPyType_Ready;
				_CPythonLibraryInterface_CPyType_Ready = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_Ready)&>(ptr);
				_CPythonLibraryInterface_CPyType_Ready_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_SaveThread))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_SaveThread), W, MTable>::type::_CPythonLibraryInterface_CPyEval_SaveThread;
				_CPythonLibraryInterface_CPyEval_SaveThread = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_SaveThread)&>(ptr);
				_CPythonLibraryInterface_CPyEval_SaveThread_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_RestoreThread))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_RestoreThread), W, MTable>::type::_CPythonLibraryInterface_CPyEval_RestoreThread;
				_CPythonLibraryInterface_CPyEval_RestoreThread = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_RestoreThread)&>(ptr);
				_CPythonLibraryInterface_CPyEval_RestoreThread_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ThreadsInitialized))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ThreadsInitialized), W, MTable>::type::_CPythonLibraryInterface_CPyEval_ThreadsInitialized;
				_CPythonLibraryInterface_CPyEval_ThreadsInitialized = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_ThreadsInitialized)&>(ptr);
				_CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_InitThreads))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_InitThreads), W, MTable>::type::_CPythonLibraryInterface_CPyEval_InitThreads;
				_CPythonLibraryInterface_CPyEval_InitThreads = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_InitThreads)&>(ptr);
				_CPythonLibraryInterface_CPyEval_InitThreads_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_AcquireLock))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_AcquireLock), W, MTable>::type::_CPythonLibraryInterface_CPyEval_AcquireLock;
				_CPythonLibraryInterface_CPyEval_AcquireLock = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_AcquireLock)&>(ptr);
				_CPythonLibraryInterface_CPyEval_AcquireLock_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseLock))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseLock), W, MTable>::type::_CPythonLibraryInterface_CPyEval_ReleaseLock;
				_CPythonLibraryInterface_CPyEval_ReleaseLock = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_ReleaseLock)&>(ptr);
				_CPythonLibraryInterface_CPyEval_ReleaseLock_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_AcquireThread))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_AcquireThread), W, MTable>::type::_CPythonLibraryInterface_CPyEval_AcquireThread;
				_CPythonLibraryInterface_CPyEval_AcquireThread = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_AcquireThread)&>(ptr);
				_CPythonLibraryInterface_CPyEval_AcquireThread_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseThread))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseThread), W, MTable>::type::_CPythonLibraryInterface_CPyEval_ReleaseThread;
				_CPythonLibraryInterface_CPyEval_ReleaseThread = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_ReleaseThread)&>(ptr);
				_CPythonLibraryInterface_CPyEval_ReleaseThread_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReInitThreads))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_ReInitThreads), W, MTable>::type::_CPythonLibraryInterface_CPyEval_ReInitThreads;
				_CPythonLibraryInterface_CPyEval_ReInitThreads = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_ReInitThreads)&>(ptr);
				_CPythonLibraryInterface_CPyEval_ReInitThreads_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_GetBuiltins))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_GetBuiltins), W, MTable>::type::_CPythonLibraryInterface_CPyEval_GetBuiltins;
				_CPythonLibraryInterface_CPyEval_GetBuiltins = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_GetBuiltins)&>(ptr);
				_CPythonLibraryInterface_CPyEval_GetBuiltins_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_EvalCode))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyEval_EvalCode), W, MTable>::type::_CPythonLibraryInterface_CPyEval_EvalCode;
				_CPythonLibraryInterface_CPyEval_EvalCode = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyEval_EvalCode)&>(ptr);
				_CPythonLibraryInterface_CPyEval_EvalCode_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_Check), W, MTable>::type::_CPythonLibraryInterface_CPyFloat_Check;
				_CPythonLibraryInterface_CPyFloat_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyFloat_Check)&>(ptr);
				_CPythonLibraryInterface_CPyFloat_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat32))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat32), W, MTable>::type::_CPythonLibraryInterface_CPyFloat_FromFloat32;
				_CPythonLibraryInterface_CPyFloat_FromFloat32 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyFloat_FromFloat32)&>(ptr);
				_CPythonLibraryInterface_CPyFloat_FromFloat32_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat64), W, MTable>::type::_CPythonLibraryInterface_CPyFloat_FromFloat64;
				_CPythonLibraryInterface_CPyFloat_FromFloat64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyFloat_FromFloat64)&>(ptr);
				_CPythonLibraryInterface_CPyFloat_FromFloat64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_AsFloat64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_AsFloat64), W, MTable>::type::_CPythonLibraryInterface_CPyFloat_AsFloat64;
				_CPythonLibraryInterface_CPyFloat_AsFloat64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyFloat_AsFloat64)&>(ptr);
				_CPythonLibraryInterface_CPyFloat_AsFloat64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_Check), W, MTable>::type::_CPythonLibraryInterface_CPyInt_Check;
				_CPythonLibraryInterface_CPyInt_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_Check)&>(ptr);
				_CPythonLibraryInterface_CPyInt_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyBool_FromBool))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyBool_FromBool), W, MTable>::type::_CPythonLibraryInterface_CPyBool_FromBool;
				_CPythonLibraryInterface_CPyBool_FromBool = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyBool_FromBool)&>(ptr);
				_CPythonLibraryInterface_CPyBool_FromBool_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt16))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt16), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromInt16;
				_CPythonLibraryInterface_CPyInt_FromInt16 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromInt16)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromInt16_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt16))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt16), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromUInt16;
				_CPythonLibraryInterface_CPyInt_FromUInt16 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromUInt16)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromUInt16_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt32))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt32), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromInt32;
				_CPythonLibraryInterface_CPyInt_FromInt32 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromInt32)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromInt32_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt32))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt32), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromUInt32;
				_CPythonLibraryInterface_CPyInt_FromUInt32 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromUInt32)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromUInt32_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromInt64), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromInt64;
				_CPythonLibraryInterface_CPyInt_FromInt64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromInt64)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromInt64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_FromUInt64), W, MTable>::type::_CPythonLibraryInterface_CPyInt_FromUInt64;
				_CPythonLibraryInterface_CPyInt_FromUInt64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_FromUInt64)&>(ptr);
				_CPythonLibraryInterface_CPyInt_FromUInt64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt16))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt16), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsInt16;
				_CPythonLibraryInterface_CPyInt_AsInt16 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsInt16)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsInt16_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt16))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt16), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsUInt16;
				_CPythonLibraryInterface_CPyInt_AsUInt16 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsUInt16)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsUInt16_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt32))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt32), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsInt32;
				_CPythonLibraryInterface_CPyInt_AsInt32 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsInt32)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsInt32_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt32))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt32), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsUInt32;
				_CPythonLibraryInterface_CPyInt_AsUInt32 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsUInt32)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsUInt32_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsInt64), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsInt64;
				_CPythonLibraryInterface_CPyInt_AsInt64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsInt64)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsInt64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt64))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_AsUInt64), W, MTable>::type::_CPythonLibraryInterface_CPyInt_AsUInt64;
				_CPythonLibraryInterface_CPyInt_AsUInt64 = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_AsUInt64)&>(ptr);
				_CPythonLibraryInterface_CPyInt_AsUInt64_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyNumber_Check))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyNumber_Check), W, MTable>::type::_CPythonLibraryInterface_CPyNumber_Check;
				_CPythonLibraryInterface_CPyNumber_Check = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyNumber_Check)&>(ptr);
				_CPythonLibraryInterface_CPyNumber_Check_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyFunction_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyFunction_New), W, MTable>::type::_CPythonLibraryInterface_MPyFunction_New;
				_CPythonLibraryInterface_MPyFunction_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyFunction_New)&>(ptr);
				_CPythonLibraryInterface_MPyFunction_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyMember_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyMember_New), W, MTable>::type::_CPythonLibraryInterface_MPyMember_New;
				_CPythonLibraryInterface_MPyMember_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyMember_New)&>(ptr);
				_CPythonLibraryInterface_MPyMember_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyClass_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyClass_New), W, MTable>::type::_CPythonLibraryInterface_MPyClass_New;
				_CPythonLibraryInterface_MPyClass_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyClass_New)&>(ptr);
				_CPythonLibraryInterface_MPyClass_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DebugFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DebugFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_DebugFlag;
				_CPythonLibraryInterface_CPy_DebugFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_DebugFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_DebugFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_VerboseFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_VerboseFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_VerboseFlag;
				_CPythonLibraryInterface_CPy_VerboseFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_VerboseFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_VerboseFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InteractiveFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InteractiveFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_InteractiveFlag;
				_CPythonLibraryInterface_CPy_InteractiveFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_InteractiveFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_InteractiveFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InspectFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_InspectFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_InspectFlag;
				_CPythonLibraryInterface_CPy_InspectFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_InspectFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_InspectFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_OptimizeFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_OptimizeFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_OptimizeFlag;
				_CPythonLibraryInterface_CPy_OptimizeFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_OptimizeFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_OptimizeFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NoSiteFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NoSiteFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_NoSiteFlag;
				_CPythonLibraryInterface_CPy_NoSiteFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_NoSiteFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_NoSiteFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_BytesWarningFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_BytesWarningFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_BytesWarningFlag;
				_CPythonLibraryInterface_CPy_BytesWarningFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_BytesWarningFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_BytesWarningFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_UseClassExceptionsFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_UseClassExceptionsFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_UseClassExceptionsFlag;
				_CPythonLibraryInterface_CPy_UseClassExceptionsFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_UseClassExceptionsFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_UseClassExceptionsFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_FrozenFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_FrozenFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_FrozenFlag;
				_CPythonLibraryInterface_CPy_FrozenFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_FrozenFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_FrozenFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_TabcheckFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_TabcheckFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_TabcheckFlag;
				_CPythonLibraryInterface_CPy_TabcheckFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_TabcheckFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_TabcheckFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_UnicodeFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_UnicodeFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_UnicodeFlag;
				_CPythonLibraryInterface_CPy_UnicodeFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_UnicodeFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_UnicodeFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_IgnoreEnvironmentFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_IgnoreEnvironmentFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag;
				_CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DivisionWarningFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DivisionWarningFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_DivisionWarningFlag;
				_CPythonLibraryInterface_CPy_DivisionWarningFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_DivisionWarningFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_DivisionWarningFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DontWriteBytecodeFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_DontWriteBytecodeFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_DontWriteBytecodeFlag;
				_CPythonLibraryInterface_CPy_DontWriteBytecodeFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_DontWriteBytecodeFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NoUserSiteDirectory))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_NoUserSiteDirectory), W, MTable>::type::_CPythonLibraryInterface_CPy_NoUserSiteDirectory;
				_CPythonLibraryInterface_CPy_NoUserSiteDirectory = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_NoUserSiteDirectory)&>(ptr);
				_CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_QnewFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_QnewFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_QnewFlag;
				_CPythonLibraryInterface_CPy_QnewFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_QnewFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_QnewFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Py3kWarningFlag))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_Py3kWarningFlag), W, MTable>::type::_CPythonLibraryInterface_CPy_Py3kWarningFlag;
				_CPythonLibraryInterface_CPy_Py3kWarningFlag = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_Py3kWarningFlag)&>(ptr);
				_CPythonLibraryInterface_CPy_Py3kWarningFlag_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_CheckInterval))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPy_CheckInterval), W, MTable>::type::_CPythonLibraryInterface_CPy_CheckInterval;
				_CPythonLibraryInterface_CPy_CheckInterval = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPy_CheckInterval)&>(ptr);
				_CPythonLibraryInterface_CPy_CheckInterval_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BaseException))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BaseException), W, MTable>::type::_CPythonLibraryInterface_CPyExc_BaseException;
				_CPythonLibraryInterface_CPyExc_BaseException = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_BaseException)&>(ptr);
				_CPythonLibraryInterface_CPyExc_BaseException_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_Exception))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_Exception), W, MTable>::type::_CPythonLibraryInterface_CPyExc_Exception;
				_CPythonLibraryInterface_CPyExc_Exception = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_Exception)&>(ptr);
				_CPythonLibraryInterface_CPyExc_Exception_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_StopIteration))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_StopIteration), W, MTable>::type::_CPythonLibraryInterface_CPyExc_StopIteration;
				_CPythonLibraryInterface_CPyExc_StopIteration = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_StopIteration)&>(ptr);
				_CPythonLibraryInterface_CPyExc_StopIteration_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_GeneratorExit))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_GeneratorExit), W, MTable>::type::_CPythonLibraryInterface_CPyExc_GeneratorExit;
				_CPythonLibraryInterface_CPyExc_GeneratorExit = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_GeneratorExit)&>(ptr);
				_CPythonLibraryInterface_CPyExc_GeneratorExit_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_StandardError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_StandardError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_StandardError;
				_CPythonLibraryInterface_CPyExc_StandardError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_StandardError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_StandardError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ArithmeticError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ArithmeticError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ArithmeticError;
				_CPythonLibraryInterface_CPyExc_ArithmeticError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ArithmeticError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ArithmeticError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_LookupError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_LookupError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_LookupError;
				_CPythonLibraryInterface_CPyExc_LookupError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_LookupError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_LookupError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_AssertionError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_AssertionError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_AssertionError;
				_CPythonLibraryInterface_CPyExc_AssertionError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_AssertionError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_AssertionError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_AttributeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_AttributeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_AttributeError;
				_CPythonLibraryInterface_CPyExc_AttributeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_AttributeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_AttributeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_EOFError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_EOFError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_EOFError;
				_CPythonLibraryInterface_CPyExc_EOFError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_EOFError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_EOFError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_FloatingPointError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_FloatingPointError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_FloatingPointError;
				_CPythonLibraryInterface_CPyExc_FloatingPointError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_FloatingPointError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_FloatingPointError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_EnvironmentError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_EnvironmentError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_EnvironmentError;
				_CPythonLibraryInterface_CPyExc_EnvironmentError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_EnvironmentError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_EnvironmentError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IOError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IOError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_IOError;
				_CPythonLibraryInterface_CPyExc_IOError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_IOError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_IOError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_OSError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_OSError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_OSError;
				_CPythonLibraryInterface_CPyExc_OSError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_OSError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_OSError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ImportError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ImportError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ImportError;
				_CPythonLibraryInterface_CPyExc_ImportError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ImportError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ImportError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IndexError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IndexError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_IndexError;
				_CPythonLibraryInterface_CPyExc_IndexError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_IndexError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_IndexError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_KeyError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_KeyError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_KeyError;
				_CPythonLibraryInterface_CPyExc_KeyError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_KeyError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_KeyError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_KeyboardInterrupt))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_KeyboardInterrupt), W, MTable>::type::_CPythonLibraryInterface_CPyExc_KeyboardInterrupt;
				_CPythonLibraryInterface_CPyExc_KeyboardInterrupt = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_KeyboardInterrupt)&>(ptr);
				_CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_MemoryError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_MemoryError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_MemoryError;
				_CPythonLibraryInterface_CPyExc_MemoryError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_MemoryError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_MemoryError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_NameError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_NameError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_NameError;
				_CPythonLibraryInterface_CPyExc_NameError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_NameError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_NameError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_OverflowError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_OverflowError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_OverflowError;
				_CPythonLibraryInterface_CPyExc_OverflowError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_OverflowError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_OverflowError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_RuntimeError;
				_CPythonLibraryInterface_CPyExc_RuntimeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_RuntimeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_RuntimeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_NotImplementedError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_NotImplementedError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_NotImplementedError;
				_CPythonLibraryInterface_CPyExc_NotImplementedError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_NotImplementedError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_NotImplementedError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_SyntaxError;
				_CPythonLibraryInterface_CPyExc_SyntaxError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_SyntaxError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_SyntaxError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IndentationError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_IndentationError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_IndentationError;
				_CPythonLibraryInterface_CPyExc_IndentationError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_IndentationError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_IndentationError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_TabError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_TabError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_TabError;
				_CPythonLibraryInterface_CPyExc_TabError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_TabError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_TabError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ReferenceError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ReferenceError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ReferenceError;
				_CPythonLibraryInterface_CPyExc_ReferenceError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ReferenceError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ReferenceError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SystemError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SystemError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_SystemError;
				_CPythonLibraryInterface_CPyExc_SystemError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_SystemError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_SystemError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SystemExit))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SystemExit), W, MTable>::type::_CPythonLibraryInterface_CPyExc_SystemExit;
				_CPythonLibraryInterface_CPyExc_SystemExit = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_SystemExit)&>(ptr);
				_CPythonLibraryInterface_CPyExc_SystemExit_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_TypeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_TypeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_TypeError;
				_CPythonLibraryInterface_CPyExc_TypeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_TypeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_TypeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnboundLocalError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnboundLocalError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnboundLocalError;
				_CPythonLibraryInterface_CPyExc_UnboundLocalError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnboundLocalError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnicodeError;
				_CPythonLibraryInterface_CPyExc_UnicodeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnicodeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnicodeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeEncodeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeEncodeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnicodeEncodeError;
				_CPythonLibraryInterface_CPyExc_UnicodeEncodeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnicodeEncodeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeDecodeError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeDecodeError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnicodeDecodeError;
				_CPythonLibraryInterface_CPyExc_UnicodeDecodeError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnicodeDecodeError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeTranslateError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeTranslateError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnicodeTranslateError;
				_CPythonLibraryInterface_CPyExc_UnicodeTranslateError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnicodeTranslateError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ValueError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ValueError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ValueError;
				_CPythonLibraryInterface_CPyExc_ValueError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ValueError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ValueError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ZeroDivisionError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ZeroDivisionError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ZeroDivisionError;
				_CPythonLibraryInterface_CPyExc_ZeroDivisionError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ZeroDivisionError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_WindowsError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_WindowsError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_WindowsError;
				_CPythonLibraryInterface_CPyExc_WindowsError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_WindowsError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_WindowsError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BufferError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BufferError), W, MTable>::type::_CPythonLibraryInterface_CPyExc_BufferError;
				_CPythonLibraryInterface_CPyExc_BufferError = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_BufferError)&>(ptr);
				_CPythonLibraryInterface_CPyExc_BufferError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_MemoryErrorInst))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_MemoryErrorInst), W, MTable>::type::_CPythonLibraryInterface_CPyExc_MemoryErrorInst;
				_CPythonLibraryInterface_CPyExc_MemoryErrorInst = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_MemoryErrorInst)&>(ptr);
				_CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RecursionErrorInst))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RecursionErrorInst), W, MTable>::type::_CPythonLibraryInterface_CPyExc_RecursionErrorInst;
				_CPythonLibraryInterface_CPyExc_RecursionErrorInst = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_RecursionErrorInst)&>(ptr);
				_CPythonLibraryInterface_CPyExc_RecursionErrorInst_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_Warning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_Warning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_Warning;
				_CPythonLibraryInterface_CPyExc_Warning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_Warning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_Warning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UserWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UserWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UserWarning;
				_CPythonLibraryInterface_CPyExc_UserWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UserWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UserWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_DeprecationWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_DeprecationWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_DeprecationWarning;
				_CPythonLibraryInterface_CPyExc_DeprecationWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_DeprecationWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_PendingDeprecationWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_PendingDeprecationWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_PendingDeprecationWarning;
				_CPythonLibraryInterface_CPyExc_PendingDeprecationWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_PendingDeprecationWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_SyntaxWarning;
				_CPythonLibraryInterface_CPyExc_SyntaxWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_SyntaxWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_RuntimeWarning;
				_CPythonLibraryInterface_CPyExc_RuntimeWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_RuntimeWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_FutureWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_FutureWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_FutureWarning;
				_CPythonLibraryInterface_CPyExc_FutureWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_FutureWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_FutureWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ImportWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_ImportWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_ImportWarning;
				_CPythonLibraryInterface_CPyExc_ImportWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_ImportWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_ImportWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_UnicodeWarning;
				_CPythonLibraryInterface_CPyExc_UnicodeWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_UnicodeWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BytesWarning))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyExc_BytesWarning), W, MTable>::type::_CPythonLibraryInterface_CPyExc_BytesWarning;
				_CPythonLibraryInterface_CPyExc_BytesWarning = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyExc_BytesWarning)&>(ptr);
				_CPythonLibraryInterface_CPyExc_BytesWarning_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyNullImporter_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyNullImporter_Type), W, MTable>::type::_CPythonLibraryInterface_CPyNullImporter_Type;
				_CPythonLibraryInterface_CPyNullImporter_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyNullImporter_Type)&>(ptr);
				_CPythonLibraryInterface_CPyNullImporter_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySuper_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySuper_Type), W, MTable>::type::_CPythonLibraryInterface_CPySuper_Type;
				_CPythonLibraryInterface_CPySuper_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySuper_Type)&>(ptr);
				_CPythonLibraryInterface_CPySuper_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyBool_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyBool_Type), W, MTable>::type::_CPythonLibraryInterface_CPyBool_Type;
				_CPythonLibraryInterface_CPyBool_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyBool_Type)&>(ptr);
				_CPythonLibraryInterface_CPyBool_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_Type), W, MTable>::type::_CPythonLibraryInterface_CPyObject_Type;
				_CPythonLibraryInterface_CPyObject_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_Type)&>(ptr);
				_CPythonLibraryInterface_CPyObject_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyModule_Type), W, MTable>::type::_CPythonLibraryInterface_CPyModule_Type;
				_CPythonLibraryInterface_CPyModule_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyModule_Type)&>(ptr);
				_CPythonLibraryInterface_CPyModule_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyString_Type), W, MTable>::type::_CPythonLibraryInterface_CPyString_Type;
				_CPythonLibraryInterface_CPyString_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyString_Type)&>(ptr);
				_CPythonLibraryInterface_CPyString_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyInt_Type), W, MTable>::type::_CPythonLibraryInterface_CPyInt_Type;
				_CPythonLibraryInterface_CPyInt_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyInt_Type)&>(ptr);
				_CPythonLibraryInterface_CPyInt_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyLong_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyLong_Type), W, MTable>::type::_CPythonLibraryInterface_CPyLong_Type;
				_CPythonLibraryInterface_CPyLong_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyLong_Type)&>(ptr);
				_CPythonLibraryInterface_CPyLong_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyFloat_Type), W, MTable>::type::_CPythonLibraryInterface_CPyFloat_Type;
				_CPythonLibraryInterface_CPyFloat_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyFloat_Type)&>(ptr);
				_CPythonLibraryInterface_CPyFloat_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTuple_Type), W, MTable>::type::_CPythonLibraryInterface_CPyTuple_Type;
				_CPythonLibraryInterface_CPyTuple_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTuple_Type)&>(ptr);
				_CPythonLibraryInterface_CPyTuple_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyList_Type), W, MTable>::type::_CPythonLibraryInterface_CPyList_Type;
				_CPythonLibraryInterface_CPyList_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyList_Type)&>(ptr);
				_CPythonLibraryInterface_CPyList_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyDict_Type), W, MTable>::type::_CPythonLibraryInterface_CPyDict_Type;
				_CPythonLibraryInterface_CPyDict_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyDict_Type)&>(ptr);
				_CPythonLibraryInterface_CPyDict_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyClass_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyClass_Type), W, MTable>::type::_CPythonLibraryInterface_CPyClass_Type;
				_CPythonLibraryInterface_CPyClass_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyClass_Type)&>(ptr);
				_CPythonLibraryInterface_CPyClass_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTraceBack_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyTraceBack_Type), W, MTable>::type::_CPythonLibraryInterface_CPyTraceBack_Type;
				_CPythonLibraryInterface_CPyTraceBack_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyTraceBack_Type)&>(ptr);
				_CPythonLibraryInterface_CPyTraceBack_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySlice_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPySlice_Type), W, MTable>::type::_CPythonLibraryInterface_CPySlice_Type;
				_CPythonLibraryInterface_CPySlice_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPySlice_Type)&>(ptr);
				_CPythonLibraryInterface_CPySlice_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyType_Type), W, MTable>::type::_CPythonLibraryInterface_CPyType_Type;
				_CPythonLibraryInterface_CPyType_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyType_Type)&>(ptr);
				_CPythonLibraryInterface_CPyType_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyMemoryView_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyMemoryView_Type), W, MTable>::type::_CPythonLibraryInterface_CPyMemoryView_Type;
				_CPythonLibraryInterface_CPyMemoryView_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyMemoryView_Type)&>(ptr);
				_CPythonLibraryInterface_CPyMemoryView_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ConvertAndCacheString))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ConvertAndCacheString), W, MTable>::type::_CPythonLibraryInterface_ConvertAndCacheString;
				_CPythonLibraryInterface_ConvertAndCacheString = reinterpret_cast<const decltype(_CPythonLibraryInterface_ConvertAndCacheString)&>(ptr);
				_CPythonLibraryInterface_ConvertAndCacheString_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterSpecificPythonClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterSpecificPythonClass), W, MTable>::type::_CPythonLibraryInterface_RegisterSpecificPythonClass;
				_CPythonLibraryInterface_RegisterSpecificPythonClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_RegisterSpecificPythonClass)&>(ptr);
				_CPythonLibraryInterface_RegisterSpecificPythonClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateRegisterBuiltinConverter))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateRegisterBuiltinConverter), W, MTable>::type::_CPythonLibraryInterface_PrivateRegisterBuiltinConverter;
				_CPythonLibraryInterface_PrivateRegisterBuiltinConverter = reinterpret_cast<const decltype(_CPythonLibraryInterface_PrivateRegisterBuiltinConverter)&>(ptr);
				_CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetSpecialPath))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetSpecialPath), W, MTable>::type::_CPythonLibraryInterface_GetSpecialPath;
				_CPythonLibraryInterface_GetSpecialPath = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetSpecialPath)&>(ptr);
				_CPythonLibraryInterface_GetSpecialPath_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterSpecialPath))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, RegisterSpecialPath), W, MTable>::type::_CPythonLibraryInterface_RegisterSpecialPath;
				_CPythonLibraryInterface_RegisterSpecialPath = reinterpret_cast<const decltype(_CPythonLibraryInterface_RegisterSpecialPath)&>(ptr);
				_CPythonLibraryInterface_RegisterSpecialPath_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataCapsule_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataCapsule_Type), W, MTable>::type::_CPythonLibraryInterface_MPyDataCapsule_Type;
				_CPythonLibraryInterface_MPyDataCapsule_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyDataCapsule_Type)&>(ptr);
				_CPythonLibraryInterface_MPyDataCapsule_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyData_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyData_Type), W, MTable>::type::_CPythonLibraryInterface_CPyData_Type;
				_CPythonLibraryInterface_CPyData_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyData_Type)&>(ptr);
				_CPythonLibraryInterface_CPyData_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_Type))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyCapsule_Type), W, MTable>::type::_CPythonLibraryInterface_CPyCapsule_Type;
				_CPythonLibraryInterface_CPyCapsule_Type = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyCapsule_Type)&>(ptr);
				_CPythonLibraryInterface_CPyCapsule_Type_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateGetCurrentCallerContext))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, PrivateGetCurrentCallerContext), W, MTable>::type::_CPythonLibraryInterface_PrivateGetCurrentCallerContext;
				_CPythonLibraryInterface_PrivateGetCurrentCallerContext = reinterpret_cast<const decltype(_CPythonLibraryInterface_PrivateGetCurrentCallerContext)&>(ptr);
				_CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_ToMapperInstance))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_ToMapperInstance), W, MTable>::type::_CPythonLibraryInterface_MPyDataType_ToMapperInstance;
				_CPythonLibraryInterface_MPyDataType_ToMapperInstance = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyDataType_ToMapperInstance)&>(ptr);
				_CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_ToMapperInstance))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_ToMapperInstance), W, MTable>::type::_CPythonLibraryInterface_MPyData_ToMapperInstance;
				_CPythonLibraryInterface_MPyData_ToMapperInstance = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyData_ToMapperInstance)&>(ptr);
				_CPythonLibraryInterface_MPyData_ToMapperInstance_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_ToMapperInstance))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_ToMapperInstance), W, MTable>::type::_CPythonLibraryInterface_CPyObject_ToMapperInstance;
				_CPythonLibraryInterface_CPyObject_ToMapperInstance = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_ToMapperInstance)&>(ptr);
				_CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, AssociateDataTypeWithPythonTypes))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, AssociateDataTypeWithPythonTypes), W, MTable>::type::_CPythonLibraryInterface_AssociateDataTypeWithPythonTypes;
				_CPythonLibraryInterface_AssociateDataTypeWithPythonTypes = reinterpret_cast<const decltype(_CPythonLibraryInterface_AssociateDataTypeWithPythonTypes)&>(ptr);
				_CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetAssociatedDataType))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetAssociatedDataType), W, MTable>::type::_CPythonLibraryInterface_GetAssociatedDataType;
				_CPythonLibraryInterface_GetAssociatedDataType = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetAssociatedDataType)&>(ptr);
				_CPythonLibraryInterface_GetAssociatedDataType_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetConverterPyObject_FromData))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetConverterPyObject_FromData), W, MTable>::type::_CPythonLibraryInterface_GetConverterPyObject_FromData;
				_CPythonLibraryInterface_GetConverterPyObject_FromData = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetConverterPyObject_FromData)&>(ptr);
				_CPythonLibraryInterface_GetConverterPyObject_FromData_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_New), W, MTable>::type::_CPythonLibraryInterface_MPyData_New;
				_CPythonLibraryInterface_MPyData_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyData_New)&>(ptr);
				_CPythonLibraryInterface_MPyData_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_New), W, MTable>::type::_CPythonLibraryInterface_MPyData_New_1;
				_CPythonLibraryInterface_MPyData_New_1 = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyData_New_1)&>(ptr);
				_CPythonLibraryInterface_MPyData_New_1_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_New))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_New), W, MTable>::type::_CPythonLibraryInterface_MPyDataType_New;
				_CPythonLibraryInterface_MPyDataType_New = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyDataType_New)&>(ptr);
				_CPythonLibraryInterface_MPyDataType_New_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_CheckExact))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_CheckExact), W, MTable>::type::_CPythonLibraryInterface_MPyDataType_CheckExact;
				_CPythonLibraryInterface_MPyDataType_CheckExact = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyDataType_CheckExact)&>(ptr);
				_CPythonLibraryInterface_MPyDataType_CheckExact_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_GetDataType))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyDataType_GetDataType), W, MTable>::type::_CPythonLibraryInterface_MPyDataType_GetDataType;
				_CPythonLibraryInterface_MPyDataType_GetDataType = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyDataType_GetDataType)&>(ptr);
				_CPythonLibraryInterface_MPyDataType_GetDataType_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_CheckExact))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MPyData_CheckExact), W, MTable>::type::_CPythonLibraryInterface_MPyData_CheckExact;
				_CPythonLibraryInterface_MPyData_CheckExact = reinterpret_cast<const decltype(_CPythonLibraryInterface_MPyData_CheckExact)&>(ptr);
				_CPythonLibraryInterface_MPyData_CheckExact_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_AsData))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_AsData), W, MTable>::type::_CPythonLibraryInterface_CPyObject_AsData;
				_CPythonLibraryInterface_CPyObject_AsData = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_AsData)&>(ptr);
				_CPythonLibraryInterface_CPyObject_AsData_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetRegisteredTypesWithConversions))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetRegisteredTypesWithConversions), W, MTable>::type::_CPythonLibraryInterface_GetRegisteredTypesWithConversions;
				_CPythonLibraryInterface_GetRegisteredTypesWithConversions = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetRegisteredTypesWithConversions)&>(ptr);
				_CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ParseDataType))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, ParseDataType), W, MTable>::type::_CPythonLibraryInterface_ParseDataType;
				_CPythonLibraryInterface_ParseDataType = reinterpret_cast<const decltype(_CPythonLibraryInterface_ParseDataType)&>(ptr);
				_CPythonLibraryInterface_ParseDataType_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, SetError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, SetError), W, MTable>::type::_CPythonLibraryInterface_SetError;
				_CPythonLibraryInterface_SetError = reinterpret_cast<const decltype(_CPythonLibraryInterface_SetError)&>(ptr);
				_CPythonLibraryInterface_SetError_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, SetError))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, SetError), W, MTable>::type::_CPythonLibraryInterface_SetError_1;
				_CPythonLibraryInterface_SetError_1 = reinterpret_cast<const decltype(_CPythonLibraryInterface_SetError_1)&>(ptr);
				_CPythonLibraryInterface_SetError_1_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MaxonConvertAuto))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, MaxonConvertAuto), W, MTable>::type::_CPythonLibraryInterface_MaxonConvertAuto;
				_CPythonLibraryInterface_MaxonConvertAuto = reinterpret_cast<const decltype(_CPythonLibraryInterface_MaxonConvertAuto)&>(ptr);
				_CPythonLibraryInterface_MaxonConvertAuto_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_FromGeneric))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CPyObject_FromGeneric), W, MTable>::type::_CPythonLibraryInterface_CPyObject_FromGeneric;
				_CPythonLibraryInterface_CPyObject_FromGeneric = reinterpret_cast<const decltype(_CPythonLibraryInterface_CPyObject_FromGeneric)&>(ptr);
				_CPythonLibraryInterface_CPyObject_FromGeneric_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CreateGlobalDictionary))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, CreateGlobalDictionary), W, MTable>::type::_CPythonLibraryInterface_CreateGlobalDictionary;
				_CPythonLibraryInterface_CreateGlobalDictionary = reinterpret_cast<const decltype(_CPythonLibraryInterface_CreateGlobalDictionary)&>(ptr);
				_CPythonLibraryInterface_CreateGlobalDictionary_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCurrentTraceback))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCurrentTraceback), W, MTable>::type::_CPythonLibraryInterface_GetCurrentTraceback;
				_CPythonLibraryInterface_GetCurrentTraceback = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCurrentTraceback)&>(ptr);
				_CPythonLibraryInterface_GetCurrentTraceback_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyRefClass), W, MTable>::type::_CPythonLibraryInterface_GetCPyRefClass;
				_CPythonLibraryInterface_GetCPyRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCPyRefClass)&>(ptr);
				_CPythonLibraryInterface_GetCPyRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyTypeRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyTypeRefClass), W, MTable>::type::_CPythonLibraryInterface_GetCPyTypeRefClass;
				_CPythonLibraryInterface_GetCPyTypeRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCPyTypeRefClass)&>(ptr);
				_CPythonLibraryInterface_GetCPyTypeRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyFrameRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyFrameRefClass), W, MTable>::type::_CPythonLibraryInterface_GetCPyFrameRefClass;
				_CPythonLibraryInterface_GetCPyFrameRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCPyFrameRefClass)&>(ptr);
				_CPythonLibraryInterface_GetCPyFrameRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyTracebackRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyTracebackRefClass), W, MTable>::type::_CPythonLibraryInterface_GetCPyTracebackRefClass;
				_CPythonLibraryInterface_GetCPyTracebackRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCPyTracebackRefClass)&>(ptr);
				_CPythonLibraryInterface_GetCPyTracebackRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyCodeRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetCPyCodeRefClass), W, MTable>::type::_CPythonLibraryInterface_GetCPyCodeRefClass;
				_CPythonLibraryInterface_GetCPyCodeRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetCPyCodeRefClass)&>(ptr);
				_CPythonLibraryInterface_GetCPyCodeRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyClassRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyClassRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyClassRefClass;
				_CPythonLibraryInterface_GetMPyClassRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyClassRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyClassRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyMemberRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyMemberRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyMemberRefClass;
				_CPythonLibraryInterface_GetMPyMemberRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyMemberRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyMemberRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyFunctionRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyFunctionRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyFunctionRefClass;
				_CPythonLibraryInterface_GetMPyFunctionRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyFunctionRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyFunctionRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyDataTypeRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyDataTypeRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyDataTypeRefClass;
				_CPythonLibraryInterface_GetMPyDataTypeRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyDataTypeRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyDataRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyDataRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyDataRefClass;
				_CPythonLibraryInterface_GetMPyDataRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyDataRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyDataRefClass_Offset = offset;
			}
			if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyCallerContextRefClass))
			{
				auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, CPythonLibraryInterface, GetMPyCallerContextRefClass), W, MTable>::type::_CPythonLibraryInterface_GetMPyCallerContextRefClass;
				_CPythonLibraryInterface_GetMPyCallerContextRefClass = reinterpret_cast<const decltype(_CPythonLibraryInterface_GetMPyCallerContextRefClass)&>(ptr);
				_CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset = offset;
			}
		}
		template <typename W> static maxon::Bool InitWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			if (!W::Implementation::PROXY && (!LibraryInterface::MTable::InitWithBases<W>(info, offset))) return false;
			MTable* vt = (MTable*) maxon::Object::PrivateGetOrCreateMTable(info, _interface); if (!vt) return false;
			vt->Init<W>(offset); return true;
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<CPythonLibraryInterface, LibraryInterface::MTable::CombinedMTable<S>>;
		PRIVATE_MAXON_COMPBASE(CPythonLibraryInterface);
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct CPythonLibraryInterface::StaticMTable
	{
		static StaticMTable _instance;
		static StaticMTable _unresolvedInstance;
		static maxon::Bool InitUnresolved(maxon::NonvirtualInterfaceReference::UnresolvedAssembler assembler, StaticMTable* tbl);
		static const maxon::Char* const _ids;
		static const maxon::NULL_RETURN_TYPE _returnTypes[];
		Result<PYSTARTOPERATION> (*_CPythonLibraryInterface_ParseCommandLine) (BaseArray<String>* args, Data* res, PYTHONFLAG* flags);
		Result<void> (*_CPythonLibraryInterface_GetUrl) (DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome);
		StaticMTable() = default;
		template <typename IMPL> static void Init(StaticMTable* tbl)
		{
			tbl->_CPythonLibraryInterface_ParseCommandLine = &IMPL::_CPythonLibraryInterface_ParseCommandLine;
			tbl->_CPythonLibraryInterface_GetUrl = &IMPL::_CPythonLibraryInterface_GetUrl;
		}
	};
	template <typename S> class CPythonLibraryInterface::Wrapper : public LibraryInterface::Wrapper<S>
	{
	public:
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(AssociateDataTypeWithPythonTypes);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_FromBool);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallable_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallerContext_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetContext);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetPointer);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetContext);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetPointer);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCode_Addr2Line);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyData_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Clear);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Contains);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Copy);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItemString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Items);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Keys);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Next);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItemString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Size);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Values);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Clear);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_ExceptionMatches);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Fetch);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_NormalizeException);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Occurred);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Print);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Restore);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetNone);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrno);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrnoAndFilename);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_AcquireLock);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_AcquireThread);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_EvalCode);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_GetBuiltins);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_InitThreads);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ReInitThreads);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ReleaseLock);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ReleaseThread);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_RestoreThread);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_SaveThread);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ThreadsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ArithmeticError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AssertionError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AttributeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BaseException);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BufferError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BytesWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_DeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EOFError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EnvironmentError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Exception);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FloatingPointError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FutureWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_GeneratorExit);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IOError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndentationError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndexError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyboardInterrupt);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_LookupError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NameError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NotImplementedError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OSError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OverflowError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_PendingDeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RecursionErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ReferenceError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StandardError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StopIteration);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemExit);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TabError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TypeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnboundLocalError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeDecodeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeEncodeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeTranslateError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UserWarning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ValueError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Warning);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_WindowsError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ZeroDivisionError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExceptionClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_AsFloat64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat32);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGC_Collect);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGILState_GetThisThreadState);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Ensure);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Release);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_GetImporter);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_ImportModule);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsInt16);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsInt32);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsInt64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsUInt16);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsUInt32);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_AsUInt64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromInt16);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromInt32);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromInt64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromUInt16);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromUInt32);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_FromUInt64);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyInt_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyIter_Next);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Append);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_AsTuple);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Insert);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Reverse);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetSlice);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Size);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Sort);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyMemoryView_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddIntConstant);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddObject);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNullImporter_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNumber_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_AsData);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Call);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_CallFunction);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Dir);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_FromGeneric);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemInt);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetIter);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_HasAttrString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Hash);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_IsTrue);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Length);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Not);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Repr);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_RichCompare);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Str);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_TypeCheck);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_FileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_InteractiveLoopFlags);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleFileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySite_AddSiteDir);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySlice_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_AsCString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_AsString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_FromString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_FromStringAndSize);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_Size);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyString_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySuper_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetObject);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetPath);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetArgvEx);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetObject);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_Swap);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Size);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Check);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_FastSubclass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_GetName);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_HasFeature);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_IsSubtype);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Ready);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_BytesWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_CheckInterval);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_CompileStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DebugFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Decref);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DivisionWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DontWriteBytecodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_False);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Finalize);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_FrozenFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetBuildInfo);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCompiler);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCopyright);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPlatform);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetVersion);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IgnoreEnvironmentFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Incref);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InitModule);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Initialize);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InspectFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InteractiveFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoSiteFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoUserSiteDirectory);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_None);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NotImplemented);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_OptimizeFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Py3kWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_QnewFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeDecref);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeIncref);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_TabcheckFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_True);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_UnicodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_UseClassExceptionsFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_VerboseFlag);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ConvertAndCacheString);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CreateGlobalDictionary);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ExecuteModule);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(FopenNative);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Free);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetAssociatedDataType);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyCodeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyFrameRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTracebackRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConverterPyObject_FromData);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCurrentTraceback);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetDll);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetGilState);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyCallerContextRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyClassRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyFunctionRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyMemberRefClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetRegisteredTypesWithConversions);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Init);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitBuiltinModules);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitTypes);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(LastPythonCallFailed);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyClass_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_GetDataType);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyFunction_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyMember_New);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MaxonConvertAuto);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ParseDataType);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateCPyRandom_Init);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateGetCurrentCallerContext);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateRegisterBuiltinConverter);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterComponentProxy);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecificPythonClass);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetError);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackData);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackDataType);
		static Result<PYSTARTOPERATION> _CPythonLibraryInterface_ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) { return S::Implementation::ParseCommandLine(args, res, flags); }
		static Result<void> _CPythonLibraryInterface_Init(maxon::GenericComponent* this_, const Url& librarypath, Bool createSubLibrary) { return ((typename S::Implementation*) this_)->Init(librarypath, createSubLibrary); }
		static Result<void> _CPythonLibraryInterface_InitTypes(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->InitTypes(); }
		static Result<void> _CPythonLibraryInterface_InitBuiltinModules(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->InitBuiltinModules(); }
		static void _CPythonLibraryInterface_CPy_Initialize(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_Initialize(); }
		static void _CPythonLibraryInterface_CPy_Finalize(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_Finalize(); }
		static void _CPythonLibraryInterface_PrivateCPyRandom_Init(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->PrivateCPyRandom_Init(); }
		static CPyRef _CPythonLibraryInterface_CPy_InitModule(maxon::GenericComponent* this_, const ModuleDefinition& module) { return ((typename S::Implementation*) this_)->CPy_InitModule(module); }
		static void _CPythonLibraryInterface_Free(maxon::GenericComponent* this_, const Delegate<void()>& shutdownEngine) { return ((typename S::Implementation*) this_)->Free(shutdownEngine); }
		static const PythonDll& _CPythonLibraryInterface_GetDll(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetDll(); }
		static FILE_native* _CPythonLibraryInterface_FopenNative(maxon::GenericComponent* this_, const Char* name, const Char* mode) { return ((typename S::Implementation*) this_)->FopenNative(name, mode); }
		static Error _CPythonLibraryInterface_LastPythonCallFailed(maxon::GenericComponent* this_, const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) { return ((typename S::Implementation*) this_)->LastPythonCallFailed(allocLocation, withTraceback, restoreError); }
		static Result<MPyDataRef> _CPythonLibraryInterface_RegisterComponentProxy(maxon::GenericComponent* this_, const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType* dtOfObject) { return ((typename S::Implementation*) this_)->RegisterComponentProxy(type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject); }
		static Bool _CPythonLibraryInterface_CPy_IsInitialized(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_IsInitialized(); }
		static const Char* _CPythonLibraryInterface_CPy_GetVersion(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetVersion(); }
		static const Char* _CPythonLibraryInterface_CPy_GetPlatform(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetPlatform(); }
		static const Char* _CPythonLibraryInterface_CPy_GetCopyright(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetCopyright(); }
		static const Char* _CPythonLibraryInterface_CPy_GetCompiler(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetCompiler(); }
		static const Char* _CPythonLibraryInterface_CPy_GetBuildInfo(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetBuildInfo(); }
		static Result<void> _CPythonLibraryInterface_CPy_SetProgramName(maxon::GenericComponent* this_, const String& name) { return ((typename S::Implementation*) this_)->CPy_SetProgramName(name); }
		static Result<void> _CPythonLibraryInterface_CPy_SetPythonHome(maxon::GenericComponent* this_, const Url& name) { return ((typename S::Implementation*) this_)->CPy_SetPythonHome(name); }
		static String _CPythonLibraryInterface_CPy_GetProgramName(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetProgramName(); }
		static String _CPythonLibraryInterface_CPy_GetPythonHome(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetPythonHome(); }
		static Bool _CPythonLibraryInterface_ExecuteModule(maxon::GenericComponent* this_, const String& name) { return ((typename S::Implementation*) this_)->ExecuteModule(name); }
		static MPyCallerContextRef _CPythonLibraryInterface_CPyCallerContext_New(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyCallerContext_New(); }
		static Bool _CPythonLibraryInterface_CPyRun_SimpleFileExFlags(maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleFileExFlags(fp, filename, closeit, flags); }
		static Bool _CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(maxon::GenericComponent* this_, const Url& url, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleFileExFlags(url, flags); }
		static CPyRef _CPythonLibraryInterface_CPyRun_SimpleStringFlags(maxon::GenericComponent* this_, const String& code, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleStringFlags(code, flags); }
		static NativePyObject* _CPythonLibraryInterface_CPyRun_FileExFlags(maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_FileExFlags(fp, filename, start, globals, locals, closeit, flags); }
		static Result<void> _CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(maxon::GenericComponent* this_, FILE* fp, const Char* filename, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_InteractiveLoopFlags(fp, filename, flags); }
		static PYGILSTATE _CPythonLibraryInterface_CPyGilState_Ensure(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGilState_Ensure(); }
		static void _CPythonLibraryInterface_CPyGilState_Release(maxon::GenericComponent* this_, PYGILSTATE state) { return ((typename S::Implementation*) this_)->CPyGilState_Release(state); }
		static GILSTATE _CPythonLibraryInterface_GetGilState(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetGilState(); }
		static NativePyThreadState* _CPythonLibraryInterface_CPyGILState_GetThisThreadState(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGILState_GetThisThreadState(); }
		static NativePyThreadState* _CPythonLibraryInterface_CPyThreadState_Swap(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyThreadState_Swap(state); }
		static CPyRef _CPythonLibraryInterface_CPyThreadState_GetDict(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyThreadState_GetDict(); }
		static CPyCodeRef _CPythonLibraryInterface_CPy_CompileStringFlags(maxon::GenericComponent* this_, const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPy_CompileStringFlags(code, filename, start, flags); }
		static void _CPythonLibraryInterface_CPy_Incref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_Incref(o); }
		static void _CPythonLibraryInterface_CPy_Decref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_Decref(o); }
		static void _CPythonLibraryInterface_CPy_SafeIncref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_SafeIncref(o); }
		static void _CPythonLibraryInterface_CPy_SafeDecref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_SafeDecref(o); }
		static Int64 _CPythonLibraryInterface_CPyGC_Collect(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGC_Collect(); }
		static Int32 _CPythonLibraryInterface_CPyCode_Addr2Line(maxon::GenericComponent* this_, const CPyCodeRef& codeObject, Int32 x) { return ((typename S::Implementation*) this_)->CPyCode_Addr2Line(codeObject, x); }
		static CPyRef _CPythonLibraryInterface_UnpackDataType(maxon::GenericComponent* this_, const CPyRef& obj) { return ((typename S::Implementation*) this_)->UnpackDataType(obj); }
		static CPyRef _CPythonLibraryInterface_UnpackData(maxon::GenericComponent* this_, const CPyRef& obj) { return ((typename S::Implementation*) this_)->UnpackData(obj); }
		static CPyConstRef _CPythonLibraryInterface_CPy_None(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_None(); }
		static CPyConstRef _CPythonLibraryInterface_CPy_True(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_True(); }
		static CPyConstRef _CPythonLibraryInterface_CPy_False(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_False(); }
		static CPyConstRef _CPythonLibraryInterface_CPy_NotImplemented(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_NotImplemented(); }
		static void _CPythonLibraryInterface_CPyErr_Print(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyErr_Print(); }
		static void _CPythonLibraryInterface_CPyErr_Clear(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyErr_Clear(); }
		static Bool _CPythonLibraryInterface_CPyErr_Occurred(maxon::GenericComponent* this_, CPyRef* type) { return ((typename S::Implementation*) this_)->CPyErr_Occurred(type); }
		static CPyRef _CPythonLibraryInterface_CPyErr_SetString(maxon::GenericComponent* this_, const CPyRef& errorType, const Char* errorString) { return ((typename S::Implementation*) this_)->CPyErr_SetString(errorType, errorString); }
		static CPyRef _CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber, const Char* filename) { return ((typename S::Implementation*) this_)->CPyErr_SetWithErrnoAndFilename(errorType, errorNumber, filename); }
		static CPyRef _CPythonLibraryInterface_CPyErr_SetWithErrno(maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber) { return ((typename S::Implementation*) this_)->CPyErr_SetWithErrno(errorType, errorNumber); }
		static CPyRef _CPythonLibraryInterface_CPyErr_SetString_1(maxon::GenericComponent* this_, const CPyRef& errorType, const String& errorString) { return ((typename S::Implementation*) this_)->CPyErr_SetString(errorType, errorString); }
		static void _CPythonLibraryInterface_CPyErr_SetNone(maxon::GenericComponent* this_, const CPyRef& errorType) { return ((typename S::Implementation*) this_)->CPyErr_SetNone(errorType); }
		static void _CPythonLibraryInterface_CPyErr_Fetch(maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_Fetch(type, value, traceback); }
		static void _CPythonLibraryInterface_CPyErr_NormalizeException(maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_NormalizeException(type, value, traceback); }
		static void _CPythonLibraryInterface_CPyErr_Restore(maxon::GenericComponent* this_, const CPyRef& type, const CPyRef& value, const CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_Restore(type, value, traceback); }
		static Bool _CPythonLibraryInterface_CPyErr_ExceptionMatches(maxon::GenericComponent* this_, const CPyRef& exc) { return ((typename S::Implementation*) this_)->CPyErr_ExceptionMatches(exc); }
		static Bool _CPythonLibraryInterface_CPyExceptionClass_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyExceptionClass_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyCapsule_New(const maxon::GenericComponent* this_, void* pointer, const Char* name, CPyCapsule_Destructor* destructor) { return ((const typename S::Implementation*) this_)->CPyCapsule_New(pointer, name, destructor); }
		static Bool _CPythonLibraryInterface_CPyCapsule_SetPointer(maxon::GenericComponent* this_, const CPyRef& capsule, void* pointer) { return ((typename S::Implementation*) this_)->CPyCapsule_SetPointer(capsule, pointer); }
		static void* _CPythonLibraryInterface_CPyCapsule_GetPointer(maxon::GenericComponent* this_, const CPyRef& capsule, const Char* name) { return ((typename S::Implementation*) this_)->CPyCapsule_GetPointer(capsule, name); }
		static void* _CPythonLibraryInterface_CPyCapsule_GetContext(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->CPyCapsule_GetContext(capsule); }
		static Bool _CPythonLibraryInterface_CPyCapsule_SetContext(maxon::GenericComponent* this_, const CPyRef& capsule, void* context) { return ((typename S::Implementation*) this_)->CPyCapsule_SetContext(capsule, context); }
		static Bool _CPythonLibraryInterface_CPyCapsule_CheckExact(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyCapsule_CheckExact(o); }
		static Bool _CPythonLibraryInterface_CPyTraceBack_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyTraceBack_Check(o); }
		static Bool _CPythonLibraryInterface_CPyClass_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyClass_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyTuple_New(const maxon::GenericComponent* this_, UInt size) { return ((const typename S::Implementation*) this_)->CPyTuple_New(size); }
		static UInt _CPythonLibraryInterface_CPyTuple_Size(maxon::GenericComponent* this_, const CPyRef& tuple) { return ((typename S::Implementation*) this_)->CPyTuple_Size(tuple); }
		static CPyRef _CPythonLibraryInterface_CPyTuple_GetItem(maxon::GenericComponent* this_, const CPyRef& tuple, UInt index) { return ((typename S::Implementation*) this_)->CPyTuple_GetItem(tuple, index); }
		static Bool _CPythonLibraryInterface_CPyTuple_SetItem(maxon::GenericComponent* this_, const CPyRef& tuple, UInt index, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyTuple_SetItem(tuple, index, item); }
		static CPyRef _CPythonLibraryInterface_CPyTuple_GetSlice(maxon::GenericComponent* this_, const CPyRef& tuple, UInt from, UInt to) { return ((typename S::Implementation*) this_)->CPyTuple_GetSlice(tuple, from, to); }
		static Bool _CPythonLibraryInterface_CPyTuple_CheckExact(maxon::GenericComponent* this_, const CPyRef& tuple) { return ((typename S::Implementation*) this_)->CPyTuple_CheckExact(tuple); }
		static Bool _CPythonLibraryInterface_CPyObject_HasAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* attrName) { return ((typename S::Implementation*) this_)->CPyObject_HasAttrString(o, attrName); }
		static Bool _CPythonLibraryInterface_CPyObject_SetAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* name, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyObject_SetAttrString(o, name, item); }
		static CPyRef _CPythonLibraryInterface_CPyObject_GetAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* name) { return ((typename S::Implementation*) this_)->CPyObject_GetAttrString(o, name); }
		static CPyRef _CPythonLibraryInterface_CPyObject_Call(maxon::GenericComponent* this_, const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) { return ((typename S::Implementation*) this_)->CPyObject_Call(callable_object, tupleArg, kw); }
		static CPyRef _CPythonLibraryInterface_CPyObject_Str(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Str(o); }
		static CPyRef _CPythonLibraryInterface_CPyObject_Repr(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Repr(o); }
		static CPyRef _CPythonLibraryInterface_CPyObject_Dir(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Dir(o); }
		static CPyRef _CPythonLibraryInterface_CPyObject_RichCompare(maxon::GenericComponent* this_, const CPyRef& o1, const CPyRef& o2, Int32 opid) { return ((typename S::Implementation*) this_)->CPyObject_RichCompare(o1, o2, opid); }
		static Int64 _CPythonLibraryInterface_CPyObject_Hash(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Hash(o); }
		static Bool _CPythonLibraryInterface_CPyObject_IsTrue(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_IsTrue(o); }
		static Bool _CPythonLibraryInterface_CPyObject_Not(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Not(o); }
		static Bool _CPythonLibraryInterface_CPyCallable_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyCallable_Check(o); }
		static Int _CPythonLibraryInterface_CPyObject_Length(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Length(o); }
		static CPyRef _CPythonLibraryInterface_CPyObject_GetItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyObject_GetItem(o, key); }
		static CPyRef _CPythonLibraryInterface_CPyObject_GetItemInt(maxon::GenericComponent* this_, const CPyRef& o, Int index) { return ((typename S::Implementation*) this_)->CPyObject_GetItemInt(o, index); }
		static CPyRef _CPythonLibraryInterface_CPyObject_GetItemString(maxon::GenericComponent* this_, const CPyRef& o, const Char* index) { return ((typename S::Implementation*) this_)->CPyObject_GetItemString(o, index); }
		static Bool _CPythonLibraryInterface_CPyObject_DelItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyObject_DelItem(o, key); }
		static Bool _CPythonLibraryInterface_CPyObject_SetItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyObject_SetItem(o, key, item); }
		static Bool _CPythonLibraryInterface_CPyObject_TypeCheck(maxon::GenericComponent* this_, const CPyRef& object, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyObject_TypeCheck(object, type); }
		static CPyRef _CPythonLibraryInterface_CPyObject_CallFunction(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_CallFunction(o); }
		static CPyRef _CPythonLibraryInterface_CPySys_GetObject(maxon::GenericComponent* this_, const Char* name) { return ((typename S::Implementation*) this_)->CPySys_GetObject(name); }
		static Bool _CPythonLibraryInterface_CPySys_SetObject(maxon::GenericComponent* this_, const Char* name, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPySys_SetObject(name, o); }
		static Result<void> _CPythonLibraryInterface_CPySys_SetPath(maxon::GenericComponent* this_, const BaseArray<Url>& paths, PATHHANDLE add) { return ((typename S::Implementation*) this_)->CPySys_SetPath(paths, add); }
		static Result<void> _CPythonLibraryInterface_CPySys_SetArgvEx(maxon::GenericComponent* this_, const BaseArray<String>& args, Bool updatepath) { return ((typename S::Implementation*) this_)->CPySys_SetArgvEx(args, updatepath); }
		static BaseArray<Url> _CPythonLibraryInterface_CPySys_GetPath(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySys_GetPath(); }
		static Result<void> _CPythonLibraryInterface_CPySite_AddSiteDir(maxon::GenericComponent* this_, const Url& siteDir) { return ((typename S::Implementation*) this_)->CPySite_AddSiteDir(siteDir); }
		static Bool _CPythonLibraryInterface_CPyString_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyString_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyString_FromString(const maxon::GenericComponent* this_, const Char* str) { return ((const typename S::Implementation*) this_)->CPyString_FromString(str); }
		static CPyRef _CPythonLibraryInterface_CPyString_FromStringAndSize(maxon::GenericComponent* this_, const Block<const Char>& block) { return ((typename S::Implementation*) this_)->CPyString_FromStringAndSize(block); }
		static Result<String> _CPythonLibraryInterface_CPyString_AsString(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyString_AsString(str); }
		static const Char* _CPythonLibraryInterface_CPyString_AsCString(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyString_AsCString(str); }
		static Int _CPythonLibraryInterface_CPyString_Size(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyString_Size(str); }
		static CPyRef _CPythonLibraryInterface_CPyObject_GetIter(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->CPyObject_GetIter(o); }
		static CPyRef _CPythonLibraryInterface_CPyIter_Next(const maxon::GenericComponent* this_, const CPyRef& it) { return ((const typename S::Implementation*) this_)->CPyIter_Next(it); }
		static CPyRef _CPythonLibraryInterface_CPyDict_New(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPyDict_New(); }
		static CPyRef _CPythonLibraryInterface_CPyDict_GetItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) { return ((typename S::Implementation*) this_)->CPyDict_GetItem(dict, key, raiseKeyError); }
		static CPyRef _CPythonLibraryInterface_CPyDict_GetItemString(maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, Bool raiseKeyError) { return ((typename S::Implementation*) this_)->CPyDict_GetItemString(dict, key, raiseKeyError); }
		static Bool _CPythonLibraryInterface_CPyDict_SetItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyDict_SetItem(dict, key, item); }
		static Bool _CPythonLibraryInterface_CPyDict_DelItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyDict_DelItem(dict, key); }
		static CONTAINS _CPythonLibraryInterface_CPyDict_Contains(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyDict_Contains(dict, key); }
		static void _CPythonLibraryInterface_CPyDict_Clear(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Clear(dict); }
		static Bool _CPythonLibraryInterface_CPyDict_Next(maxon::GenericComponent* this_, const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) { return ((typename S::Implementation*) this_)->CPyDict_Next(dict, pos, key, value); }
		static CPyRef _CPythonLibraryInterface_CPyDict_Keys(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Keys(dict); }
		static CPyRef _CPythonLibraryInterface_CPyDict_Values(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Values(dict); }
		static CPyRef _CPythonLibraryInterface_CPyDict_Items(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Items(dict); }
		static Int _CPythonLibraryInterface_CPyDict_Size(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Size(dict); }
		static CPyRef _CPythonLibraryInterface_CPyDict_Copy(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Copy(dict); }
		static Bool _CPythonLibraryInterface_CPyDict_SetItemString(const maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, const CPyRef& item) { return ((const typename S::Implementation*) this_)->CPyDict_SetItemString(dict, key, item); }
		static Bool _CPythonLibraryInterface_CPyDict_Check(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->CPyDict_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyList_New(maxon::GenericComponent* this_, UInt size) { return ((typename S::Implementation*) this_)->CPyList_New(size); }
		static Bool _CPythonLibraryInterface_CPyList_CheckExact(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_CheckExact(list); }
		static Int _CPythonLibraryInterface_CPyList_Size(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Size(list); }
		static CPyRef _CPythonLibraryInterface_CPyList_GetItem(maxon::GenericComponent* this_, const CPyRef& list, UInt index) { return ((typename S::Implementation*) this_)->CPyList_GetItem(list, index); }
		static Bool _CPythonLibraryInterface_CPyList_SetItem(maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_SetItem(list, anonymous_param_2, item); }
		static Bool _CPythonLibraryInterface_CPyList_Insert(maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_Insert(list, anonymous_param_2, item); }
		static Bool _CPythonLibraryInterface_CPyList_Append(maxon::GenericComponent* this_, const CPyRef& list, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_Append(list, item); }
		static CPyRef _CPythonLibraryInterface_CPyList_GetSlice(maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to) { return ((typename S::Implementation*) this_)->CPyList_GetSlice(list, from, to); }
		static Bool _CPythonLibraryInterface_CPyList_SetSlice(maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_SetSlice(list, from, to, item); }
		static Bool _CPythonLibraryInterface_CPyList_Sort(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Sort(list); }
		static Bool _CPythonLibraryInterface_CPyList_Reverse(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Reverse(list); }
		static CPyRef _CPythonLibraryInterface_CPyList_AsTuple(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_AsTuple(list); }
		static Bool _CPythonLibraryInterface_CPyDict_DelItemString(maxon::GenericComponent* this_, const CPyRef& p, const Char* key) { return ((typename S::Implementation*) this_)->CPyDict_DelItemString(p, key); }
		static Bool _CPythonLibraryInterface_CPyModule_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyModule_Check(o); }
		static Bool _CPythonLibraryInterface_CPyModule_AddObject(maxon::GenericComponent* this_, const CPyRef& module, const Char* name, const CPyRef& value) { return ((typename S::Implementation*) this_)->CPyModule_AddObject(module, name, value); }
		static CPyRef _CPythonLibraryInterface_CPyModule_GetDict(maxon::GenericComponent* this_, const CPyRef& module) { return ((typename S::Implementation*) this_)->CPyModule_GetDict(module); }
		static Bool _CPythonLibraryInterface_CPyModule_AddIntConstant(maxon::GenericComponent* this_, const CPyRef& mod, const Char* name, long value) { return ((typename S::Implementation*) this_)->CPyModule_AddIntConstant(mod, name, value); }
		static CPyRef _CPythonLibraryInterface_CPyImport_ImportModule(maxon::GenericComponent* this_, const Char* name) { return ((typename S::Implementation*) this_)->CPyImport_ImportModule(name); }
		static CPyRef _CPythonLibraryInterface_CPyImport_GetImporter(maxon::GenericComponent* this_, const CPyRef& path) { return ((typename S::Implementation*) this_)->CPyImport_GetImporter(path); }
		static Bool _CPythonLibraryInterface_CPyType_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyType_Check(o); }
		static Bool _CPythonLibraryInterface_CPyType_IsSubtype(maxon::GenericComponent* this_, const CPyTypeRef& a, const CPyTypeRef& b) { return ((typename S::Implementation*) this_)->CPyType_IsSubtype(a, b); }
		static Bool _CPythonLibraryInterface_CPyType_HasFeature(const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) this_)->CPyType_HasFeature(type, f); }
		static Bool _CPythonLibraryInterface_CPyType_FastSubclass(const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) this_)->CPyType_FastSubclass(type, f); }
		static Result<String> _CPythonLibraryInterface_CPyType_GetName(maxon::GenericComponent* this_, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyType_GetName(type); }
		static Bool _CPythonLibraryInterface_CPyType_Ready(maxon::GenericComponent* this_, CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyType_Ready(type); }
		static NativePyThreadState* _CPythonLibraryInterface_CPyEval_SaveThread(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_SaveThread(); }
		static void _CPythonLibraryInterface_CPyEval_RestoreThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_RestoreThread(state); }
		static Bool _CPythonLibraryInterface_CPyEval_ThreadsInitialized(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_ThreadsInitialized(); }
		static void _CPythonLibraryInterface_CPyEval_InitThreads(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_InitThreads(); }
		static void _CPythonLibraryInterface_CPyEval_AcquireLock(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_AcquireLock(); }
		static void _CPythonLibraryInterface_CPyEval_ReleaseLock(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_ReleaseLock(); }
		static void _CPythonLibraryInterface_CPyEval_AcquireThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_AcquireThread(state); }
		static void _CPythonLibraryInterface_CPyEval_ReleaseThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_ReleaseThread(state); }
		static void _CPythonLibraryInterface_CPyEval_ReInitThreads(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_ReInitThreads(); }
		static CPyRef _CPythonLibraryInterface_CPyEval_GetBuiltins(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPyEval_GetBuiltins(); }
		static CPyRef _CPythonLibraryInterface_CPyEval_EvalCode(const maxon::GenericComponent* this_, const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) { return ((const typename S::Implementation*) this_)->CPyEval_EvalCode(code, globals, locals); }
		static Bool _CPythonLibraryInterface_CPyFloat_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyFloat_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyFloat_FromFloat32(maxon::GenericComponent* this_, Float32 value) { return ((typename S::Implementation*) this_)->CPyFloat_FromFloat32(value); }
		static CPyRef _CPythonLibraryInterface_CPyFloat_FromFloat64(maxon::GenericComponent* this_, Float64 value) { return ((typename S::Implementation*) this_)->CPyFloat_FromFloat64(value); }
		static Float64 _CPythonLibraryInterface_CPyFloat_AsFloat64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyFloat_AsFloat64(o); }
		static Bool _CPythonLibraryInterface_CPyInt_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_Check(o); }
		static CPyRef _CPythonLibraryInterface_CPyBool_FromBool(maxon::GenericComponent* this_, Bool value) { return ((typename S::Implementation*) this_)->CPyBool_FromBool(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromInt16(maxon::GenericComponent* this_, Int16 value) { return ((typename S::Implementation*) this_)->CPyInt_FromInt16(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromUInt16(maxon::GenericComponent* this_, UInt16 value) { return ((typename S::Implementation*) this_)->CPyInt_FromUInt16(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromInt32(maxon::GenericComponent* this_, Int32 value) { return ((typename S::Implementation*) this_)->CPyInt_FromInt32(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromUInt32(maxon::GenericComponent* this_, UInt32 value) { return ((typename S::Implementation*) this_)->CPyInt_FromUInt32(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromInt64(maxon::GenericComponent* this_, Int64 value) { return ((typename S::Implementation*) this_)->CPyInt_FromInt64(value); }
		static CPyRef _CPythonLibraryInterface_CPyInt_FromUInt64(maxon::GenericComponent* this_, UInt64 value) { return ((typename S::Implementation*) this_)->CPyInt_FromUInt64(value); }
		static Int16 _CPythonLibraryInterface_CPyInt_AsInt16(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsInt16(o); }
		static UInt16 _CPythonLibraryInterface_CPyInt_AsUInt16(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsUInt16(o); }
		static Int32 _CPythonLibraryInterface_CPyInt_AsInt32(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsInt32(o); }
		static UInt32 _CPythonLibraryInterface_CPyInt_AsUInt32(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsUInt32(o); }
		static Int64 _CPythonLibraryInterface_CPyInt_AsInt64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsInt64(o); }
		static UInt64 _CPythonLibraryInterface_CPyInt_AsUInt64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyInt_AsUInt64(o); }
		static Bool _CPythonLibraryInterface_CPyNumber_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyNumber_Check(o); }
		static MPyFunctionRef _CPythonLibraryInterface_MPyFunction_New(maxon::GenericComponent* this_, const reflection::Function* func) { return ((typename S::Implementation*) this_)->MPyFunction_New(func); }
		static MPyMemberRef _CPythonLibraryInterface_MPyMember_New(maxon::GenericComponent* this_, const reflection::Member* member) { return ((typename S::Implementation*) this_)->MPyMember_New(member); }
		static MPyClassRef _CPythonLibraryInterface_MPyClass_New(maxon::GenericComponent* this_, const reflection::Class* cls) { return ((typename S::Implementation*) this_)->MPyClass_New(cls); }
		static Int32* _CPythonLibraryInterface_CPy_DebugFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_DebugFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_VerboseFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_VerboseFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_InteractiveFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_InteractiveFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_InspectFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_InspectFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_OptimizeFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_OptimizeFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_NoSiteFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_NoSiteFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_BytesWarningFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_BytesWarningFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_UseClassExceptionsFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_UseClassExceptionsFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_FrozenFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_FrozenFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_TabcheckFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_TabcheckFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_UnicodeFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_UnicodeFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_IgnoreEnvironmentFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_DivisionWarningFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_DivisionWarningFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_DontWriteBytecodeFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_NoUserSiteDirectory(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_NoUserSiteDirectory(); }
		static Int32* _CPythonLibraryInterface_CPy_QnewFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_QnewFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_Py3kWarningFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_Py3kWarningFlag(); }
		static Int32* _CPythonLibraryInterface_CPy_CheckInterval(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_CheckInterval(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_BaseException(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BaseException(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_Exception(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_Exception(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_StopIteration(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_StopIteration(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_GeneratorExit(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_GeneratorExit(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_StandardError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_StandardError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ArithmeticError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ArithmeticError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_LookupError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_LookupError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_AssertionError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_AssertionError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_AttributeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_AttributeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_EOFError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_EOFError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_FloatingPointError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_FloatingPointError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_EnvironmentError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_EnvironmentError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_IOError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IOError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_OSError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_OSError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ImportError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ImportError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_IndexError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IndexError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_KeyError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_KeyError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_KeyboardInterrupt(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_KeyboardInterrupt(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_MemoryError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_MemoryError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_NameError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_NameError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_OverflowError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_OverflowError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_RuntimeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_RuntimeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_NotImplementedError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_NotImplementedError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_SyntaxError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SyntaxError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_IndentationError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IndentationError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_TabError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_TabError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ReferenceError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ReferenceError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_SystemError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SystemError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_SystemExit(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SystemExit(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_TypeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_TypeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnboundLocalError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnboundLocalError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnicodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnicodeEncodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeEncodeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnicodeDecodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeDecodeError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnicodeTranslateError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeTranslateError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ValueError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ValueError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ZeroDivisionError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ZeroDivisionError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_WindowsError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_WindowsError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_BufferError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BufferError(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_MemoryErrorInst(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_MemoryErrorInst(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_RecursionErrorInst(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_RecursionErrorInst(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_Warning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_Warning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UserWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UserWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_DeprecationWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_DeprecationWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_PendingDeprecationWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_SyntaxWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SyntaxWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_RuntimeWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_RuntimeWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_FutureWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_FutureWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_ImportWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ImportWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_UnicodeWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeWarning(); }
		static CPyConstRef _CPythonLibraryInterface_CPyExc_BytesWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BytesWarning(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyNullImporter_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyNullImporter_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPySuper_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySuper_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyBool_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyBool_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyObject_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyObject_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyModule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyModule_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyString_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyString_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyInt_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyInt_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyLong_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyLong_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyFloat_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyFloat_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyTuple_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyTuple_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyList_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyList_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyDict_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyDict_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyClass_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyClass_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyTraceBack_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyTraceBack_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPySlice_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySlice_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyType_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyType_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyMemoryView_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyMemoryView_Type(); }
		static const PyChar* _CPythonLibraryInterface_ConvertAndCacheString(maxon::GenericComponent* this_, const String& str, const StringEncodingRef& encoding) { return ((typename S::Implementation*) this_)->ConvertAndCacheString(str, encoding); }
		static Result<void> _CPythonLibraryInterface_RegisterSpecificPythonClass(maxon::GenericComponent* this_, const Id& typeId, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->RegisterSpecificPythonClass(typeId, type); }
		static Result<void> _CPythonLibraryInterface_PrivateRegisterBuiltinConverter(maxon::GenericComponent* this_, const DataType* dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) { return ((typename S::Implementation*) this_)->PrivateRegisterBuiltinConverter(dt, f1, f2); }
		static Result<void> _CPythonLibraryInterface_GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) { return S::Implementation::GetUrl(pythonPath, pythonLibrary, pythonHome); }
		static Url _CPythonLibraryInterface_GetSpecialPath(maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1) { return ((typename S::Implementation*) this_)->GetSpecialPath(anonymous_param_1); }
		static void _CPythonLibraryInterface_RegisterSpecialPath(maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1, const Url& path) { return ((typename S::Implementation*) this_)->RegisterSpecialPath(anonymous_param_1, path); }
		static CPyTypeConstRef _CPythonLibraryInterface_MPyDataCapsule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->MPyDataCapsule_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyData_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyData_Type(); }
		static CPyTypeConstRef _CPythonLibraryInterface_CPyCapsule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyCapsule_Type(); }
		static CPyRef _CPythonLibraryInterface_PrivateGetCurrentCallerContext(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->PrivateGetCurrentCallerContext(); }
		static CPyRef _CPythonLibraryInterface_MPyDataType_ToMapperInstance(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->MPyDataType_ToMapperInstance(capsule); }
		static CPyRef _CPythonLibraryInterface_MPyData_ToMapperInstance(maxon::GenericComponent* this_, const MPyDataRef& capsule) { return ((typename S::Implementation*) this_)->MPyData_ToMapperInstance(capsule); }
		static CPyRef _CPythonLibraryInterface_CPyObject_ToMapperInstance(maxon::GenericComponent* this_, const DataType* dt, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->CPyObject_ToMapperInstance(dt, capsule); }
		static Result<void> _CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(maxon::GenericComponent* this_, const DataType* dt, const CPyRef& type) { return ((typename S::Implementation*) this_)->AssociateDataTypeWithPythonTypes(dt, type); }
		static Result<CPyRef> _CPythonLibraryInterface_GetAssociatedDataType(maxon::GenericComponent* this_, const DataType* dt) { return ((typename S::Implementation*) this_)->GetAssociatedDataType(dt); }
		static DelegatePyObject_FromData<>* _CPythonLibraryInterface_GetConverterPyObject_FromData(maxon::GenericComponent* this_, const DataType* dt) { return ((typename S::Implementation*) this_)->GetConverterPyObject_FromData(dt); }
		static MPyDataRef _CPythonLibraryInterface_MPyData_New(maxon::GenericComponent* this_, Data& data) { return ((typename S::Implementation*) this_)->MPyData_New(data); }
		static MPyDataRef _CPythonLibraryInterface_MPyData_New_1(maxon::GenericComponent* this_, const DataType* dt, Generic* data, Bool owner, const DataType* mapDt) { return ((typename S::Implementation*) this_)->MPyData_New(dt, data, owner, mapDt); }
		static MPyDataTypeRef _CPythonLibraryInterface_MPyDataType_New(maxon::GenericComponent* this_, const DataType* dt) { return ((typename S::Implementation*) this_)->MPyDataType_New(dt); }
		static Bool _CPythonLibraryInterface_MPyDataType_CheckExact(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->MPyDataType_CheckExact(o); }
		static const DataType* _CPythonLibraryInterface_MPyDataType_GetDataType(const maxon::GenericComponent* this_, const MPyDataTypeRef& o) { return ((const typename S::Implementation*) this_)->MPyDataType_GetDataType(o); }
		static Bool _CPythonLibraryInterface_MPyData_CheckExact(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->MPyData_CheckExact(o); }
		static Result<Data*> _CPythonLibraryInterface_CPyObject_AsData(maxon::GenericComponent* this_, Int stackDepth, const CPyRef& obj, const DataType* expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) { return ((typename S::Implementation*) this_)->CPyObject_AsData(stackDepth, obj, expected, k, n); }
		static Result<BaseArray<TYPE_CONVERSION_TUPLE>> _CPythonLibraryInterface_GetRegisteredTypesWithConversions(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->GetRegisteredTypesWithConversions(); }
		static Result<const DataType*> _CPythonLibraryInterface_ParseDataType(maxon::GenericComponent* this_, const CPyRef& args, Int32 argIndex, Bool canBeNone) { return ((typename S::Implementation*) this_)->ParseDataType(args, argIndex, canBeNone); }
		static void _CPythonLibraryInterface_SetError(maxon::GenericComponent* this_, const Error& err) { return ((typename S::Implementation*) this_)->SetError(err); }
		static void _CPythonLibraryInterface_SetError_1(maxon::GenericComponent* this_, const ErrorPtr& err) { return ((typename S::Implementation*) this_)->SetError(err); }
		static CPyRef _CPythonLibraryInterface_MaxonConvertAuto(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->MaxonConvertAuto(capsule); }
		static CPyRef _CPythonLibraryInterface_CPyObject_FromGeneric(maxon::GenericComponent* this_, const DataType* origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) { return ((typename S::Implementation*) this_)->CPyObject_FromGeneric(origDt, object, ownership, expected, count); }
		static CPyRef _CPythonLibraryInterface_CreateGlobalDictionary(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CreateGlobalDictionary(); }
		static Result<BaseArray<SourceLocation>> _CPythonLibraryInterface_GetCurrentTraceback(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->GetCurrentTraceback(); }
		static Class<CPyRef> _CPythonLibraryInterface_GetCPyRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyRefClass(); }
		static Class<CPyTypeRef> _CPythonLibraryInterface_GetCPyTypeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyTypeRefClass(); }
		static Class<CPyFrameRef> _CPythonLibraryInterface_GetCPyFrameRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyFrameRefClass(); }
		static Class<CPyTracebackRef> _CPythonLibraryInterface_GetCPyTracebackRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyTracebackRefClass(); }
		static Class<CPyCodeRef> _CPythonLibraryInterface_GetCPyCodeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyCodeRefClass(); }
		static Class<MPyClassRef> _CPythonLibraryInterface_GetMPyClassRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyClassRefClass(); }
		static Class<MPyMemberRef> _CPythonLibraryInterface_GetMPyMemberRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyMemberRefClass(); }
		static Class<MPyFunctionRef> _CPythonLibraryInterface_GetMPyFunctionRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyFunctionRefClass(); }
		static Class<MPyDataTypeRef> _CPythonLibraryInterface_GetMPyDataTypeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyDataTypeRefClass(); }
		static Class<MPyDataRef> _CPythonLibraryInterface_GetMPyDataRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyDataRefClass(); }
		static Class<MPyCallerContextRef> _CPythonLibraryInterface_GetMPyCallerContextRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyCallerContextRefClass(); }
	};

	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION>
	{
		return StaticMTable::_instance._CPythonLibraryInterface_ParseCommandLine(args, res, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_Init((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitTypes() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_InitTypes((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_InitTypes_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitBuiltinModules() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_InitBuiltinModules((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_InitBuiltinModules_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Initialize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_Initialize((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_Initialize_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Finalize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_Finalize((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_Finalize_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateCPyRandom_Init() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_PrivateCPyRandom_Init((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_PrivateCPyRandom_Init_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InitModule(const ModuleDefinition& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_InitModule((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_InitModule_Offset, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Free(const Delegate<void()>& shutdownEngine) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_Free((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_Free_Offset, shutdownEngine);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetDll() const -> const PythonDll&
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetDll((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetDll_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::FopenNative(const Char* name, const Char* mode) -> FILE_native*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_FopenNative((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_FopenNative_Offset, name, mode);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> Error
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_LastPythonCallFailed((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType* dtOfObject) -> Result<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_RegisterComponentProxy((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_IsInitialized((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_IsInitialized_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetVersion() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetVersion((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetVersion_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPlatform() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetPlatform((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetPlatform_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCopyright() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetCopyright((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetCopyright_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCompiler() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetCompiler((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetCompiler_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetBuildInfo() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetBuildInfo((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetBuildInfo_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetProgramName(const String& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_SetProgramName((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_SetProgramName_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_SetPythonHome((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_SetPythonHome_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetProgramName() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetProgramName((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetProgramName_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPythonHome() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_GetPythonHome((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_GetPythonHome_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ExecuteModule(const String& name) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_ExecuteModule((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_ExecuteModule_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallerContext_New() -> MPyCallerContextRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCallerContext_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCallerContext_New_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> NativePyObject*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyRun_FileExFlags((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Ensure() -> PYGILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyGilState_Ensure((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyGilState_Ensure_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Release(PYGILSTATE state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyGilState_Release((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyGilState_Release_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetGilState() const -> GILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetGilState((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetGilState_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGILState_GetThisThreadState() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_Swap(NativePyThreadState* state) -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyThreadState_Swap((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyThreadState_Swap_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_GetDict() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyThreadState_GetDict((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyThreadState_GetDict_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> CPyCodeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_CompileStringFlags((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Incref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_Incref((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_Incref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Decref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_Decref((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_Decref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeIncref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_SafeIncref((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_SafeIncref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeDecref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_SafeDecref((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_SafeDecref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGC_Collect() -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyGC_Collect((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyGC_Collect_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCode_Addr2Line((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackDataType(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_UnpackDataType((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_UnpackDataType_Offset, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackData(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_UnpackData((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_UnpackData_Offset, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_None() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_None((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_None_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_True() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_True((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_True_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_False() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_False((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_False_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NotImplemented() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_NotImplemented((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_NotImplemented_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Print() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_Print((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_Print_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Clear() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_Clear((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_Clear_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Occurred(CPyRef* type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_Occurred((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_Occurred_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_SetString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_SetWithErrno((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_SetString_1((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetNone(const CPyRef& errorType) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_SetNone((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_Fetch((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_NormalizeException((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_Restore((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_ExceptionMatches(const CPyRef& exc) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExceptionClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExceptionClass_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_New((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_New_Offset, pointer, name, destructor);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_SetPointer((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_GetPointer((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetContext(const CPyRef& capsule) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_GetContext((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_SetContext((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_CheckExact(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_CheckExact((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTraceBack_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTraceBack_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyClass_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyClass_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_New(UInt size) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_New((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_New_Offset, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Size(const CPyRef& tuple) -> UInt
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_Size((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_Size_Offset, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_GetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_SetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_GetSlice((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_CheckExact(const CPyRef& tuple) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_CheckExact((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_HasAttrString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_SetAttrString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_GetAttrString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Call((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Str(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Str((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Str_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Repr(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Repr((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Repr_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Dir(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Dir((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Dir_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_RichCompare((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Hash(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Hash((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Hash_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_IsTrue(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_IsTrue((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_IsTrue_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Not(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Not((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Not_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallable_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCallable_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCallable_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Length(const CPyRef& o) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Length((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Length_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_GetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemInt(const CPyRef& o, Int index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_GetItemInt((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_GetItemString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_DelItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_SetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_TypeCheck((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_CallFunction(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_CallFunction((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_CallFunction_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetObject(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySys_GetObject((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySys_GetObject_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetObject(const Char* name, const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySys_SetObject((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySys_SetObject_Offset, name, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySys_SetPath((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySys_SetArgvEx((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetPath() -> BaseArray<Url>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySys_GetPath((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySys_GetPath_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySite_AddSiteDir((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_FromString(const Char* str) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_FromString((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_FromString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_FromStringAndSize(const Block<const Char>& block) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_FromStringAndSize((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_FromStringAndSize_Offset, block);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_AsString(const CPyRef& str) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_AsString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_AsString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_AsCString(const CPyRef& str) -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_AsCString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_AsCString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_Size(const CPyRef& str) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_Size((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_Size_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetIter(const CPyRef& o) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_GetIter((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_GetIter_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyIter_Next(const CPyRef& it) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyIter_Next((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyIter_Next_Offset, it);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_New() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_New((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_New_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_GetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_GetItemString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_SetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_DelItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> CONTAINS
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Contains((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Clear(const CPyRef& dict) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Clear((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Next((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Keys(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Keys((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Keys_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Values(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Values((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Values_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Items(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Items((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Items_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Size(const CPyRef& dict) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Size((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Size_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Copy(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Copy((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Copy_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_SetItemString((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_SetItemString_Offset, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Check(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Check((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_New(UInt size) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_New_Offset, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_CheckExact(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_CheckExact((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_CheckExact_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Size(const CPyRef& list) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Size((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Size_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetItem(const CPyRef& list, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_GetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_GetItem_Offset, list, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_SetItem((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Insert((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Append(const CPyRef& list, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Append((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Append_Offset, list, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_GetSlice((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_SetSlice((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Sort(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Sort((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Sort_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Reverse(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Reverse((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Reverse_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_AsTuple(const CPyRef& list) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_AsTuple((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_AsTuple_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_DelItemString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyModule_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyModule_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyModule_AddObject((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_GetDict(const CPyRef& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyModule_GetDict((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyModule_GetDict_Offset, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyModule_AddIntConstant((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_ImportModule(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyImport_ImportModule((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyImport_ImportModule_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_GetImporter(const CPyRef& path) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyImport_GetImporter((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyImport_GetImporter_Offset, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_IsSubtype((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_HasFeature((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_HasFeature_Offset, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_FastSubclass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_FastSubclass_Offset, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_GetName((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_GetName_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Ready(CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_Ready((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_Ready_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_SaveThread() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_SaveThread((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_SaveThread_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_RestoreThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_RestoreThread((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ThreadsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_InitThreads() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_InitThreads((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_InitThreads_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_AcquireLock() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_AcquireLock((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_AcquireLock_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ReleaseLock() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_ReleaseLock((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_ReleaseLock_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_AcquireThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_AcquireThread((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ReleaseThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_ReleaseThread((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ReInitThreads() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_ReInitThreads((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_ReInitThreads_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_GetBuiltins() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_GetBuiltins((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_GetBuiltins_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyEval_EvalCode((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyEval_EvalCode_Offset, code, globals, locals);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyFloat_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyFloat_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat32(Float32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyFloat_FromFloat32((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat64(Float64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyFloat_FromFloat64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_AsFloat64(const CPyRef& o) -> Float64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyFloat_AsFloat64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_FromBool(Bool value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyBool_FromBool((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyBool_FromBool_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromInt16(Int16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromInt16((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromInt16_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromUInt16(UInt16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromUInt16((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromUInt16_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromInt32(Int32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromInt32((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromInt32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromUInt32(UInt32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromUInt32((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromUInt32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromInt64(Int64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromInt64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromInt64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_FromUInt64(UInt64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_FromUInt64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_FromUInt64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsInt16(const CPyRef& o) -> Int16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsInt16((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsInt16_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsUInt16(const CPyRef& o) -> UInt16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsUInt16((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsUInt16_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsInt32(const CPyRef& o) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsInt32((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsInt32_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsUInt32(const CPyRef& o) -> UInt32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsUInt32((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsUInt32_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsInt64(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsInt64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsInt64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_AsUInt64(const CPyRef& o) -> UInt64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_AsUInt64((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_AsUInt64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNumber_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyNumber_Check((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyNumber_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyFunction_New(const reflection::Function* func) -> MPyFunctionRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyFunction_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyFunction_New_Offset, func);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyMember_New(const reflection::Member* member) -> MPyMemberRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyMember_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyMember_New_Offset, member);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyClass_New(const reflection::Class* cls) -> MPyClassRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyClass_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyClass_New_Offset, cls);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DebugFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_DebugFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_DebugFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_VerboseFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_VerboseFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_VerboseFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InteractiveFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_InteractiveFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_InteractiveFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InspectFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_InspectFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_InspectFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_OptimizeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_OptimizeFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_OptimizeFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoSiteFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_NoSiteFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_NoSiteFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_BytesWarningFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_BytesWarningFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_BytesWarningFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_UseClassExceptionsFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_FrozenFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_FrozenFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_FrozenFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_TabcheckFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_TabcheckFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_TabcheckFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_UnicodeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_UnicodeFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_UnicodeFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IgnoreEnvironmentFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DivisionWarningFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DontWriteBytecodeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoUserSiteDirectory() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_QnewFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_QnewFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_QnewFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Py3kWarningFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_CheckInterval() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPy_CheckInterval((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPy_CheckInterval_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BaseException() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_BaseException((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_BaseException_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Exception() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_Exception((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_Exception_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StopIteration() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_StopIteration((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_StopIteration_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_GeneratorExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_GeneratorExit((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_GeneratorExit_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StandardError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_StandardError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_StandardError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ArithmeticError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ArithmeticError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ArithmeticError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_LookupError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_LookupError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_LookupError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AssertionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_AssertionError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_AssertionError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AttributeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_AttributeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_AttributeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EOFError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_EOFError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_EOFError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FloatingPointError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_FloatingPointError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_FloatingPointError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EnvironmentError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_EnvironmentError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_EnvironmentError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IOError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_IOError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_IOError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OSError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_OSError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_OSError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ImportError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ImportError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndexError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_IndexError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_IndexError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_KeyError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_KeyError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyboardInterrupt() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_MemoryError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_MemoryError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NameError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_NameError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_NameError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OverflowError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_OverflowError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_OverflowError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_RuntimeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_RuntimeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NotImplementedError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_NotImplementedError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_NotImplementedError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_SyntaxError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_SyntaxError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndentationError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_IndentationError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_IndentationError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TabError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_TabError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_TabError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ReferenceError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ReferenceError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ReferenceError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_SystemError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_SystemError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_SystemExit((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_SystemExit_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TypeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_TypeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_TypeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnboundLocalError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnicodeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnicodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeEncodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeDecodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeTranslateError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ValueError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ValueError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ValueError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ZeroDivisionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_WindowsError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_WindowsError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_WindowsError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BufferError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_BufferError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_BufferError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryErrorInst() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RecursionErrorInst() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Warning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_Warning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_Warning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UserWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UserWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UserWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_DeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_PendingDeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FutureWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_FutureWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_FutureWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_ImportWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_ImportWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BytesWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyExc_BytesWarning((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyExc_BytesWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNullImporter_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyNullImporter_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyNullImporter_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySuper_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySuper_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySuper_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyBool_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyBool_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyModule_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyModule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyString_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyString_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyString_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyInt_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyInt_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyInt_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyLong_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyLong_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyFloat_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyFloat_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTuple_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTuple_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyList_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyList_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyDict_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyDict_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyClass_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyClass_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyTraceBack_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyTraceBack_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySlice_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPySlice_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPySlice_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyType_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyType_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyMemoryView_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyMemoryView_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyMemoryView_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConvertAndCacheString(const String& str, const StringEncodingRef& encoding) -> const PyChar*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_ConvertAndCacheString((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_ConvertAndCacheString_Offset, str, encoding);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_RegisterSpecificPythonClass((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateRegisterBuiltinConverter(const DataType* dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void>
	{
		return StaticMTable::_instance._CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetSpecialPath(SPECIALPATH anonymous_param_1) -> Url
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetSpecialPath((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_RegisterSpecialPath((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyDataCapsule_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyDataCapsule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyData_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyData_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyData_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyCapsule_Type((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyCapsule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateGetCurrentCallerContext() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyData_ToMapperInstance((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_ToMapperInstance(const DataType* dt, const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::AssociateDataTypeWithPythonTypes(const DataType* dt, const CPyRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetAssociatedDataType(const DataType* dt) -> Result<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetAssociatedDataType((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetAssociatedDataType_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetConverterPyObject_FromData(const DataType* dt) -> DelegatePyObject_FromData<>*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetConverterPyObject_FromData((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(Data& data) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyData_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyData_New_Offset, data);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(const DataType* dt, Generic* data, Bool owner, const DataType* mapDt) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyData_New_1((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_New(const DataType* dt) -> MPyDataTypeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyDataType_New((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyDataType_New_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyDataType_CheckExact((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyDataType_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> const DataType*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyDataType_GetDataType((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyDataType_GetDataType_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MPyData_CheckExact((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MPyData_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType* expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_AsData((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<const DataType*>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_ParseDataType((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const Error& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_SetError((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_SetError_Offset, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const ErrorPtr& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_SetError_1((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_SetError_1_Offset, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MaxonConvertAuto(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_MaxonConvertAuto((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_FromGeneric(const DataType* origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CPyObject_FromGeneric((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CreateGlobalDictionary() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_CreateGlobalDictionary((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_CreateGlobalDictionary_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCurrentTraceback((maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCurrentTraceback_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyRefClass() const -> Class<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCPyRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCPyRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTypeRefClass() const -> Class<CPyTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCPyTypeRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCPyTypeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyFrameRefClass() const -> Class<CPyFrameRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCPyFrameRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCPyFrameRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTracebackRefClass() const -> Class<CPyTracebackRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCPyTracebackRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCPyTracebackRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyCodeRefClass() const -> Class<CPyCodeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetCPyCodeRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetCPyCodeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyClassRefClass() const -> Class<MPyClassRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyClassRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyClassRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyMemberRefClass() const -> Class<MPyMemberRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyMemberRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyMemberRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyFunctionRefClass() const -> Class<MPyFunctionRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyFunctionRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyFunctionRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataTypeRefClass() const -> Class<MPyDataTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyDataTypeRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataRefClass() const -> Class<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyDataRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyDataRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyCallerContextRefClass() const -> Class<MPyCallerContextRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_._CPythonLibraryInterface_GetMPyCallerContextRefClass((const maxon::GenericComponent*) this + mt_._CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION> { return (StaticMTable::_instance._CPythonLibraryInterface_ParseCommandLine(args, res, flags)); }
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::Init(const Url& librarypath, Bool createSubLibrary) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::InitTypes() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_InitTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_InitTypes_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::InitTypes() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_InitTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_InitTypes_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::InitBuiltinModules() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_InitBuiltinModules(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_InitBuiltinModules_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::InitBuiltinModules() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_InitBuiltinModules(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_InitBuiltinModules_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_Initialize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Initialize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Initialize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_Initialize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Initialize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Initialize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_Finalize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Finalize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Finalize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_Finalize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Finalize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Finalize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::PrivateCPyRandom_Init() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateCPyRandom_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_PrivateCPyRandom_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateCPyRandom_Init_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::PrivateCPyRandom_Init() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateCPyRandom_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_PrivateCPyRandom_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateCPyRandom_Init_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_InitModule(const ModuleDefinition& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InitModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InitModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InitModule_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_InitModule(const ModuleDefinition& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InitModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InitModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InitModule_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::Free(const Delegate<void()>& shutdownEngine) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_Free(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_Free_Offset, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::Free(const Delegate<void()>& shutdownEngine) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_Free(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_Free_Offset, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetDll() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const PythonDll&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetDll) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetDll(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetDll_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::FopenNative(const Char* name, const Char* mode) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_FopenNative(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_FopenNative_Offset, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::FopenNative(const Char* name, const Char* mode) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_FopenNative(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_FopenNative_Offset, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<Error>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_LastPythonCallFailed(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_LastPythonCallFailed(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType* dtOfObject) const -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<MPyDataRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_RegisterComponentProxy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType* dtOfObject) -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<MPyDataRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_RegisterComponentProxy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_IsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_IsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_IsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_IsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_IsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_IsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetVersion() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetVersion(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetVersion_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetVersion() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetVersion(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetVersion_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetPlatform() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetPlatform(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetPlatform_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetPlatform() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetPlatform(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetPlatform_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetCopyright() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetCopyright(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetCopyright_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetCopyright() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetCopyright(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetCopyright_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetCompiler() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetCompiler(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetCompiler_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetCompiler() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetCompiler(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetCompiler_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetBuildInfo() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetBuildInfo(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetBuildInfo_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetBuildInfo() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetBuildInfo(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetBuildInfo_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_SetProgramName(const String& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_SetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SetProgramName_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_SetProgramName(const String& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_SetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SetProgramName_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_SetPythonHome(const Url& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_SetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SetPythonHome_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_SetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SetPythonHome_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetProgramName() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetProgramName_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetProgramName() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetProgramName_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_GetPythonHome() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetPythonHome_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_GetPythonHome() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_GetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_GetPythonHome_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ExecuteModule(const String& name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ExecuteModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ExecuteModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ExecuteModule(const String& name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ExecuteModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ExecuteModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCallerContext_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyCallerContextRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCallerContext_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCallerContext_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCallerContext_New() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCallerContext_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCallerContext_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_FileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_FileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyGilState_Ensure() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<PYGILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGilState_Ensure(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGilState_Ensure_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyGilState_Ensure() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGilState_Ensure(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGilState_Ensure_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyGilState_Release(PYGILSTATE state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyGilState_Release(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGilState_Release_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyGilState_Release(PYGILSTATE state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyGilState_Release(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGilState_Release_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetGilState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<GILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetGilState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetGilState(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetGilState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyGILState_GetThisThreadState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyGILState_GetThisThreadState() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyThreadState_Swap(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyThreadState_Swap(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyThreadState_Swap_Offset, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyThreadState_Swap(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyThreadState_Swap(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyThreadState_Swap_Offset, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyThreadState_GetDict() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyThreadState_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyThreadState_GetDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyThreadState_GetDict() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyThreadState_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyThreadState_GetDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyCodeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_CompileStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_CompileStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_Incref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Incref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Incref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Incref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_Decref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Decref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_Decref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Decref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_SafeIncref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeIncref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_SafeIncref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SafeIncref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_SafeDecref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeDecref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPy_SafeDecref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_SafeDecref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_SafeClear(T*& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPy_SafeClear on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } 
		o_->CPy_SafeClear<T>(o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyGC_Collect() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGC_Collect(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGC_Collect_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyGC_Collect() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyGC_Collect(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyGC_Collect_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCode_Addr2Line(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCode_Addr2Line(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::UnpackDataType(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_UnpackDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_UnpackDataType_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::UnpackDataType(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_UnpackDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_UnpackDataType_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::UnpackData(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_UnpackData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_UnpackData_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::UnpackData(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_UnpackData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_UnpackData_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_None() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_None) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_None(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_None_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_True() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_True) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_True(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_True_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_False() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_False) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_False(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_False_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPy_NotImplemented() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NotImplemented) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_NotImplemented(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_NotImplemented_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_Print() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Print(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Print_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_Print() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Print(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Print_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_Clear() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Clear_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_Clear() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Clear_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_Occurred(CPyRef* type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_Occurred(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Occurred_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_Occurred(CPyRef* type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_Occurred(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Occurred_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetWithErrno(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetWithErrno(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetString_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_SetString_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_SetNone(const CPyRef& errorType) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_SetNone(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_SetNone(const CPyRef& errorType) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_SetNone(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Fetch(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Fetch(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_NormalizeException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_NormalizeException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Restore(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyErr_Restore(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyErr_ExceptionMatches(const CPyRef& exc) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyErr_ExceptionMatches(const CPyRef& exc) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExceptionClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExceptionClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExceptionClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExceptionClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_New_Offset, pointer, name, destructor));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_SetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_SetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_GetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_GetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_GetContext(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_GetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_GetContext(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_GetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_SetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_SetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_CheckExact(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTraceBack_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTraceBack_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTraceBack_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTraceBack_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTraceBack_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTraceBack_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyTuple_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_Size(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_Size_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_Size(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_Size_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_CheckExact(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_CheckExact(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_HasAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_HasAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_SetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_SetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Call(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Call(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Str(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Str(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Str_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Str(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Str(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Str_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Repr(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Repr(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Repr_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Repr(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Repr(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Repr_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Dir(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Dir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Dir_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Dir(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Dir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Dir_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_RichCompare(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_RichCompare(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Hash(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Hash(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Hash_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Hash(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Hash(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Hash_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_IsTrue(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_IsTrue(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_IsTrue_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_IsTrue(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_IsTrue(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_IsTrue_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Not(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Not(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Not_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Not(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Not(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Not_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCallable_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCallable_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCallable_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCallable_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCallable_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCallable_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Length(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Length(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Length_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Length(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Length(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Length_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItemInt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItemInt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_TypeCheck(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_TypeCheck(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_CallFunction(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_CallFunction(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_CallFunction_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_CallFunction(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_CallFunction(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_CallFunction_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySys_GetObject(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_GetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_GetObject_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySys_GetObject(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_GetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_GetObject_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySys_SetObject(const Char* name, const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetObject_Offset, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySys_SetObject(const Char* name, const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetObject_Offset, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetArgvEx(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_SetArgvEx(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySys_GetPath() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<BaseArray<Url>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_GetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_GetPath_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySys_GetPath() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySys_GetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySys_GetPath_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySite_AddSiteDir(const Url& siteDir) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySite_AddSiteDir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySite_AddSiteDir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyString_FromString(const Char* str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_FromString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_FromString(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_FromString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_FromStringAndSize(const Block<const Char>& block) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_FromStringAndSize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_FromStringAndSize_Offset, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_FromStringAndSize(const Block<const Char>& block) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_FromStringAndSize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_FromStringAndSize_Offset, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_AsString(const CPyRef& str) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_AsString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_AsString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_AsString(const CPyRef& str) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_AsString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_AsString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_AsCString(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_AsCString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_AsCString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_AsCString(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_AsCString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_AsCString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_Size(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Size_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_Size(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Size_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyObject_GetIter(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetIter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_GetIter(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_GetIter_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyIter_Next(const CPyRef& it) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyIter_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyIter_Next(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyIter_Next_Offset, it));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyDict_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CONTAINS>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Contains(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Contains(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Clear(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyDict_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Clear(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyDict_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Next(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Next(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Keys(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Keys(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Keys_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Keys(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Keys(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Keys_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Values(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Values(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Values_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Values(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Values(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Values_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Items(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Items(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Items_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Items(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Items(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Items_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Size(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Size_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Size(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Size_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Copy(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Copy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Copy_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Copy(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Copy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Copy_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_SetItemString(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_SetItemString_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyDict_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Check(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_New(UInt size) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_CheckExact(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_CheckExact_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_CheckExact(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_CheckExact_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Size(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Size_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Size(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Size_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_GetItem(const CPyRef& list, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_GetItem_Offset, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_GetItem(const CPyRef& list, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_GetItem_Offset, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Insert(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Insert(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Append(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Append_Offset, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Append(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Append_Offset, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_SetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_SetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Sort(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Sort(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Sort_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Sort(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Sort(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Sort_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Reverse(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Reverse(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Reverse_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Reverse(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Reverse(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Reverse_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_AsTuple(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_AsTuple(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_AsTuple_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_AsTuple(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_AsTuple(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_AsTuple_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_DelItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_DelItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyModule_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyModule_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_AddObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_AddObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyModule_GetDict(const CPyRef& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_GetDict_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyModule_GetDict(const CPyRef& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_GetDict_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_AddIntConstant(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_AddIntConstant(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyImport_ImportModule(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyImport_ImportModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyImport_ImportModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyImport_ImportModule(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyImport_ImportModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyImport_ImportModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyImport_GetImporter(const CPyRef& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyImport_GetImporter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyImport_GetImporter_Offset, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyImport_GetImporter(const CPyRef& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyImport_GetImporter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyImport_GetImporter_Offset, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyType_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyType_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_IsSubtype(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_IsSubtype(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_HasFeature) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_HasFeature(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_HasFeature_Offset, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_FastSubclass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_FastSubclass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_FastSubclass_Offset, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyType_GetName(const CPyTypeRef& type) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_GetName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_GetName_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_GetName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_GetName_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyType_Ready(CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Ready(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Ready_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyType_Ready(CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Ready(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Ready_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_SaveThread() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_SaveThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_SaveThread_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_SaveThread() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_SaveThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_SaveThread_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_RestoreThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_RestoreThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_RestoreThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_RestoreThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_ThreadsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_ThreadsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_InitThreads() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_InitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_InitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_InitThreads() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_InitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_InitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_AcquireLock() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireLock) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_AcquireLock(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_AcquireLock_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_AcquireLock() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireLock) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_AcquireLock(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_AcquireLock_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_ReleaseLock() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseLock) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReleaseLock(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReleaseLock_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_ReleaseLock() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseLock) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReleaseLock(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReleaseLock_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_AcquireThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_AcquireThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_AcquireThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_AcquireThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_ReleaseThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReleaseThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_ReleaseThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReleaseThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyEval_ReInitThreads() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReInitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReInitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReInitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyEval_ReInitThreads() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReInitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_CPyEval_ReInitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_ReInitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyEval_GetBuiltins() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_GetBuiltins) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_GetBuiltins(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_GetBuiltins_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_EvalCode) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyEval_EvalCode(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyEval_EvalCode_Offset, code, globals, locals));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_FromFloat32(Float32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_FromFloat32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_FromFloat32(Float32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_FromFloat32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_FromFloat64(Float64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_FromFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_FromFloat64(Float64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_FromFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_AsFloat64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_AsFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_AsFloat64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_AsFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_As on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_From(std::enable_if_t<std::is_same<T, Float32>::value, Float32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<std::is_same<T, Float32>::value, Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_From(std::enable_if_t<std::is_same<T, Float32>::value, Float32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<std::is_same<T, Float32>::value, Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_From(std::enable_if_t<std::is_same<T, Float64>::value, Float64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<std::is_same<T, Float64>::value, Float64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_From(std::enable_if_t<std::is_same<T, Float64>::value, Float64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<std::is_same<T, Float64>::value, Float64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyBool_FromBool(Bool value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyBool_FromBool(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyBool_FromBool_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyBool_FromBool(Bool value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyBool_FromBool(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyBool_FromBool_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromInt16(Int16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromInt16(Int16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromUInt16(UInt16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromUInt16(UInt16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromInt32(Int32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromInt32(Int32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromUInt32(UInt32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromUInt32(UInt32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromInt64(Int64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromInt64(Int64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_FromUInt64(UInt64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_FromUInt64(UInt64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_FromUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_FromUInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsUInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsUInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsUInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsUInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_AsUInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return 0; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_AsUInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_AsUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_AsUInt64_Offset, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyInt_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyInt_As on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyInt_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyInt_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyInt_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyInt_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->CPyInt_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyInt_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->CPyInt_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyNumber_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(false); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyNumber_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyNumber_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyNumber_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyNumber_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyNumber_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyFunction_New(const reflection::Function* func) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyFunctionRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyFunction_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyFunction_New_Offset, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyFunction_New(const reflection::Function* func) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyFunction_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyFunction_New_Offset, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyMember_New(const reflection::Member* member) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyMemberRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyMember_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyMember_New_Offset, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyMember_New(const reflection::Member* member) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyMember_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyMember_New_Offset, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyClass_New(const reflection::Class* cls) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyClassRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyClass_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyClass_New_Offset, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyClass_New(const reflection::Class* cls) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyClass_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyClass_New_Offset, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_DebugFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DebugFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DebugFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_DebugFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DebugFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DebugFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_VerboseFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_VerboseFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_VerboseFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_VerboseFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_VerboseFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_VerboseFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_InteractiveFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InteractiveFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InteractiveFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_InteractiveFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InteractiveFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InteractiveFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_InspectFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InspectFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InspectFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_InspectFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_InspectFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_InspectFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_OptimizeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_OptimizeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_OptimizeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_OptimizeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_OptimizeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_OptimizeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_NoSiteFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_NoSiteFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_NoSiteFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_NoSiteFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_NoSiteFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_NoSiteFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_BytesWarningFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_BytesWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_BytesWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_BytesWarningFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_BytesWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_BytesWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_UseClassExceptionsFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_UseClassExceptionsFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_UseClassExceptionsFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_UseClassExceptionsFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_UseClassExceptionsFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_FrozenFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_FrozenFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_FrozenFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_FrozenFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_FrozenFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_FrozenFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_TabcheckFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_TabcheckFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_TabcheckFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_TabcheckFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_TabcheckFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_TabcheckFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_TabcheckFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_TabcheckFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_UnicodeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_UnicodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_UnicodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_UnicodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_UnicodeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_UnicodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_UnicodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_UnicodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_IgnoreEnvironmentFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_IgnoreEnvironmentFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_DivisionWarningFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DivisionWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_DivisionWarningFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DivisionWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DivisionWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_DontWriteBytecodeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_DontWriteBytecodeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_NoUserSiteDirectory() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_NoUserSiteDirectory() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_QnewFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_QnewFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_QnewFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_QnewFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_QnewFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_QnewFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_QnewFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_QnewFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_Py3kWarningFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Py3kWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_Py3kWarningFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Py3kWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_Py3kWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPy_CheckInterval() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CheckInterval) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_CheckInterval(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_CheckInterval_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPy_CheckInterval() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CheckInterval) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPy_CheckInterval(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPy_CheckInterval_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_BaseException() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BaseException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BaseException_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_BaseException() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BaseException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BaseException_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_Exception() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_Exception(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_Exception_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_Exception() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_Exception(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_Exception_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_StopIteration() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_StopIteration(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_StopIteration_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_StopIteration() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_StopIteration(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_StopIteration_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_GeneratorExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_GeneratorExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_GeneratorExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_GeneratorExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_GeneratorExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_GeneratorExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_StandardError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_StandardError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_StandardError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_StandardError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_StandardError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_StandardError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ArithmeticError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ArithmeticError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ArithmeticError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ArithmeticError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ArithmeticError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ArithmeticError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_LookupError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_LookupError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_LookupError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_LookupError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_LookupError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_LookupError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_AssertionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_AssertionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_AssertionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_AssertionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_AssertionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_AssertionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_AttributeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_AttributeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_AttributeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_AttributeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_AttributeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_AttributeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_EOFError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_EOFError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_EOFError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_EOFError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_EOFError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_EOFError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_FloatingPointError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_FloatingPointError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_FloatingPointError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_FloatingPointError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_FloatingPointError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_FloatingPointError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_EnvironmentError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_EnvironmentError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_EnvironmentError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_EnvironmentError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_EnvironmentError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_EnvironmentError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_IOError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IOError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IOError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_IOError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IOError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IOError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_OSError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_OSError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_OSError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_OSError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_OSError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_OSError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ImportError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ImportError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ImportError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ImportError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ImportError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ImportError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_IndexError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IndexError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IndexError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_IndexError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IndexError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IndexError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_KeyError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_KeyError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_KeyError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_KeyError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_KeyError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_KeyError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_KeyboardInterrupt() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_KeyboardInterrupt() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_MemoryError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_MemoryError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_MemoryError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_MemoryError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_MemoryError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_MemoryError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_NameError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_NameError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_NameError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_NameError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_NameError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_NameError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_OverflowError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_OverflowError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_OverflowError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_OverflowError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_OverflowError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_OverflowError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_RuntimeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RuntimeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RuntimeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_RuntimeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RuntimeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RuntimeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_NotImplementedError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_NotImplementedError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_NotImplementedError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_NotImplementedError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_NotImplementedError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_NotImplementedError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_SyntaxError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SyntaxError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SyntaxError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_SyntaxError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SyntaxError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SyntaxError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_IndentationError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IndentationError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IndentationError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_IndentationError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_IndentationError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_IndentationError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_TabError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_TabError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_TabError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_TabError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_TabError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_TabError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ReferenceError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ReferenceError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ReferenceError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ReferenceError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ReferenceError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ReferenceError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_SystemError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SystemError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SystemError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_SystemError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SystemError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SystemError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_SystemExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SystemExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SystemExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_SystemExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SystemExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SystemExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_TypeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_TypeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_TypeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_TypeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_TypeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_TypeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnboundLocalError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnboundLocalError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnicodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnicodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnicodeEncodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnicodeEncodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnicodeDecodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnicodeDecodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnicodeTranslateError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnicodeTranslateError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ValueError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ValueError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ValueError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ValueError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ValueError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ValueError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ZeroDivisionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ZeroDivisionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_WindowsError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_WindowsError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_WindowsError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_WindowsError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_WindowsError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_WindowsError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_BufferError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BufferError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BufferError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_BufferError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BufferError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BufferError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_MemoryErrorInst() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_MemoryErrorInst() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_RecursionErrorInst() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RecursionErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_RecursionErrorInst() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RecursionErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RecursionErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_Warning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_Warning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_Warning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_Warning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_Warning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_Warning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UserWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UserWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UserWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UserWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UserWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UserWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_DeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_DeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_PendingDeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_PendingDeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_SyntaxWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_SyntaxWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_RuntimeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_RuntimeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_FutureWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_FutureWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_FutureWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_FutureWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_FutureWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_FutureWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_ImportWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ImportWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ImportWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_ImportWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_ImportWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_ImportWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_UnicodeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_UnicodeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyExc_BytesWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BytesWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BytesWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyExc_BytesWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyExc_BytesWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyExc_BytesWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyNullImporter_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyNullImporter_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyNullImporter_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyNullImporter_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyNullImporter_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyNullImporter_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySuper_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySuper_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySuper_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySuper_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySuper_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySuper_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyBool_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyBool_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyBool_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyBool_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyBool_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyBool_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyModule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyModule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyModule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyModule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyString_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyString_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyString_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyString_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyString_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyInt_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyInt_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyInt_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyInt_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyInt_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyLong_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyLong_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyLong_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyLong_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyLong_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyLong_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyFloat_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyFloat_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyFloat_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyFloat_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTuple_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTuple_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTuple_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTuple_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyList_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyList_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyList_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyList_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyDict_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyDict_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyDict_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyDict_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyClass_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyClass_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyClass_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyClass_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyClass_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyClass_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyTraceBack_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTraceBack_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTraceBack_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyTraceBack_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyTraceBack_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyTraceBack_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPySlice_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySlice_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySlice_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPySlice_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPySlice_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPySlice_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyType_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyType_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyType_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyType_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyMemoryView_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyMemoryView_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyMemoryView_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyMemoryView_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyMemoryView_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyMemoryView_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ConvertAndCacheString(const String& str, const StringEncodingRef& encoding) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ConvertAndCacheString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ConvertAndCacheString_Offset, str, encoding));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ConvertAndCacheString(const String& str, const StringEncodingRef& encoding) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ConvertAndCacheString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ConvertAndCacheString_Offset, str, encoding));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_RegisterSpecificPythonClass(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_RegisterSpecificPythonClass(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::PrivateRegisterBuiltinConverter(const DataType* dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::PrivateRegisterBuiltinConverter(const DataType* dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<Result<void>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::RegisterBuiltinConverter on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void> { return (StaticMTable::_instance._CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome)); }
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<Url>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_RegisterSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_RegisterSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyDataCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyDataCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyData_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyData_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyData_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyData_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyData_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyData_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::PrivateGetCurrentCallerContext() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::PrivateGetCurrentCallerContext() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_ToMapperInstance(const DataType* dt, const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_ToMapperInstance(const DataType* dt, const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::AssociateDataTypeWithPythonTypes(const DataType* dt, const CPyRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::AssociateDataTypeWithPythonTypes(const DataType* dt, const CPyRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::GetAssociatedDataType(const DataType* dt) const -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<CPyRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetAssociatedDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetAssociatedDataType_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::GetAssociatedDataType(const DataType* dt) -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<CPyRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetAssociatedDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetAssociatedDataType_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::GetConverterPyObject_FromData(const DataType* dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return nullptr; const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetConverterPyObject_FromData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::GetConverterPyObject_FromData(const DataType* dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetConverterPyObject_FromData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyData_New(Data& data) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_New_Offset, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyData_New(Data& data) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_New_Offset, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyData_New(const DataType* dt, Generic* data, Bool owner, const DataType* mapDt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyData_New(const DataType* dt, Generic* data, Bool owner, const DataType* mapDt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MPyDataType_New(const DataType* dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<MPyDataTypeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_New_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MPyDataType_New(const DataType* dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_New_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::MPyDataType_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_CheckExact(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType*>, const DataType*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType*>, const DataType*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_GetDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyDataType_GetDataType(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyDataType_GetDataType_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::MPyData_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MPyData_CheckExact(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MPyData_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType* expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) const -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<Data*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_AsData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType* expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<Data*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_AsData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::GetRegisteredTypesWithConversions() const -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>, typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>, typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type, maxon::Result<typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type, maxon::Result<typename std::enable_if<std::is_same<T, DataType*>::value, ResultPtr<const DataType>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<T>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<Result<T>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseRef on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>, typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>, typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type, maxon::Result<typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type, maxon::Result<typename std::enable_if<std::is_reference<T>::value||std::is_pointer<T>::value, Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>, typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>, typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type, maxon::Result<typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type, maxon::Result<typename std::enable_if<!std::is_reference<T>::value&&!std::is_pointer<T>::value, Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) const -> Result<const DataType*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<const DataType*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ParseDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<const DataType*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<const DataType*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_ParseDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, const DataType*& dt, Bool unpackData) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<T>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<Result<T>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, const DataType*& dt, Bool unpackData) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseGeneric on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::SetError(const Error& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_SetError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_SetError_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::SetError(const Error& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_SetError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_SetError_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::SetError(const ErrorPtr& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateLogNullptrError(); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_SetError_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_SetError_1_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::SetError(const ErrorPtr& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_._CPythonLibraryInterface_SetError_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_SetError_1_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::MaxonConvertAuto(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MaxonConvertAuto(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::MaxonConvertAuto(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_MaxonConvertAuto(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::CPyObject_FromGeneric(const DataType* origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_FromGeneric(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::CPyObject_FromGeneric(const DataType* origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CPyObject_FromGeneric(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::CreateGlobalDictionary() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CreateGlobalDictionary) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_CreateGlobalDictionary(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_CreateGlobalDictionary_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::GetCurrentTraceback() const -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCurrentTraceback(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCurrentTraceback_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCurrentTraceback(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCurrentTraceback_Offset));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ReferenceFunctionsImpl<S>::Enum_ToMapperInstance(T enumm) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::COWReferenceFunctionsImpl<S>::Enum_ToMapperInstance(T enumm) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::Enum_ToMapperInstance on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetCPyRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCPyRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCPyRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetCPyTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCPyTypeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCPyTypeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetCPyFrameRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyFrameRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyFrameRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCPyFrameRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCPyFrameRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetCPyTracebackRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTracebackRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTracebackRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCPyTracebackRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCPyTracebackRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetCPyCodeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyCodeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyCodeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetCPyCodeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetCPyCodeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyClassRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyClassRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyClassRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyClassRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyClassRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyMemberRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyMemberRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyMemberRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyMemberRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyMemberRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyFunctionRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyFunctionRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyFunctionRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyFunctionRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyFunctionRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyDataTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyDataTypeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyDataRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyDataRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyDataRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConstReferenceFunctionsImpl<S>::GetMPyCallerContextRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyCallerContextRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyCallerContextRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_._CPythonLibraryInterface_GetMPyCallerContextRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_._CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset));
	}
	auto CPythonLibraryInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto CPythonLibraryInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
	static maxon::EntityUse s_ui_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
	static maxon::EntityUse s_usi_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_staticInterface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif
}

struct PyModuleInterface::MTable
{
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConstants);
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetFunctions27);
	static const maxon::Char* const _ids;
	static const maxon::Bool HAS_NONSTATIC = false;
	Result<void> (*_PyModuleInterface_GetFunctions27) (maxon::GenericComponent* this_, BaseArray<NativePyCFunctionTable>& functions);
	maxon::Int _PyModuleInterface_GetFunctions27_Offset;
	Result<void> (*_PyModuleInterface_GetConstants) (maxon::GenericComponent* this_, BaseArray<Tuple<const Char*, Int32>>& constants);
	maxon::Int _PyModuleInterface_GetConstants_Offset;
	template <typename W> void Init(maxon::Int offset)
	{
		if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PyModuleInterface, GetFunctions27))
		{
			auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PyModuleInterface, GetFunctions27), W, MTable>::type::_PyModuleInterface_GetFunctions27;
			_PyModuleInterface_GetFunctions27 = reinterpret_cast<const decltype(_PyModuleInterface_GetFunctions27)&>(ptr);
			_PyModuleInterface_GetFunctions27_Offset = offset;
		}
		if (PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PyModuleInterface, GetConstants))
		{
			auto ptr = &std::conditional<PRIVATE_MAXON_IMPLEMENTS(W::Implementation, PyModuleInterface, GetConstants), W, MTable>::type::_PyModuleInterface_GetConstants;
			_PyModuleInterface_GetConstants = reinterpret_cast<const decltype(_PyModuleInterface_GetConstants)&>(ptr);
			_PyModuleInterface_GetConstants_Offset = offset;
		}
	}
	template <typename W> static maxon::Bool InitWithBases(maxon::ClassInfo* info, maxon::Int offset)
	{
		if (!W::Implementation::PROXY && (!LibraryInterface::MTable::InitWithBases<W>(info, offset))) return false;
		MTable* vt = (MTable*) maxon::Object::PrivateGetOrCreateMTable(info, _interface); if (!vt) return false;
		vt->Init<W>(offset); return true;
	}
	template <typename S> using CombinedMTable = maxon::CombinedMTable<PyModuleInterface, LibraryInterface::MTable::CombinedMTable<S>>;
	PRIVATE_MAXON_COMPBASE(PyModuleInterface);
	template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
};

template <typename S> class PyModuleInterface::Wrapper : public LibraryInterface::Wrapper<S>
{
public:
	PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConstants);
	PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetFunctions27);
	static Result<void> _PyModuleInterface_GetFunctions27(maxon::GenericComponent* this_, BaseArray<NativePyCFunctionTable>& functions) { return ((typename S::Implementation*) this_)->GetFunctions27(functions); }
	static Result<void> _PyModuleInterface_GetConstants(maxon::GenericComponent* this_, BaseArray<Tuple<const Char*, Int32>>& constants) { return ((typename S::Implementation*) this_)->GetConstants(constants); }
};

MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetFunctions27(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return mt_._PyModuleInterface_GetFunctions27((maxon::GenericComponent*) this + mt_._PyModuleInterface_GetFunctions27_Offset, functions);
}
MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return mt_._PyModuleInterface_GetConstants((maxon::GenericComponent*) this + mt_._PyModuleInterface_GetConstants_Offset, constants);
}

template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::ReferenceFunctionsImpl<S>::GetFunctions27(BaseArray<NativePyCFunctionTable>& functions) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions27) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_._PyModuleInterface_GetFunctions27(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PyModuleInterface_GetFunctions27_Offset, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::COWReferenceFunctionsImpl<S>::GetFunctions27(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions27) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_._PyModuleInterface_GetFunctions27(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PyModuleInterface_GetFunctions27_Offset, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::ReferenceFunctionsImpl<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (MAXON_UNLIKELY(!o_)) return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_._PyModuleInterface_GetConstants(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PyModuleInterface_GetConstants_Offset, constants));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::COWReferenceFunctionsImpl<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS) && MAXON_UNLIKELY(!o_)) return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBase::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_._PyModuleInterface_GetConstants(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_._PyModuleInterface_GetConstants_Offset, constants));
}
auto PyModuleInterface::GetPtr() -> Ptr { return Ptr(this); }
auto PyModuleInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT)
static maxon::EntityUse s_ui_maxon_PyModuleInterface(PyModuleInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif
#endif

#ifdef MAXON_COMPILER_GCC
	#pragma GCC diagnostic pop
#endif

#endif

