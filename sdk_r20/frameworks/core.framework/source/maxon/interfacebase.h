#ifndef INTERFACEBASE_H__
#define INTERFACEBASE_H__

#include "maxon/entity.h"
#include "maxon/baseref.h"
#include "maxon/datatypebase.h"

namespace maxon
{

/// @addtogroup SYSTEM
/// @{


/// @cond INTERNAL

using MTableBase = void;

void* PrivateSystemAlloc(Int size);
void PrivateSystemFree(void*);

//----------------------------------------------------------------------------------------
/// DataTypeInitializer functions are invoked during the initialization of interfaces to initialize their type info objects.
#ifndef MAXON_COMPILER_CLANG	// circumvent clang bug that creates false positives
/// @param[in] info								Pointer to the not-yet initialized DataType object.
/// @param[in] type								Interface identifier.
/// @param[in] impl								The interface implementation info.
#endif
//----------------------------------------------------------------------------------------
using DataTypeInitializer = Result<void>(*)(DataType* info, Id&& type, const NonvirtualInterfaceImplementation* impl);


// used internally for the JIT assembly of Unresolved implementations to assemble the correct code depending on the return type
enum class NULL_RETURN_TYPE : UChar
{
	VOID_ZERO,
	VOID_ZERO_FREE_FUNCTION,
	INTEGRAL_ZERO,
	FLOAT_ZERO,
	DOUBLE_ZERO,
	POINTER_TO_ZERO,
	OTHER
} MAXON_ENUM_LIST(NULL_RETURN_TYPE);


//----------------------------------------------------------------------------------------
/// NonvirtualInterfaceReference is an EntityReference object which declares a non-virtual interface.
/// It is created by MAXON_INTERFACE_NONVIRTUAL together with code generated by the source processor.
/// @see NonvirtualInterfaceImplementation
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
class NonvirtualInterfaceReference
{
public:
	using MTableInitializer = void(*)(MTableBase*);
	using UnresolvedAssembler = Bool(*)(const NonvirtualInterfaceReference*, void* table, const NULL_RETURN_TYPE* returnTypes, Int count);
	using UnresolvedInitializer = Bool(*)(UnresolvedAssembler init, MTableBase* table);

	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceReference object and adds it to the reference list of the current translation unit.
	/// The MAXON_INTERFACE_REGISTER macro in the register.cpp file of the current module invokes this constructor.
	/// @param[in] iid								Unique interface identifier.
	/// @param[in] mtable							Pointer to the module's MTable for this interface.
	/// @param[in] unresolvedMTable		Pointer to the module's MTable for unresolved functions of this interface.
	/// @param[in] methodIds					Pointer to the module's method id table for this interface.
	/// @param[in] methodCount				Number of methods in the table.
	/// @param[in] initUnresolved			Function to initialize mtable with function pointers of the interface's Unresolved implementation.
	/// @param[in] nullResolve				If non-null, this is invoked to use a null-implementation when no definition for the interface exists. This is non-null only if @MAXON_ANNOTATION{nullimpl=true} is set for the interface.
	/// @param[in] unit								The translation unit containing the reference.
	/// @param[in] refType						The reference type of the interface (one of the REFERENCE flags of EntityBase::FLAGS).
	//----------------------------------------------------------------------------------------
	NonvirtualInterfaceReference(const Char* iid, MTableBase* mtable, MTableBase* unresolvedMTable, const Char* methodIds, Int methodCount, UnresolvedInitializer initUnresolved, MTableInitializer nullResolve, TranslationUnit* unit, EntityBase::FLAGS refType);

	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceReference object and adds it to the reference list of the current translation unit.
	/// The MAXON_INTERFACE_REGISTER macro in the register.cpp file of the current module invokes this constructor.
	/// @param[in] iid								Unique interface identifier.
	/// @param[in] mtable							Pointer to the module's MTable for this interface.
	/// @param[in] unresolvedMTable		Pointer to the module's MTable for unresolved functions of this interface.
	/// @param[in] methodIds					Pointer to the module's method id table for this interface.
	/// @param[in] methodCount				Number of methods in the table.
	/// @param[in] initUnresolved			Function to initialize mtable with function pointers of the interface's Unresolved implementation.
	/// @param[in] unit								The translation unit containing the reference.
	/// @param[in] refType						The reference type of the interface (one of the REFERENCE flags of EntityBase::FLAGS).
	//----------------------------------------------------------------------------------------
	NonvirtualInterfaceReference(const Char* iid, MTableBase* mtable, MTableBase* unresolvedMTable, const Char* methodIds, Int methodCount, UnresolvedInitializer initUnresolved, TranslationUnit* unit, EntityBase::FLAGS refType);

	//----------------------------------------------------------------------------------------
	/// This is invoked by the methods of an interface's Unresolved class to trigger the resolution of the interface.
	/// If the method table can be initialized properly this will return true, and the calling method of the Unresolved class
	/// will forward the invocation to the resolved method. Otherwise, false is returned, and the calling method
	/// will return the appropriate null value.
	//----------------------------------------------------------------------------------------
	static Bool PrivateResolve(NonvirtualInterfaceReference* this_, Bool showMessage);

	//----------------------------------------------------------------------------------------
	/// Returns true if the interface reference has been initialized successfully. This means that the reference has been resolved
	/// to an implementation which itself has been initialized successfully, so that it can be used.
	/// @return												True if reference and corresponding implementation have been initialized successfully.
	//----------------------------------------------------------------------------------------
	Bool IsInitialized() const
	{
		return _super.IsInitialized();
	}

	//----------------------------------------------------------------------------------------
	/// Returns the unique identifier of the interface.
	/// @return												Identifier of the interface.
	//----------------------------------------------------------------------------------------
	const Id& GetId() const
	{
		return _super.GetBase().GetId();
	}

	//----------------------------------------------------------------------------------------
	/// Returns the DataType of this interface. This is only valid after a successful initialization.
	/// @return												Data type of this interface.
	//----------------------------------------------------------------------------------------
	const DataType* GetDataType() const
	{
		return _type;
	}

	//----------------------------------------------------------------------------------------
	/// Returns a const reference to the null value of the reference class. This is only valid after a successful initialization.
	/// @return												Const reference to the null value (to be casted into the reference class).
	//----------------------------------------------------------------------------------------
	const Generic* const& GetNullValue() const
	{
		return _nullValue;
	}

	const Char* GetMethodIds() const
	{
		return _methodIds;
	}

	const MTableBase* GetMTable() const
	{
		return _mtable;
	}

	const EntityReference& GetReference() const
	{
		return _super;
	}

private:
	EntityReference _super; ///< EntityReference base object.
	MTableBase* _mtable; ///< Pointer to the method table of the current module for the interface.
	MTableBase* _unresolvedMTable; ///< Pointer to the method table for unresolved functions of the current module for the interface.
	const Char* _methodIds; ///< Pointer to the method id table of the current module for the interface.
	Int _methodCount; ///< Number of methods in the method table.
	UnresolvedInitializer _initUnresolved; ///< Initializer to set function pointers of MTable to Unresolved implementations.
	const DataType* _type; ///< The type of this interface.
	MTableInitializer _nullResolve; ///< If non-null, this is invoked to use a null-implementation when no definition for the interface exists.
	const Generic* _nullValue; ///< Pointer to the null value of the implementation (may be nullptr).
	friend class ObjectModel;
	friend class NonvirtualInterfaceImplementation;
};


template <typename T> class InterfaceDataTypeFunctions;

template <typename T> struct InterfaceDataTypeFunctionsTrait
{
	using Functions = InterfaceDataTypeFunctions<T>;
	static const Bool REGISTER_TYPE = true;
};

template <typename T, Bool HAS_NONSTATIC = T::MTable::HAS_NONSTATIC> struct PrivateInitInterfaceType
{
	static Result<void> Init(DataType* info, Id&& iid, const NonvirtualInterfaceImplementation* impl)
	{
		new (info) DataType(std::move(iid), nullptr, nullptr, (T*) nullptr, (typename InterfaceDataTypeFunctionsTrait<T>::Functions*) nullptr, VALUEKIND::NONE, impl, VALUEKIND::NONVIRTUAL_INTERFACE);
		if (!InterfaceDataTypeFunctionsTrait<T>::REGISTER_TYPE)
			return OK;
		return info->PrivateRegister();
	}

	static DataTypeInitializer Get() { return &Init; }
};

template <typename T> struct PrivateInitInterfaceType<T, false>
{
	static DataTypeInitializer Get() { return nullptr; }
};

//----------------------------------------------------------------------------------------
/// NonvirtualInterfaceImplementation is an EntityDefinition object which provides the implementation of a non-virtual interface.
/// It is defined by MAXON_IMPLEMENTATION and MAXON_IMPLEMENTATION_REGISTER.
//----------------------------------------------------------------------------------------
class NonvirtualInterfaceImplementation
{
public:
	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceImplementation object and adds it to the definition list of the current translation unit.
	/// This constructor is used by MAXON_IMPLEMENTATION_REGISTER.
	/// @param[in] dummy							Dummy parameter, this is only needed to determine template parameter C.
	/// @param[in] clsName						Name of the implementation class.
	/// @param[in] ref								Corresponding interface reference of the module of this definition.
	/// @param[in] init								Pointer to a function which initializes the implementation's MTable with the implemented function pointers.
	/// @param[in] flags							Additional entity property flags,
	/// @param[in] unit								The translation unit containing the implementation.
	/// @param[in] file								Source file name.
	/// @tparam C											Implementation class.
	///
	/// @see MAXON_INTERFACE_NONVIRTUAL
	//----------------------------------------------------------------------------------------
	template <typename C> NonvirtualInterfaceImplementation(C* dummy, const Char* clsName, const NonvirtualInterfaceReference& ref, NonvirtualInterfaceReference::MTableInitializer init, EntityBase::FLAGS flags, TranslationUnit* unit, const Char* file)
		: _super(ref._super, unit, file, flags), _implementationClass(clsName), _initMTable(init),
			_initType(PrivateInitInterfaceType<typename C::Interface>::Get()),
			_initImplementation(&C::_PrivateInitImplementation), _freeImplementation(&C::_PrivateFreeImplementation), _nullValue(nullptr)
	{
	}

	const Generic* GetNullValue() const
	{
		return _nullValue;
	}

	const DataType* GetDataType() const
	{
		return &_type;
	}

private:
	EntityDefinition _super; ///< EntityDefinition base object.

	const Char* const _implementationClass; ///< Name of the implementation class (without namespace prefix).
	NonvirtualInterfaceReference::MTableInitializer const _initMTable; ///< Function to initialize the method table with the function pointers of the implementation.
	DataTypeInitializer _initType; ///< Initializer function for _type.
	DataType _type; ///< Type info for this interface.
	Result<const Generic*> (*_initImplementation) (); ///< This function is invoked to initialize the implementation before it's used the first time.
	void (*_freeImplementation) (); ///< This function is invoked after the last use of the implementation.
	const Generic* _nullValue; ///< The result of the invocation of _initImplementation, may be nullptr. This represents the null value of the implementation.
	friend class ObjectModel;
};


class ComponentPointerHandler : public PointerHandler
{
};

class SelfPointerHandler : public PointerHandler
{
public:
	static const VALUEKIND KIND = (VALUEKIND::POINTER_FLAGS | VALUEKIND::DEEP_CONSTNESS) & ~VALUEKIND::ZERO_INITIALIZED;
};

class SuperPointerHandler : public SelfPointerHandler
{
};

// This template is used for conversion operators from S to REF. Only if S matches REF regarding
// reference handling, the conversion operators shall exist.
template <typename S, typename S_HANDLER, typename HANDLER, typename REF, Bool CONST_THIS_NONCONST_PTR> struct RefConversionTarget
{
	using type = typename std::conditional<S::DIRECT_REF && std::is_same<HANDLER, S_HANDLER>::value, REF, DummyReturnType>::type;
};

// The specialization for the self-pointer always allows to convert to REF.
template <typename S, typename HANDLER, typename REF> struct RefConversionTarget<S, SelfPointerHandler, HANDLER, REF, false>
{
	using type = REF;
};

// But for the case of a const self-pointer and a REF which points to a non-const object we must not allow the conversion to REF.
template <typename S, typename HANDLER, typename REF> struct RefConversionTarget<S, SelfPointerHandler, HANDLER, REF, true>
{
	using type = DummyReturnType;
};


template <typename T, typename HANDLER, typename REFCLASS> struct DirectRefReferenceClassInfo
{
	using type = REFCLASS;
	using Component = T;

	template <typename TO> using HasBase = maxon::HasBase<T, TO>;
};

template <typename T, typename HANDLER> struct DirectRefReferenceClassInfo<T, HANDLER, void>
{
	using type = typename std::conditional<std::is_const<T>::value, typename T::ConstPtr, typename T::Ptr>::type;
	using Component = T;

	template <typename TO> using HasBase = maxon::HasBase<T, TO>;
};

template <typename T, typename C> struct DirectRefReferenceClassInfo<T, ComponentPointerHandler, C>
{
	using type = typename std::conditional<std::is_const<T>::value, typename C::ConstPtr, typename C::Ptr>::type;
	using Component = C;

	template <typename TO> using HasBase = typename C::template ComponentHasBase<typename std::remove_const<TO>::type>;
};

template <typename T, typename C> struct DirectRefReferenceClassInfo<T, SelfPointerHandler, C>
{
	using type = typename C::SelfPtr;
	using Component = C;

	template <typename TO> using HasBase = typename C::template ComponentHasBase<typename std::remove_const<TO>::type>;
};

template <typename C, typename BASE> struct SuperPtrComponentInfo;

template <typename T, typename C, typename BASE> struct DirectRefReferenceClassInfo<T, SuperPointerHandler, SuperPtrComponentInfo<C, BASE>>
{
	using type = typename BASE::SelfPtr;
	using Component = C;

	template <typename TO> using HasBase = typename BASE::template ComponentHasBase<typename std::remove_const<TO>::type>;
};


// used for RefBaseFunctions
template <typename T, typename HANDLER, typename REFCLASS_INFO> class DirectRef
{
public:
	using Info = DirectRefReferenceClassInfo<T, HANDLER, REFCLASS_INFO>;
	using ReferenceClass = typename Info::type;
	using Component = typename Info::Component;
	using ReferencedType = T;
	using ConstReferencedType = typename ConstIf<T, Bool(HANDLER::KIND & VALUEKIND::DEEP_CONSTNESS)>::type;
	using DirectlyReferencedType = T;
	using Handler = HANDLER;
	using BaseRefType = BaseRef<T, HANDLER>;
	static const Bool DIRECT_REF = true;
	static const Bool HAS_ERROR = false;
	using type = DirectRef;

	const ReferenceClass& PrivateGetRefMember() const
	{
		static_assert(ReferenceClass::DIRECT_REF && ReferenceClass::Handler::KIND == HANDLER::KIND
									&& std::is_const<ConstReferencedType>::value <= std::is_const<typename ReferenceClass::ReferencedType>::value,
									"Invalid reinterpret_cast.");
		return *reinterpret_cast<const ReferenceClass*>(this);
	}

	ReferenceClass& PrivateGetRefMember()
	{
		static_assert(ReferenceClass::DIRECT_REF && ReferenceClass::Handler::KIND == HANDLER::KIND
									&& std::is_const<ReferencedType>::value <= std::is_const<typename ReferenceClass::ReferencedType>::value,
									"Invalid reinterpret_cast.");
		return *reinterpret_cast<ReferenceClass*>(this);
	}

	T* GetPointer() { return *(T**) this; }
	ConstReferencedType* GetPointer() const { return *(T**) this; }
	const BaseRefType& GetBaseRef() const { return *reinterpret_cast<const BaseRefType*>(this); }
	BaseRefType& GetBaseRef() { return *reinterpret_cast<BaseRefType*>(this); }

	template <typename TO> using HasBase = typename Info::template HasBase<TO>;

	DirectRef& operator =(std::nullptr_t) { *reinterpret_cast<BaseRefType*>(this) = nullptr; return *this; }

	const ThreadReferencedError& GetErrorStorage() const
	{
		return *(const ThreadReferencedError*) this;
	}

	static std::nullptr_t GetWrapper()
	{
		return nullptr;
	}

	ResultRef<typename std::remove_const<T>::type> MakeWritable(Bool resetOnError = true)
	{
		return reinterpret_cast<BaseRefType*>(this)->MakeWritable(resetOnError);
	}

protected:
	void SetPointer(T* ptr) { *(T**) this = ptr; }
	void ResetPointer() { *reinterpret_cast<BaseRefType*>(this) = nullptr; }
};

template <typename REF> using RefMemberType = typename InheritConst<typename REF::ReferenceClass, REF>::type&;

template <typename SUPER> class ReferenceResultBase : public SUPER
{
public:
	using ReferenceClass = typename std::decay<typename SUPER::ValueType>::type;

	using SUPER::SUPER;

	using Handler = typename ReferenceClass::Handler;
	// We don't add a ReferencedType alias here to that a Result<SomeReference> isn't recognized as a reference.
	using PrivateReferencedType = typename ReferenceClass::ReferencedType;
	using type = ReferenceResultBase;
	using Component = PrivateReferencedType;
	static const Bool DIRECT_REF = false;

	ReferenceClass& PrivateGetRefMember()
	{
		return this->GetValue();
	}

	const ReferenceClass& PrivateGetRefMember() const
	{
		return this->GetValue();
	}

	/// @note Required for result chaining.
	static std::nullptr_t GetWrapper()
	{
		return nullptr;
	}

	/// @note Required for result chaining.
	PrivateReferencedType* GetPointer() const
	{
		return this->UncheckedGetValue().GetPointer();
	}

	/// @note Required for result chaining.
	ResultRef<typename std::remove_const<PrivateReferencedType>::type> MakeWritable(Bool resetOnError = true)
	{
		static_assert(MAXON_IS_COW_KIND(Handler::KIND), "MakeWritable must not be invoked for non-COW references.");
		return std::move(this->GetValue()).MakeWritable(resetOnError);
	}
};

namespace details
{
template <typename T> typename SFINAEHelper<std::true_type, decltype(std::declval<T>().IsPopulated())>::type TestForIsPopulatedOrIsEmptyFunction(OverloadRank2);
template <typename T> typename SFINAEHelper<std::true_type, decltype(std::declval<T>().IsEmpty())>::type TestForIsPopulatedOrIsEmptyFunction(OverloadRank1);
template <typename T> std::false_type TestForIsPopulatedOrIsEmptyFunction(OverloadRank0);
}

//----------------------------------------------------------------------------------------
/// RefBaseFunctions is used internally as base class for reference classes for interfaces.
/// RefBaseFunctions itself is just a class without any data members. Its subclasses have to add suitable data members.
/// RefBaseFunctions uses SUPER as base class, SUPER has to declare the function GetPointer() to obtain the pointer to the referenced object.
/// For example, if you use DirectRef for SUPER, then the reference class stores a pointer as its
/// first member which directly points to the referenced object. But you can also use
/// classes for SUPER which follow several indirections to reach the referenced object.
//----------------------------------------------------------------------------------------
template <typename SUPER> class RefBaseFunctions : public SUPER
{
public:
	const ThreadReferencedError& GetErrorStorage() const
	{
		return *(const ThreadReferencedError*) this;
	}

	template <typename S> using ResultFunctions = typename ReferenceResultBase<S>::PrivateReferencedType::template ReferenceFunctions<ReferenceResultBase<S>>::type;

	using Handler = typename SUPER::Handler;
	using ReferencedType = typename SUPER::ReferencedType;
	using ConstReferencedType = typename ConstIf<ReferencedType, Bool(Handler::KIND & VALUEKIND::DEEP_CONSTNESS)>::type;
	using PrivateReferencedType = ReferencedType;
	using type = RefBaseFunctions;
	static const Bool COW = MAXON_IS_COW_KIND(Handler::KIND);

	Bool operator ==(const ReferencedType* ptr) const { return RefCompare<COW, true>::IsEqual(this->GetPointer(), ptr); }
	Bool operator !=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::IsEqual(this->GetPointer(), ptr); }
	Bool operator <(const ReferencedType* ptr) const { return RefCompare<COW, true>::LessThan(this->GetPointer(), ptr); }
	Bool operator >(const ReferencedType* ptr) const { return RefCompare<COW, true>::LessThan(ptr, this->GetPointer()); }
	Bool operator <=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::LessThan(ptr, this->GetPointer()); }
	Bool operator >=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::LessThan(this->GetPointer(), ptr); }

	Bool operator ==(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator ==(static_cast<const ReferencedType*>(ptr)); }
	Bool operator !=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator !=(static_cast<const ReferencedType*>(ptr)); }
	Bool operator <(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator <(static_cast<const ReferencedType*>(ptr)); }
	Bool operator >(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator >(static_cast<const ReferencedType*>(ptr)); }
	Bool operator <=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator <=(static_cast<const ReferencedType*>(ptr)); }
	Bool operator >=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator >=(static_cast<const ReferencedType*>(ptr)); }

	Bool operator ==(std::nullptr_t) const { return this->operator ==((const ReferencedType*) nullptr); }
	Bool operator !=(std::nullptr_t) const { return this->operator !=((const ReferencedType*) nullptr); }

	UInt GetHashCode() const { return RefCompare<COW, true>::GetHashCode(this->GetPointer()); }

	template <typename T, typename = typename std::enable_if<!std::is_same<const T, const Object>::value && !std::is_same<const T, const ReferencedType>::value
																													 && SUPER::template HasBase<T>::value && std::is_const<T>::value >= std::is_const<ReferencedType>::value>::type>
	operator T*() { return reinterpret_cast<T*>(this->GetPointer()); }

	template <typename T, typename = typename std::enable_if<!std::is_same<const T, const Object>::value && !std::is_same<const T, const ReferencedType>::value
																													 && SUPER::template HasBase<T>::value && std::is_const<T>::value >= std::is_const<ConstReferencedType>::value>::type>
	operator T*() const { return reinterpret_cast<T*>(this->GetPointer()); }

	operator ReferencedType*() { return this->GetPointer(); }

	operator ConstReferencedType*() const { return this->GetPointer(); }

	static const Bool DERIVED_FROM_OBJECT = !std::is_same<const Object, const ReferencedType>::value && IsVirtualInterfaceType<ReferencedType>::value;

	operator typename std::conditional<DERIVED_FROM_OBJECT, typename InheritConst<Object, ReferencedType>::type*, const DummyReturnType&&>::type() { return this->GetPointer(); }

	operator typename std::conditional<DERIVED_FROM_OBJECT, typename InheritConst<Object, ConstReferencedType>::type*, const DummyReturnType&&>::type() const { return this->GetPointer(); }

	explicit operator Bool() const
	{
		static_assert(!(COW && decltype(maxon::details::TestForIsPopulatedOrIsEmptyFunction<typename SUPER::ReferenceClass>(OVERLOAD_MAX_RANK))::value),
									"For a copy-on-write reference with IsPopulated()- or IsEmpty()-function, conversion to Bool is not allowed as it would only check the pointer. You have to use IsPopulated() or IsEmpty().");
		return MAXON_LIKELY(this->GetPointer() != nullptr);
	}

	explicit operator Bool()
	{
		static_assert(!(COW && decltype(maxon::details::TestForIsPopulatedOrIsEmptyFunction<typename SUPER::ReferenceClass>(OVERLOAD_MAX_RANK))::value),
									"For a copy-on-write reference with IsPopulated()- or IsEmpty()-function, conversion to Bool is not allowed as it would only check the pointer. You have to use IsPopulated() or IsEmpty().");
		return MAXON_LIKELY(this->GetPointer() != nullptr);
	}

private:
	operator void*() = delete;
	operator void*() const = delete;
	ReferencedType& operator *() = delete;
	ConstReferencedType& operator *() const = delete;
	ReferencedType* operator ->() = delete;
	ConstReferencedType* operator ->() const = delete;

	// prevent pointer arithmetic on reference class
	void operator +(Int) = delete;
	void operator +(Int) const = delete;
	void operator -(Int) = delete;
	void operator -(Int) const = delete;
	void operator [](Int) = delete;
	void operator [](Int) const = delete;
};



template <typename S, VALUEKIND PTR_DEEP_ZERO> class ReferenceBaseCtorDtor : public S
{
public:
	using BaseRefType = typename S::BaseRefType;

	ReferenceBaseCtorDtor() : _object(nullptr)
	{
	}

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

	ReferenceBaseCtorDtor(const ReferenceBaseCtorDtor& src)
	{
		static_assert(!(PTR_DEEP_ZERO & VALUEKIND::DEEP_CONSTNESS), "Can't copy a reference with deep constness.");
		new (this) BaseRefType(reinterpret_cast<const BaseRefType&>(src));
	}

	ReferenceBaseCtorDtor& operator =(const ReferenceBaseCtorDtor& src)
	{
		static_assert(!(PTR_DEEP_ZERO & VALUEKIND::DEEP_CONSTNESS), "Can't copy a reference with deep constness.");
		reinterpret_cast<BaseRefType*>(this)->operator =(reinterpret_cast<const BaseRefType&>(src));
		return *this;
	}

	ReferenceBaseCtorDtor(ReferenceBaseCtorDtor&& src) : _object(src._object)
	{
		src._object = nullptr;
	}

	ReferenceBaseCtorDtor& operator =(ReferenceBaseCtorDtor&& src)
	{
		reinterpret_cast<BaseRefType*>(this)->operator =(std::move(reinterpret_cast<BaseRefType&>(src)));
		return *this;
	}

	~ReferenceBaseCtorDtor()
	{
		reinterpret_cast<BaseRefType*>(this)->~BaseRefType();
	}

private:
	typename S::ReferencedType* _object;
};


template <typename S> class ReferenceBaseCtorDtor<S, VALUEKIND::POINTER | VALUEKIND::ZERO_INITIALIZED> : public S
{
public:
	ReferenceBaseCtorDtor() : _object(nullptr)
	{
	}

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

private:
	typename S::ReferencedType* _object;
};

template <typename S> class ReferenceBaseCtorDtor<S, VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS> : public S
{
public:
	ReferenceBaseCtorDtor() = default;

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

	ReferenceBaseCtorDtor(const ReferenceBaseCtorDtor& src) = delete;
	ReferenceBaseCtorDtor& operator =(const ReferenceBaseCtorDtor& src) = delete;

private:
	typename S::ReferencedType* _object;
};


template <typename ST> class ReferenceBase : public ReferenceBaseCtorDtor<typename ST::type, ST::type::Handler::KIND & (VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS | VALUEKIND::ZERO_INITIALIZED)>
{
public:
	ReferenceBase() = default;
	ReferenceBase(const ReferenceBase&) = default;
	ReferenceBase& operator =(const ReferenceBase&) = default;
	ReferenceBase(ReferenceBase&&) = default;
	ReferenceBase& operator =(ReferenceBase&&) = default;

	using Super = ReferenceBaseCtorDtor<typename ST::type, ST::type::Handler::KIND & (VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS | VALUEKIND::ZERO_INITIALIZED)>;
	using ReferencedType = typename ST::type::ReferencedType;

	MAXON_IMPLICIT ReferenceBase(ReferencedType* ptr) : Super(DONT_INITIALIZE)
	{
		new (this) typename ST::type::BaseRefType(ptr);
	}

	//----------------------------------------------------------------------------------------
	/// Constructs a reference with a pointer forwarded from a memory allocation. The template
	/// parameter is used to avoid unnecessary conversion from ResultPtr<X> to ResultPtr<const X>.
	//----------------------------------------------------------------------------------------
	template <typename PTR> explicit ReferenceBase(ForwardResultPtr<PTR> ptr) : Super(DONT_INITIALIZE)
	{
		new (this) typename ST::type::BaseRefType(ptr);
	}

	MAXON_IMPLICIT ReferenceBase(std::nullptr_t) = delete;

	template <typename REF, typename = typename std::enable_if<!std::is_base_of<ReferenceBase, typename std::decay<REF>::type>::value && maxon::HasBase<typename std::decay<REF>::type::ReferencedType, ReferencedType>::value>::type> MAXON_IMPLICIT ReferenceBase(REF&& src) : Super(DONT_INITIALIZE)
	{
		new (this) typename ST::type::BaseRefType(std::forward<REF>(src));
	}

	ReferenceBase& operator =(ReferencedType* ptr)
	{
		reinterpret_cast<typename ST::type::BaseRefType*>(this)->operator =(ptr);
		return *this;
	}

	template <typename REF, typename = typename std::enable_if<!std::is_base_of<ReferenceBase, typename std::decay<REF>::type>::value && maxon::HasBase<typename std::decay<REF>::type::ReferencedType, ReferencedType>::value>::type> ReferenceBase& operator =(REF&& src)
	{
		reinterpret_cast<typename ST::type::BaseRefType*>(this)->operator =(std::forward<REF>(src));
		return *this;
	}

	ReferenceBase& operator =(std::nullptr_t)
	{
		reinterpret_cast<typename ST::type::BaseRefType*>(this)->operator =(nullptr);
		return *this;
	}

	static const typename ST::type::ReferenceClass& NullValue()
	{
		return GetPtrSizedZeroRef<typename ST::type::ReferenceClass>();
	}

	ResultRef<typename std::remove_const<ReferencedType>::type> MakeWritable(Bool resetOnError = !maxon::HasBase<ReferencedType, ErrorInterface>::value) { return this->GetBaseRef().MakeWritable(resetOnError); }
};


template <Bool HAS_ERROR, Bool RETURNS_THIS, typename T> struct ReferenceFunctionErrorReturnHelper;

template <typename T> struct ReferenceFunctionErrorReturnHelper<false, false, T>
{
	using ReturnType = T;

	template <typename REF> static T ReturnErrorOf(REF* ref)
	{
		return NullValue<T>();
	}

	template <typename REF> static T Return(REF* ref, const ThreadReferencedError& err)
	{
		return NullValue<T>();
	}
};

template <typename T> struct ReferenceFunctionErrorReturnHelper<false, false, Result<T>>
{
	using ReturnType = Result<T>;

	template <typename REF> static ReturnType ReturnErrorOf(REF* ref)
	{
		return ReturnType();
	}

	template <typename REF> static const ThreadReferencedError& Return(REF* ref, const ThreadReferencedError& err)
	{
		return err;
	}
};

template <typename T> struct ReferenceFunctionErrorReturnHelper<true, false, T>
{
	using ReturnType = T;

	template <typename REF> static const ThreadReferencedError& ReturnErrorOf(REF* ref)
	{
		return ref->GetErrorStorage();
	}

	template <typename REF> static const ThreadReferencedError& Return(REF* ref, const ThreadReferencedError& err)
	{
		return err;
	}
};


template <Bool HAS_ERROR, typename T> struct ReferenceFunctionErrorReturnHelper<HAS_ERROR, true, T>
{
	using ReturnType = T;

	template <typename REF> static T ReturnErrorOf(REF* ref)
	{
		return ref->PrivateGetRefMember();
	}

	template <typename REF> static T Return(REF* ref, const ThreadReferencedError& err)
	{
		return ref->PrivateGetRefMember();
	}

	template <typename REF> static T Return(REF* ref, const typename std::decay<T>::type&)
	{
		return ref->PrivateGetRefMember();
	}
};

template <Bool HAS_ERROR, typename T> struct ReferenceFunctionErrorReturnHelper<HAS_ERROR, true, Result<T>>
{
	using ReturnType = Result<T>;

	template <typename REF> static ReturnType ReturnErrorOf(REF* ref)
	{
		return ReturnType(ref->PrivateGetRefMember(), Result<void>(ref->GetErrorStorage()));
	}

	template <typename REF> static ReturnType Return(REF* ref, const ThreadReferencedError& err)
	{
		return ReturnType(ref->PrivateGetRefMember(), Result<void>(err));
	}
};


/// @endcond

//----------------------------------------------------------------------------------------
/// This macro can be used within non-static member functions to statically assert that the given parameter Name
/// matches the surrounding class.
/// @param[in] Name								Unqualified name of the class.
//----------------------------------------------------------------------------------------
#define MAXON_CHECK_CLASS(Name) \
	static_assert(std::is_same<const Name, const PRIVATE_MAXON_ALLOC_TYPENAME std::remove_pointer<decltype(this)>::type>::value, "Macro parameter " #Name " doesn't match class.")


//----------------------------------------------------------------------------------------
/// Use this macro to mark a member function of an interface as an interface method.
/// For simple virtual interfaces, only non-static member functions can be used as interface methods.
/// Example:
/// @code
/// MAXON_METHOD Int GetLength() const;
/// @endcode
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_METHOD

//----------------------------------------------------------------------------------------
/// Use this macro to mark a member function of an interface as a function which shall be added
/// to the reference classes. Unlike MAXON_METHOD, the function invocation will not be routed
/// through the interface; you have to provide a normal C++ function definition.
/// All kinds of interfaces allow both static and non-static functions.
///
/// MAXON_FUNCTION is very useful if you need a function pair of which one function is const and the other non-const,
/// but besides constness they do the same so that a single method suffices:
/// @code
/// MAXON_METHOD const MyElement& GetElement() const;
/// MAXON_FUNCTION MyElement& GetElement() { return MAXON_NONCONST_COUNTERPART(GetElement()); }
/// @endcode
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_FUNCTION


//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, and that no reference class shall be created for the interface.
/// This can be used for interfaces which don't have any non-static methods, or for interfaces which shall be accessed
/// through custom-coded wrapper classes which are then also responsible for the proper release of the objects.
/// MAXON_REFERENCE_NONE cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_NONE(DUMMY) \
	public: \
		void AddReference() const { } \
		void RemoveReference() const { } \
		template <typename FREE, typename CAST> void PrivateRemoveReference() const { } \
	private:

#define PRIVATE_MAXON_REFERENCE_NONE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NONE
#define PRIVATE_MAXON_REFERENCE_NONE_COPY
#define PRIVATE_MAXON_REFERENCE_NONE_NONCONST

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, but that a reference class shall be created for the interface. The reference
/// class will behave like an ordinary pointer. For the interface design and its usage, one has to
/// take care of the proper release of the objects.
/// MAXON_REFERENCE_POINTER cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_POINTER(DUMMY) \
	public: \
		template <typename S> struct ReferenceFunctions; \
		template <typename S> class ReferenceFunctionsImpl; \
		template <typename S> class COWReferenceFunctionsImpl; \
		template <typename S> class ConstReferenceFunctionsImpl; \
		DOXYGEN_SWITCH(, template <typename REF> class ReferenceFunctionsImplDoxy; template <typename REF> class COWReferenceFunctionsImplDoxy; template <typename REF> class ConstReferenceFunctionsImplDoxy;) \
		struct ReferenceClassHelper; \
		class Reference; \
		using Ptr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		void AddReference() const { } \
		void RemoveReference() const { } \
		template <typename FREE, typename CAST> void PrivateRemoveReference() const { } \
	private:

#define PRIVATE_MAXON_REFERENCE_POINTER_FLAGS maxon::EntityBase::FLAGS::REFERENCE_POINTER
#define PRIVATE_MAXON_REFERENCE_POINTER_COPY
#define PRIVATE_MAXON_REFERENCE_POINTER_NONCONST

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, but that a reference class shall be created for the interface. The reference
/// class will behave like an ordinary pointer to a const object. For the interface design and its usage, one has to
/// take care of the proper release of the objects.
/// MAXON_REFERENCE_CONST_POINTER cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_CONST_POINTER(DUMMY) MAXON_REFERENCE_POINTER(DUMMY)

#define PRIVATE_MAXON_REFERENCE_CONST_POINTER_FLAGS maxon::EntityBase::FLAGS::REFERENCE_CONST_POINTER
#define PRIVATE_MAXON_REFERENCE_CONST_POINTER_COPY
#define PRIVATE_MAXON_REFERENCE_CONST_POINTER_NONCONST

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if non-const methods shall operate on the original object
/// instead of making a copy. This is usually used for first-class objects which have an identity
/// rather than just a value. The corresponding reference class is assumed to be the name of the interface
/// with the Interface postfix replaced by Ref (e.g., InputStreamRef for the interface InputStreamInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_NORMAL(DUMMY) \
	public: \
		template <typename S> struct ReferenceFunctions; \
		template <typename S> class ReferenceFunctionsImpl; \
		template <typename S> class COWReferenceFunctionsImpl; \
		template <typename S> class ConstReferenceFunctionsImpl; \
		DOXYGEN_SWITCH(, template <typename REF> class ReferenceFunctionsImplDoxy; template <typename REF> class COWReferenceFunctionsImplDoxy; template <typename REF> class ConstReferenceFunctionsImplDoxy;) \
		struct ReferenceClassHelper; \
		class Reference; \
		using Ptr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		static inline void Free(const Interface* object); \
		template <typename FREE, typename CAST> void PrivateRemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::System::GetReferenceCounter(this).Dec() == true)) \
					FREE::Free(static_cast<const CAST*>(this)); \
		} \
		friend class maxon::StrongRefHandler; \
		friend class maxon::StrongCOWRefHandler; \
	protected:	\
		void RemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::System::GetReferenceCounter(this).Dec() == true)) \
				Free(this); \
		} \
	private:

#define PRIVATE_MAXON_REFERENCE_NORMAL_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NORMAL
#define PRIVATE_MAXON_REFERENCE_NORMAL_COPY
#define PRIVATE_MAXON_REFERENCE_NORMAL_NONCONST

//----------------------------------------------------------------------------------------
/// This reference type is similar to MAXON_REFERENCE_NORMAL, with the difference that references
/// can only be moved and not copied. Note that while semantically this is equivalent to a @c UniqueRef,
/// internally the object still uses the reference-counted implementation, with copying disabled.
/// Hence, conversions from/to UniqueRef are not possible.
///
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_UNIQUE(DUMMY) \
	public: \
		template <typename S> struct ReferenceFunctions; \
		template <typename S> class ReferenceFunctionsImpl; \
		template <typename S> class COWReferenceFunctionsImpl; \
		template <typename S> class ConstReferenceFunctionsImpl; \
		DOXYGEN_SWITCH(, template <typename REF> class ReferenceFunctionsImplDoxy; template <typename REF> class COWReferenceFunctionsImplDoxy; template <typename REF> class ConstReferenceFunctionsImplDoxy;) \
		struct ReferenceClassHelper; \
		class Reference; \
		using Ptr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		static inline void Free(const Interface* object); \
		template <typename FREE, typename CAST> void PrivateRemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::System::GetReferenceCounter(this).Dec() == true)) \
					FREE::Free(static_cast<const CAST*>(this)); \
		} \
		friend class maxon::StrongRefHandler; \
		friend class maxon::StrongCOWRefHandler; \
	protected:	\
		void RemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::System::GetReferenceCounter(this).Dec() == true)) \
				Free(this); \
		} \
	private:

#define PRIVATE_MAXON_REFERENCE_UNIQUE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NORMAL
#define PRIVATE_MAXON_REFERENCE_UNIQUE_COPY
#define PRIVATE_MAXON_REFERENCE_UNIQUE_NONCONST

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if only const methods of the interface shall be carried over
/// to the reference class. This is usually used for stateless objects which, once initialized,
/// provide their relevant functionality through const methods (e.g., IoHandlerInterface).
/// The corresponding reference class is assumed to be the name of the interface
/// with the Interface postfix removed (e.g., IoHandler for the interface IoHandlerInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_CONST(DUMMY) MAXON_REFERENCE_NORMAL(DUMMY)

#define PRIVATE_MAXON_REFERENCE_CONST_FLAGS maxon::EntityBase::FLAGS::REFERENCE_CONST
#define PRIVATE_MAXON_REFERENCE_CONST_COPY
#define PRIVATE_MAXON_REFERENCE_CONST_NONCONST class NonConstRef;

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if the reference class shall have copy-on-write semantics.
/// This means that when a non-const method is invoked through a reference and there are further references,
/// a copy of the original object is made, and the non-const method is invoked on the copy.
/// Thus, the further references aren't affected by potential modifications of the non-const method.
/// This is usually used for value types (second-class objects) where only the value is important such as String.
/// The corresponding reference class is assumed to be the name of the interface
/// without the Interface postfix (e.g., String for the interface StringInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_COPY_ON_WRITE(DUMMY) MAXON_REFERENCE_NORMAL(DUMMY)

#define PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_COPY_ON_WRITE
#define PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_COPY static inline Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION); static inline Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, const Interface& o);
#define PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_NONCONST class NonConstRef;

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if the reference class shall have always-copy-on-write semantics.
/// In contrast to MAXON_REFERENCE_COPY_ON_WRITE, this also makes a copy of the object if there is no other
/// reference to the object, so that non-const methods, invoked through the reference class,
/// will never modify an existing object.
/// In other words: If the refcount == 1 then a call to a set function will always duplicate the object.
/// The corresponding reference class is assumed to be the name of the interface
/// without the Interface postfix (e.g., String for the interface StringInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE(DUMMY) MAXON_REFERENCE_NORMAL(DUMMY)

#define PRIVATE_MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_ALWAYS_COPY_ON_WRITE
#define PRIVATE_MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE_COPY PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_COPY
#define PRIVATE_MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE_NONCONST class NonConstRef;


//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_REFERENCE_CLASS if you want to add further code to the automatically
/// generated non-const reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will not be part
/// of the generated const reference class or of the generated copy-on-write reference class.
/// Example:
/// @code
///	class DataFormatBaseReaderInterface : MAXON_INTERFACE_BASES(DataDictionaryObjectInterface)
///	{
///		MAXON_INTERFACE(DataFormatBaseReaderInterface, MAXON_REFERENCE_NORMAL, "net.maxon.interface.dataformatbasereader");
///
///	public:
///		MAXON_METHOD Result<void> CloseInput();
///
///		MAXON_ADD_TO_REFERENCE_CLASS(
///		Result<void> ResetMaybeCloseInput()
///		{
///			Result<void> res = OK;
///			if (this->GetPointer())
///			{
///				if (System::GetReferenceCounter(this->GetPointer()) == 1)
///					res = this->GetPointer()->CloseInput();
///				this->ResetPointer();
///			}
///			return res;
///		}
///		);
///		...
///	};
/// @endcode
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_CONST_REFERENCE_CLASS
/// @see MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_REFERENCE_CLASS(...)

//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS if you want to add further code to the automatically
/// generated copy-on-write reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will not be part
/// of the generated const reference class or of the generated non-const reference class.
/// For an example see MAXON_ADD_TO_REFERENCE_CLASS.
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_REFERENCE_CLASS
/// @see MAXON_ADD_TO_CONST_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS(...)

//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_CONST_REFERENCE_CLASS if you want to add further code to the automatically
/// generated const reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will also be part
/// of the generated non-const reference class and the generated copy-on-write reference class.
/// For an example see MAXON_ADD_TO_REFERENCE_CLASS.
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_REFERENCE_CLASS
/// @see MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_CONST_REFERENCE_CLASS(...)


//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_NONVIRTUAL marks a class declaration as a non-virtual interface declaration. Non-virtual
/// interfaces are used to separate code into a published interface and its internal implementation.
/// The implementation may reside in a different module as code which makes use of the interface,
/// and the whole mechanism is compatible among different compilers.
///
/// @ref nvinterfaces describes the declaration and implementation of non-virtual interfaces in detail.
/// An example is the declaration of StringInterface:
/// @code
/// class Application
/// {
/// 	MAXON_INTERFACE_NONVIRTUAL(Application, MAXON_REFERENCE_NONE, "net.maxon.interface.application");
/// public:
/// 	static MAXON_METHOD Result<Url> GetUrl(APPLICATION_URLTYPE urlType);
/// 	...
/// };
/// @endcode
/// Non-virtual interfaces must not specify a base class unless you use MAXON_INTERFACE_NONVIRTUAL_DERIVED
/// instead of MAXON_INTERFACE_NONVIRTUAL.
/// Non-virtual interfaces have to be implemented by another class using MAXON_IMPLEMENTATION.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @param[in] ID									The unique identifier of the interface.
/// @see @ref nvinterfaces
/// @see MAXON_METHOD
/// @see MAXON_FUNCTION
/// @see MAXON_INTERFACE_NONVIRTUAL_DERIVED
/// @see MAXON_INTERFACE
///
/// @note It is recommended to use virtual interfaces (MAXON_INTERFACE) instead of non-virtual ones unless
/// the interface consists only of static methods.
///
/// @note The macro itself leaves incomplete code which is completed by the source processor.
/// So you have to place the macro in a header file, because the source processor only scans
/// header files, and you have to include the generated hxx files in the header file.
/// MAXON_INTERFACE_NONVIRTUAL must be placed somewhere before the \#include of the first hxx file.
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_NONVIRTUAL(Name, REFKIND, ID) \
	public: \
		using Interface = Name; \
		using BaseInterface = Name; \
		static maxon::NonvirtualInterfaceReference _interface; \
		struct MTable; \
		template <typename C> class Wrapper; \
		using IsNonvirtualInterfaceType = std::true_type; \
		using IsAllocType = std::true_type; \
		class Null; \
		class Unresolved; \
		static const Name* NullValuePtr() { return (const Name*) _interface.GetNullValue(); } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateNullValueHelper(); \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_COPY \
		PRIVATE_##REFKIND##_NONCONST \
	protected: \
		Name() { } \
		~Name() { MAXON_CHECK_CLASS(Name); MAXON_ASSERT_STANDARD_LAYOUT(Name); } \
	private: \
		void operator =(const volatile Name&); \
		Name(const Name&); \
		REFKIND(DUMMY)

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_NONVIRTUAL_DERIVED marks a class declaration as a non-virtual interface declaration
/// which is derived from another such declaration (i.e., either MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE_NONVIRTUAL_DERIVED).
/// You have to use the base interface as base class in the class declaration.
/// The derived interface inherits all methods from its base interface. You cannot use more than
/// one direct base interface. Example:
/// @code
/// class MacroPortInterface : public AttributedObjectInterface
/// {
/// 	MAXON_INTERFACE_NONVIRTUAL_DERIVED(MacroPortInterface, MAXON_REFERENCE_NORMAL, "net.maxon.interface.macroport");
///   ...
/// };
/// @endcode
/// Derived non-virtual interfaces have to be implemented by another class using MAXON_IMPLEMENTATION_DERIVED.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @param[in] ID									The unique identifier of the interface.
/// @see @ref nvinterfaces
/// @see MAXON_INTERFACE_NONVIRTUAL
///
/// @warning As one can act (through an upcasted pointer to the base interface) on the implementation
/// of the derived interface as if it was the implementation of the base interface, the
/// implementation of the derived interface should derive from the implementation of the base interface
/// (at least both have to be compatible).
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_NONVIRTUAL_DERIVED(Name, REFKIND, ID) \
	public: \
		using Interface = Name; \
		static NonvirtualInterfaceReference _interface; \
		struct MTable; \
		template <typename C> class Wrapper; \
		template <typename S> struct ReferenceFunctions; \
		template <typename S> class ReferenceFunctionsImpl; \
		template <typename S> class COWReferenceFunctionsImpl; \
		template <typename S> class ConstReferenceFunctionsImpl; \
		DOXYGEN_SWITCH(, template <typename REF> class ReferenceFunctionsImplDoxy; template <typename REF> class COWReferenceFunctionsImplDoxy; template <typename REF> class ConstReferenceFunctionsImplDoxy;) \
		struct ReferenceClassHelper; \
		class Reference; \
		using Ptr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		class Null; \
		class Unresolved; \
		static const Name* NullValuePtr() { return (const Name*) _interface.GetNullValue(); } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateNullValueHelper(); \
		static inline void Free(const Name*); \
		void RemoveReference() const { PrivateRemoveReference<Name, Name>(); } \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_COPY \
		PRIVATE_##REFKIND##_NONCONST \
	protected: \
		Name() { } \
		~Name() { MAXON_CHECK_CLASS(Name); } \
	private: \
		void operator =(const volatile Name&); \
		Name(const Name&);

#define _MAXON_IMPLEMENTATION_BASICS(C) \
	public: \
		using MTable = std::false_type; /* for the IsInterface detection */ \
		static C* Get(Interface* object) { return (C*) object; } \
		static const C* Get(const Interface* object) { return (const C*) object; } \
		static const C* GetOrNullValue(const Interface* object) { return object ? (const C*) object : _nullValue; } \
	private: \
		template <typename T> friend void maxon::Destruct(const T* object); \
		static maxon::Result<const maxon::Generic*> _PrivateInitImplementation(); \
		static void _PrivateFreeImplementation(); \
		friend class maxon::NonvirtualInterfaceImplementation; \
		friend class maxon::StrongRefHandler; \
template <typename D, typename B, maxon::Int HAS_BASE_OR_SAME> friend class maxon::details::HasBaseHelper; \
		class _Wrapper; \
		using Implementation = C; \
		static C* _nullValue;

#define MAXON_IMPLEMENTATION_BASICS(C, I) \
	public: \
		using Interface = I; \
		using PrivateInterface = I; \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return (Interface*) this; } \
		const Interface* ToInterface() const { return (const Interface*) this; } \
		_MAXON_IMPLEMENTATION_BASICS(C)

#define _MAXON_IMPLEMENTATION(C, cast) \
		_MAXON_IMPLEMENTATION_BASICS(C) \
	public: \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return cast<Interface*>(this); } \
		const Interface* ToInterface() const { return cast<const Interface*>(this); } \
		using IsNonvirtualInterfaceType = std::false_type; \
		using IsAllocType = std::false_type; \
		using IsImplementationType = std::true_type; \
		static void Free(const volatile BaseInterface* object) { maxon::System::FreeWithDestructor((const C*) object, &maxon::Destruct<C>); } \
		template <typename D> static typename maxon::SFINAEHelper<Interface*, typename D::SourceLocationMarker>::type Alloc(const D& allocLocation) { return cast<Interface*>(MAXON_SAFE_PLACEMENT_NEW (maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD)) typename maxon::SFINAEHelper<C, D>::type); } \
		template <typename A1> static Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, A1&& a1) { return cast<Interface*>(maxon::ObjectConstructor<C, maxon::TestForCopyFromMember<C>::isSupported>::Alloc(maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD), std::forward<A1>(a1))); } \
		template <typename A1, typename A2, typename... ARGS> static Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, A1&& a1, A2&& a2, ARGS&&... args) { return cast<Interface*>(MAXON_SAFE_PLACEMENT_NEW(maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD)) C(std::forward<A1>(a1), std::forward<A2>(a2), std::forward<ARGS>(args)...)); } \
		using BaseInterface::NullValuePtr;


//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION has to be used within an implementation class for a non-virtual interface
/// (declared with MAXON_INTERFACE_NONVIRTUAL). For more details, see @ref nvinterfaces.
/// An example is the implementation of StringInterface by a class XStringImpl:
/// @code
/// class XStringImpl : private StringInterface
/// {
///   MAXON_IMPLEMENTATION(XStringImpl);
/// public:
///   XStringImpl() { }
///   XStringImpl(const XStringImpl& str) { Insert(0, &str); }
///   Int GetLength() const { return _txt.GetCount(); }
///   ...
/// };
/// MAXON_IMPLEMENTATION_REGISTER(XStringImpl);
/// @endcode
/// Don't forget to add MAXON_IMPLEMENTATION_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION(C) \
	public: \
		using PrivateInterface = Interface; \
		_MAXON_IMPLEMENTATION(C, static_cast)
// the PrivateInterface type alias above is needed because C::Interface is inaccessible from the outside when C doesn't inherit publicly from Interface, and a using Interface::Interface doesn't work

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_DERIVED has to be used within an implementation class for a derived non-virtual interface
/// (declared with MAXON_INTERFACE_NONVIRTUAL_DERIVED). The implementation class should derive from the implementation
/// class of the base interface. For more details, see @ref nvinterfaces.
/// An example is the implementation of MacroPortInterface by a class Port (AttributedObject implements
/// the base interface AttributedObjectInterface):
/// @code
/// class Port : public AttributedObject
/// {
/// 	MAXON_IMPLEMENTATION_DERIVED(Port, MacroPortInterface);
/// public:
///   ...
/// };
/// MAXON_IMPLEMENTATION_REGISTER(Port);
/// @endcode
/// Don't forget to add MAXON_IMPLEMENTATION_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @param[in] I									Name of the derived interface which C implements.
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_DERIVED(C, I) \
	public: \
		using Interface = I; \
		using PrivateInterface = I; \
		_MAXON_IMPLEMENTATION(C, reinterpret_cast)

// TODO: (Ole) in the *.dox docu it should be mentioned how return values work (that there needs to be a NullValue implementation) and how to add those if you're not using the basic datatypes
// TODO: (Ole) it should be mentioned that in interface headers "Int* bla" works, but "Int *bla" doesn't
// TODO: (Ole) also it should be mentioned that commenting out lines doesn't work in interface headers - however #if 0 / #endif works
// TODO: (Ole) it should also be mentioned that includes in interface headers need to be chosen extremely carefully as otherwise unnecessary or unwanted dependencies are generated; forwards should be used whereever possible

#ifdef MAXON_COMPILER_MSVC
// special code for MSVC, compiler crash reported as Connect bug #940118
template <typename C> inline typename std::enable_if<std::is_same<decltype(C::NullValue()), C*>::value, C*>::type ImplementationCreateNullValue(OverloadRank3)
{
	return C::NullValue();
}
#else
// if an interface implementation has a NullValue function, use this
template <typename C> inline typename NullValueDetector<C*, &C::NullValue>::type ImplementationCreateNullValue(OverloadRank3)
{
	return C::NullValue();
}
#endif

#ifdef MAXON_COMPILER_INTEL
	#define COW_KIND_SFINAE typename SFINAEHelper<C*, typename C::PrivateInterface::Reference::Handler::COWMarker>::type
#elif defined(MAXON_COMPILER_MSVC)
	#define COW_KIND_SFINAE typename SFINAEHelper<C*, typename C::PrivateInterface::Reference::Handler::COWMarker>::type
#else
	#define COW_KIND_SFINAE typename std::enable_if<MAXON_IS_COW_KIND(C::PrivateInterface::Reference::Handler::KIND), C*>::type
#endif

// otherwise, use a default-constructed object if the interface has a COW reference class
template <typename C> inline COW_KIND_SFINAE ImplementationCreateNullValue(OverloadRank2)
{
	static_assert(MAXON_IS_COW_KIND(C::PrivateInterface::Reference::Handler::KIND), "Compiler bug, non-COW references shouldn't use this overload");
	C* o = (C*) PrivateSystemAlloc(SIZEOF(C));
	if (o)
	{
		new (o) C();
		StrongRefHandler::AddReference(o->ToInterface());
	}
	return o;
}

// otherwise, return nullptr if there is a non-COW reference class
template <typename C> inline typename SFINAEHelper<C*, typename C::PrivateInterface::Reference::Handler>::type ImplementationCreateNullValue(OverloadRank1)
{
	static_assert(!MAXON_IS_COW_KIND(C::PrivateInterface::Reference::Handler::KIND), "Compiler bug, COW references shouldn't use this overload");
	return nullptr;
}

// otherwise, use nullptr as null value for interfaces without reference class
template <typename C> inline C* ImplementationCreateNullValue(OverloadRank0)
{
	return nullptr;
}

#ifdef MAXON_COMPILER_MSVC
// special code for MSVC, compiler crash reported as Connect bug #940118
template <typename C> inline typename std::enable_if<std::is_same<decltype(C::NullValue()), C*>::value, C*>::type ImplementationDestroyNullValue(const C*, OverloadRank3)
{
	return nullptr;
}
#else
// now the same for the proper destruction of the null value
template <typename C> inline typename NullValueDetector<C*, &C::NullValue>::type ImplementationDestroyNullValue(const C*, OverloadRank3)
{
	return nullptr;
}
#endif

class PrivateDummyFree
{
public:
	static void Free(const void*) { }
};

template <typename C> inline COW_KIND_SFINAE ImplementationDestroyNullValue(const C* o, OverloadRank2)
{
	o->ToInterface()->template PrivateRemoveReference<PrivateDummyFree, const void>();
	o->~C();
	PrivateSystemFree(const_cast<C*>(o));
	return nullptr;
}

template <typename C> inline void ImplementationDestroyNullValue(const C*, OverloadRank0)
{
}

#if !defined(MAXON_API) || defined(DOXYGEN)

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_REGISTER completes the implementation of a non-virtual interface.
/// It has to be used below the declaration of the implementation class (see MAXON_IMPLEMENTATION).
///
/// @param[in] C									Name of the implementation class.
/// @param[in] ...								Additional flags for the NonvirtualInterfaceImplementation such as EntityBase::FLAGS::EXPLICIT.
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_REGISTER(C, ...) \
	MAXON_UNIT_REGISTER_CHECK("MAXON_IMPLEMENTATION_REGISTER"); \
	class C::_Wrapper : public C::Interface::Wrapper<C> \
	{ \
		static maxon::NonvirtualInterfaceImplementation _implementation; \
		friend class ObjectModel; \
	}; \
	maxon::NonvirtualInterfaceImplementation C::_Wrapper::_implementation((C*) nullptr, #C, C::Interface::_interface, (maxon::NonvirtualInterfaceReference::MTableInitializer) &C::Interface::MTable::Init<C::_Wrapper>, C::Interface::REFERENCE_KIND | maxon::EntityBase::FLAGS(__VA_ARGS__), &maxon::g_translationUnit, __FILE__); \
	C* C::_nullValue; \
	maxon::Result<const maxon::Generic*> C::_PrivateInitImplementation() \
	{ \
		_nullValue = maxon::ImplementationCreateNullValue<C>( OVERLOAD_MAX_RANK); \
		using namespace maxon::defaultimplementation; \
		maxon::Result<void> res = InitImplementation(); \
		if (res == maxon::FAILED) return maxon::Result<const maxon::Generic*>(nullptr, std::move(res)); \
		return (const maxon::Generic*) _nullValue; \
	} \
	void C::_PrivateFreeImplementation() \
	{ \
		using namespace maxon::defaultimplementation; FreeImplementation(); \
		maxon::ImplementationDestroyNullValue<C>(_nullValue, OVERLOAD_MAX_RANK); \
	}

#endif

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_SIMPLE_VIRTUAL marks a class declaration as a simple virtual interface declaration.
/// Unlike true virtual interfaces (MAXON_INTERFACE), simple virtual interfaces only
/// support tree-like inheritance (no multiple inheritance), and they don't support adapters between different versions.
/// They have less overhead for method invocations, so you should use simple virtual interfaces
/// for performance-critical low-level purposes, where the interface is unlikely to change often.
///
/// @ref svinterfaces describes the declaration and implementation of simple virtual interfaces in detail.
/// As an example, consider:
/// @code
/// class SimpleInterface
/// {
/// 	MAXON_INTERFACE_SIMPLE_VIRTUAL(SimpleInterface, MAXON_REFERENCE_NORMAL);
/// public:
/// 	MAXON_METHOD void DoSomething(Int index);
/// };
/// @endcode
/// You can derive from simple virtual interfaces using MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL.
///
/// Simple virtual interfaces can be implemented by several classes.
/// An implementation class has to derive from the interface and to contain MAXON_IMPLEMENTATION_SIMPLE,
/// and in its constructors it has to pass the static @c _clsMTable member declared by MAXON_IMPLEMENTATION_SIMPLE to the constructor
/// of the base interface. Finally you have to use MAXON_IMPLEMENTATION_REGISTER_SIMPLE behind the
/// class declaration to construct the vtable:
/// @code
/// class SimpleImpl : private SimpleInterface
/// {
/// 	MAXON_IMPLEMENTATION_SIMPLE(SimpleImpl);
/// public:
/// 	SimpleImpl() : SimpleInterface(_clsMTable) { }
/// 	void DoSomething(Int index) { }
/// };
///
/// MAXON_IMPLEMENTATION_REGISTER_SIMPLE(SimpleImpl);
/// @endcode
/// Simple virtual interfaces can be class templates (all other kinds of interfaces can't).
/// In this case you have to prefix the registration as in
/// @code
/// template <typename ARRAY> MAXON_IMPLEMENTATION_REGISTER_SIMPLE(ArrayImpl<ARRAY>);
/// @endcode
///
/// Simple virtual interfaces can't have static methods, but they may have static functions
/// (marked with MAXON_FUNCTION).
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @see @ref svinterfaces
/// @see MAXON_METHOD
/// @see MAXON_FUNCTION
/// @see MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL
/// @see MAXON_IMPLEMENTATION_SIMPLE
/// @see MAXON_IMPLEMENTATION_REGISTER_SIMPLE
/// @see MAXON_INTERFACE
///
/// @note The macro itself leaves incomplete code which is completed by the source processor.
/// So you have to place the macro in a header file, because the source processor only scans
/// header files, and you have to include the generated hxx files in the header file.
/// MAXON_INTERFACE_SIMPLE_VIRTUAL must be placed somewhere before the \#include of the first hxx file.
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_SIMPLE_VIRTUAL(Name, REFKIND) \
	public: \
		using Interface = Name; \
		struct MTable; \
		template <typename C> class Wrapper; \
		static std::nullptr_t NullValuePtr() { return nullptr; } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateNullValueHelper(); \
		using IsAllocType = std::true_type; \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_NONCONST \
	protected: \
		Name(const MTable& vtable) : _vtable(&vtable) { } \
		~Name() { MAXON_CHECK_CLASS(Name); } \
		const MTable* MAXON_INTERFACE_SIMPLE_VIRTUAL_CONST_VTABLE_POINTER _vtable; \
		REFKIND(DUMMY) \
	private: \
		MAXON_DISALLOW_COPY_AND_ASSIGN(Name);


// needed for the array, set and map interfaces
#if defined(MAXON_COMPILER_MSVC) || defined(MAXON_COMPILER_GCC)
	#define CPP_853_HACK // MSVC and GCC have a bug regarding C++11 8.5.3 (see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57610)

	#define CPP_853_HACK_MAXON_INTERFACE_SIMPLE_VIRTUAL(Name, REFKIND) \
		public: \
			using Interface = Name; \
			struct MTable; \
			template <typename C> class Wrapper; \
			static std::nullptr_t NullValuePtr() { return nullptr; } \
			template <typename DUMMY> static inline maxon::Int PrivateInstantiateNullValueHelper(); \
			using IsAllocType = std::true_type; \
			static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
			PRIVATE_##REFKIND##_NONCONST \
		protected: \
			Name(const MTable& vtable) : _vtable(&vtable) { } \
			const MTable* MAXON_INTERFACE_SIMPLE_VIRTUAL_CONST_VTABLE_POINTER _vtable; \
			REFKIND(DUMMY) \
		private: \
			void operator =(const Name&);
#endif


#define MAXON_INTERFACE_SIMPLE_VIRTUAL_CONST_VTABLE_POINTER const

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL marks a class declaration as a simple virtual interface declaration
/// which is derived from another such declaration (i.e., declared with MAXON_INTERFACE_SIMPLE_VIRTUAL
/// or MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL).
/// You have to use the base interface as base class in the class declaration.
/// The derived interface inherits all methods from its base interface. You cannot use more than
/// one direct base interface. Example:
/// @code
/// class DerivedSimpleInterface : private SimpleInterface
/// {
/// 	MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL(DerivedSimpleInterface, MAXON_REFERENCE_NORMAL);
/// public:
/// 	MAXON_METHOD void DoSomethingElse();
/// };
/// @endcode
/// The implementation of a derived simple virtual interface is the same as for a
/// non-derived simple virtual interface.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_DERIVED_SIMPLE_VIRTUAL(Name, REFKIND) \
	public: \
		using Interface = Name; \
		struct MTable; \
		template <typename C> class Wrapper; \
		template <typename S> struct ReferenceFunctions; \
		template <typename S> class ReferenceFunctionsImpl; \
		template <typename S> class COWReferenceFunctionsImpl; \
		template <typename S> class ConstReferenceFunctionsImpl; \
		DOXYGEN_SWITCH(, template <typename REF> class ReferenceFunctionsImplDoxy; template <typename REF> class COWReferenceFunctionsImplDoxy; template <typename REF> class ConstReferenceFunctionsImplDoxy;) \
		struct ReferenceClassHelper; \
		class Reference; \
		using Ptr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::ReferenceBase<ReferenceFunctions<maxon::RefBaseFunctions<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateNullValueHelper(); \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_NONCONST \
	protected: \
		inline Name(const MTable& vtable); \
		~Name() { MAXON_CHECK_CLASS(Name); } \
	private: \
		MAXON_DISALLOW_COPY_AND_ASSIGN(Name);


//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_SIMPLE has to be used in the implementation of a simple
/// virtual interface. It defines the necessary members for such an implementation.
/// For an example, see MAXON_INTERFACE_SIMPLE_VIRTUAL.
///
/// Don't forget to add MAXON_IMPLEMENTATION_REGISTER_SIMPLE below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_SIMPLE(C, ...) \
	public: \
		using IsAllocType = std::false_type; \
		using MTable = std::false_type; /* for the IsInterface detection */ \
		static void Free(const C* o) { DeleteObj(o); } \
		static const __VA_ARGS__ Interface::MTable _clsMTable; \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return this; } \
		const Interface* ToInterface() const { return this; } \
		static C* Get(Interface* object) { return (C*) object; } \
		static const C* Get(const Interface* object) { return (const C*) object; }

// TODO: (Ole) remove __VA_ARGS__ hack when MSVC allows typename outside of templates

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_REGISTER_SIMPLE completes the implementation of a simple virtual interface.
/// It has to be used below the declaration of the implementation class (see MAXON_INTERFACE_SIMPLE_VIRTUAL).
///
/// @param[in] C									Name of the implementation class.
/// @see @ref svinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_REGISTER_SIMPLE(C, ...) \
	const __VA_ARGS__ C::Interface::MTable C::_clsMTable = __VA_ARGS__ C::Interface::MTable((C*) nullptr);


class ClassInterface;

/// @cond INTERNAL

//----------------------------------------------------------------------------------------
// Default implementation of some basic interface methods.
//----------------------------------------------------------------------------------------
namespace defaultimplementation
{
inline Result<void> InitImplementation() { return OK; }

inline void FreeImplementation() { }
}

/// @endcond

/// @}

} // namespace maxon

#endif // INTERFACEBASE_H__
