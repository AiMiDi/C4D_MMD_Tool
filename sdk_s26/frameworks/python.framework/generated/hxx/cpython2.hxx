
#ifndef DOXYGEN

#if defined MAXON_COMPILER_GCC
	#pragma GCC diagnostic push
	#if MAXON_COMPILER_GCC >= 600
		#pragma GCC diagnostic ignored "-Wmisleading-indentation"
	#endif
#endif

#if 1
namespace py
{
#ifdef MAXON_TARGET_WINDOWS
#endif

	struct PythonErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if (!S::Implementation::PROXY && !(Super0::InitMTablesWithBases(info, offset))) return false;
				auto* vt = (PythonErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonErrorInterface::_interface); if (!vt) return false;
				return true;
			}
		};

	};

	auto PythonErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonErrorInterface() { new (s_ui_maxon_py_PythonErrorInterface) maxon::EntityUse(PythonErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonErrorInterface(PythonErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct PythonTracebackErrorInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetUrl);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetLineNumber);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetUrl);
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		void (*PythonTracebackErrorInterface_SetUrl) (maxon::GenericComponent* this_, const Url& url);
		maxon::Int PythonTracebackErrorInterface_SetUrl_Offset;
		const Url& (*PythonTracebackErrorInterface_GetUrl) (const maxon::GenericComponent* this_);
		maxon::Int PythonTracebackErrorInterface_GetUrl_Offset;
		void (*PythonTracebackErrorInterface_SetLineNumber) (maxon::GenericComponent* this_, Int line);
		maxon::Int PythonTracebackErrorInterface_SetLineNumber_Offset;
		Int (*PythonTracebackErrorInterface_GetLineNumber) (const maxon::GenericComponent* this_);
		maxon::Int PythonTracebackErrorInterface_GetLineNumber_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, SetUrl))
		{
			PythonTracebackErrorInterface_SetUrl = &W::PythonTracebackErrorInterface_SetUrl;
			PythonTracebackErrorInterface_SetUrl_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, GetUrl))
		{
			PythonTracebackErrorInterface_GetUrl = &W::PythonTracebackErrorInterface_GetUrl;
			PythonTracebackErrorInterface_GetUrl_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, SetLineNumber))
		{
			PythonTracebackErrorInterface_SetLineNumber = &W::PythonTracebackErrorInterface_SetLineNumber;
			PythonTracebackErrorInterface_SetLineNumber_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PythonTracebackErrorInterface, GetLineNumber))
		{
			PythonTracebackErrorInterface_GetLineNumber = &W::PythonTracebackErrorInterface_GetLineNumber;
			PythonTracebackErrorInterface_GetLineNumber_Offset = offset;
		}
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonTracebackErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonTracebackErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonTracebackErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetLineNumber);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetUrl);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetLineNumber);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetUrl);
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if (!S::Implementation::PROXY && !(Super0::InitMTablesWithBases(info, offset))) return false;
				auto* vt = (PythonTracebackErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonTracebackErrorInterface::_interface); if (!vt) return false;
				vt->template Init<CWrapper>(offset);
				return true;
			}
			static void PythonTracebackErrorInterface_SetUrl(maxon::GenericComponent* this_, const Url& url) { return ((typename S::Implementation*) this_)->SetUrl(url); }
			static const Url& PythonTracebackErrorInterface_GetUrl(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetUrl(); }
			static void PythonTracebackErrorInterface_SetLineNumber(maxon::GenericComponent* this_, Int line) { return ((typename S::Implementation*) this_)->SetLineNumber(line); }
			static Int PythonTracebackErrorInterface_GetLineNumber(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetLineNumber(); }
		};

	};
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetUrl(const Url& url) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_.PythonTracebackErrorInterface_SetUrl((maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_SetUrl_Offset, url);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetUrl() const -> const Url&
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_.PythonTracebackErrorInterface_GetUrl((const maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_GetUrl_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::SetLineNumber(Int line) -> void
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_.PythonTracebackErrorInterface_SetLineNumber((maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset, line);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::GetLineNumber() const -> Int
	{
		const PythonTracebackErrorInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, this); return mt_.PythonTracebackErrorInterface_GetLineNumber((const maxon::GenericComponent*) this + mt_.PythonTracebackErrorInterface_GetLineNumber_Offset);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::Fn<S>::SetUrl(const Url& url) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_.PythonTracebackErrorInterface_SetUrl(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetUrl_Offset, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::COWFn<S>::SetUrl(const Url& url) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_.PythonTracebackErrorInterface_SetUrl(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetUrl_Offset, url);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::ConstFn<S>::GetUrl() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Url&>, const Url&>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const Url&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetUrl) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (mt_.PythonTracebackErrorInterface_GetUrl(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_GetUrl_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::Fn<S>::SetLineNumber(Int line) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_.PythonTracebackErrorInterface_SetLineNumber(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::COWFn<S>::SetLineNumber(Int line) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PythonTracebackErrorInterface* o_ = (PythonTracebackErrorInterface*) this->MakeWritable(false).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_SetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		mt_.PythonTracebackErrorInterface_SetLineNumber(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_SetLineNumber_Offset, line);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PythonTracebackErrorInterface::Hxx1::ConstFn<S>::GetLineNumber() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const PythonTracebackErrorInterface* o_ = (const PythonTracebackErrorInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = PythonTracebackErrorInterface::NullValuePtr(); if (!o_) return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PythonTracebackErrorInterface, o_, PythonTracebackErrorInterface_GetLineNumber) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PythonTracebackErrorInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PythonTracebackErrorInterface>() : PRIVATE_MAXON_VTABLE(PythonTracebackErrorInterface, o_); 
		return (mt_.PythonTracebackErrorInterface_GetLineNumber(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.PythonTracebackErrorInterface_GetLineNumber_Offset));
	}
	auto PythonTracebackErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonTracebackErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonTracebackErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonTracebackErrorInterface() { new (s_ui_maxon_py_PythonTracebackErrorInterface) maxon::EntityUse(PythonTracebackErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonTracebackErrorInterface(PythonTracebackErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct PythonSystemExitErrorInterface::MTable
	{
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		template <typename S> using CombinedMTable = maxon::CombinedMTable<PythonSystemExitErrorInterface, typename ErrorInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PythonSystemExitErrorInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct PythonSystemExitErrorInterface::Hxx2
	{
		template <typename S> class CWrapper : public ErrorInterface::Hxx2::template CWrapper<S>
		{
		public:
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename ErrorInterface::Hxx2::template CWrapper<S>;
				if (!S::Implementation::PROXY && !(Super0::InitMTablesWithBases(info, offset))) return false;
				auto* vt = (PythonSystemExitErrorInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PythonSystemExitErrorInterface::_interface); if (!vt) return false;
				return true;
			}
		};

	};

	auto PythonSystemExitErrorInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto PythonSystemExitErrorInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_PythonSystemExitErrorInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_PythonSystemExitErrorInterface() { new (s_ui_maxon_py_PythonSystemExitErrorInterface) maxon::EntityUse(PythonSystemExitErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_PythonSystemExitErrorInterface(PythonSystemExitErrorInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif

	struct CPythonLibraryInterface::MTable
	{
		PRIVATE_MAXON_IMPLEMENTS_CHECK(AssociateDataTypeWithPythonTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_FromBool);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyBool_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallable_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCallerContext_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_GetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_SetPointer);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyClass_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyCode_Addr2Line);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyData_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Contains);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Copy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_DelItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Items);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Keys);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_SetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyDict_Values);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_ExceptionMatches);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Fetch);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_NormalizeException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Occurred);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Print);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_Restore);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetNone);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrno);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyErr_SetWithErrnoAndFilename);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_AcquireThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_EvalCode);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_GetBuiltins);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_InitThreads);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ReleaseThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_RestoreThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_SaveThread);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyEval_ThreadsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ArithmeticError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AssertionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_AttributeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BaseException);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BufferError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_BytesWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_DeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EOFError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_EnvironmentError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Exception);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FloatingPointError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_FutureWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_GeneratorExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IOError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ImportWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndentationError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_IndexError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_KeyboardInterrupt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_LookupError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_MemoryErrorInst);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NameError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_NotImplementedError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OSError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_OverflowError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_PendingDeprecationWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ReferenceError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_RuntimeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StandardError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_StopIteration);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SyntaxWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_SystemExit);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TabError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_TypeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnboundLocalError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeDecodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeEncodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeTranslateError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UnicodeWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_UserWarning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ValueError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_Warning);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_WindowsError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExc_ZeroDivisionError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyExceptionClass_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_AsFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_FromFloat64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyFloat_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGC_Collect);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGILState_GetThisThreadState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Ensure);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyGilState_Release);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_GetImporter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_GetModuleDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyImport_ImportModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyIter_Next);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Append);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_AsTuple);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Clear);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Insert);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Reverse);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_SetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Sort);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyList_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_AsUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt16);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt32);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_FromUInt64);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyLong_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyMem_SetAllocator);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyMemoryView_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddIntConstant);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_AddType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Create);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyModule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNullImporter_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyNumber_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_AsData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Call);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_CallFunction);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_DelItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Dir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_FromGeneric);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemInt);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetItemString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_GetIter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_HasAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Hash);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_IsTrue);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Length);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Not);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Repr);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_RichCompare);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetAttrString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Str);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyObject_TypeCheck);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_FileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_InteractiveLoopFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleFileExFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyRun_SimpleStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySite_AddSiteDir);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySlice_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySuper_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_GetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetArgvEx);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetObject);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPySys_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_GetDict);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyThreadState_Swap);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTraceBack_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_GetSlice);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_SetItem);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Size);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyTuple_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_FastSubclass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_GetName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_HasFeature);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_IsSubtype);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Ready);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyType_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_AsCString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_AsString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_Check);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_FromString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_FromStringAndSize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_GetLength);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPyUnicode_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_BytesWarningFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_CompileStringFlags);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DebugFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Decref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_DontWriteBytecodeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_False);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Finalize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_FrozenFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetBuildInfo);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCompiler);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetCopyright);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPlatform);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_GetVersion);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IgnoreEnvironmentFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Incref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_Initialize);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InspectFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_InteractiveFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_IsInitialized);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoSiteFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NoUserSiteDirectory);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_None);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_NotImplemented);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_OptimizeFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeDecref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SafeIncref);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetProgramName);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_SetPythonHome);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_True);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CPy_VerboseFlag);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ConvertAndCacheString);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(CreateGlobalDictionary);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ExecuteModule);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(FopenNative);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Free);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetAssociatedDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyCodeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyFrameRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTracebackRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCPyTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConverterPyObject_FromData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetCurrentTraceback);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetDll);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetGilState);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyCallerContextRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyClassRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyDataTypeRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyFunctionRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyHashMapRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetMPyMemberRefClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetRegisteredTypesWithConversions);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(GetSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(Init);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitBuiltinModules);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(InitTypes);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(LastPythonCallFailed);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyClass_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataCapsule_Type);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_GetDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyDataType_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_CheckExact);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyData_ToMapperInstance);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyFunction_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyHashMap_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MPyMember_New);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(MaxonConvertAuto);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(ParseDataType);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateGetCurrentCallerContext);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(PrivateRegisterBuiltinConverter);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterComponentProxy);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecialPath);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(RegisterSpecificPythonClass);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(SetError);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackData);
		PRIVATE_MAXON_IMPLEMENTS_CHECK(UnpackDataType);
		static const maxon::Char* const _ids;
		static const maxon::METHOD_FLAGS _flags[];
		static const maxon::Bool HAS_NONSTATIC = false;
		Result<void> (*CPythonLibraryInterface_Init) (maxon::GenericComponent* this_, const Url& librarypath, Bool createSubLibrary);
		maxon::Int CPythonLibraryInterface_Init_Offset;
		Result<void> (*CPythonLibraryInterface_InitTypes) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_InitTypes_Offset;
		Result<void> (*CPythonLibraryInterface_InitBuiltinModules) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_InitBuiltinModules_Offset;
		void (*CPythonLibraryInterface_CPy_Initialize) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_Initialize_Offset;
		void (*CPythonLibraryInterface_CPy_Finalize) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_Finalize_Offset;
		CPyRef (*CPythonLibraryInterface_CPyModule_Create) (maxon::GenericComponent* this_, const ModuleDefinition& module);
		maxon::Int CPythonLibraryInterface_CPyModule_Create_Offset;
		void (*CPythonLibraryInterface_Free) (maxon::GenericComponent* this_, const Delegate<void()>& shutdownEngine);
		maxon::Int CPythonLibraryInterface_Free_Offset;
		const PythonDll& (*CPythonLibraryInterface_GetDll) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetDll_Offset;
		FILE_native* (*CPythonLibraryInterface_FopenNative) (maxon::GenericComponent* this_, const Char* name, const Char* mode);
		maxon::Int CPythonLibraryInterface_FopenNative_Offset;
		Error (*CPythonLibraryInterface_LastPythonCallFailed) (maxon::GenericComponent* this_, const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError);
		maxon::Int CPythonLibraryInterface_LastPythonCallFailed_Offset;
		Result<MPyDataRef> (*CPythonLibraryInterface_RegisterComponentProxy) (maxon::GenericComponent* this_, const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject);
		maxon::Int CPythonLibraryInterface_RegisterComponentProxy_Offset;
		Bool (*CPythonLibraryInterface_CPy_IsInitialized) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_IsInitialized_Offset;
		const Char* (*CPythonLibraryInterface_CPy_GetVersion) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetVersion_Offset;
		const Char* (*CPythonLibraryInterface_CPy_GetPlatform) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetPlatform_Offset;
		const Char* (*CPythonLibraryInterface_CPy_GetCopyright) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetCopyright_Offset;
		const Char* (*CPythonLibraryInterface_CPy_GetCompiler) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetCompiler_Offset;
		const Char* (*CPythonLibraryInterface_CPy_GetBuildInfo) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetBuildInfo_Offset;
		Result<void> (*CPythonLibraryInterface_CPy_SetProgramName) (maxon::GenericComponent* this_, const String& name);
		maxon::Int CPythonLibraryInterface_CPy_SetProgramName_Offset;
		Result<void> (*CPythonLibraryInterface_CPy_SetPythonHome) (maxon::GenericComponent* this_, const Url& name);
		maxon::Int CPythonLibraryInterface_CPy_SetPythonHome_Offset;
		String (*CPythonLibraryInterface_CPy_GetProgramName) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetProgramName_Offset;
		String (*CPythonLibraryInterface_CPy_GetPythonHome) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_GetPythonHome_Offset;
		Bool (*CPythonLibraryInterface_ExecuteModule) (maxon::GenericComponent* this_, const String& name);
		maxon::Int CPythonLibraryInterface_ExecuteModule_Offset;
		MPyCallerContextRef (*CPythonLibraryInterface_CPyCallerContext_New) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyCallerContext_New_Offset;
		Bool (*CPythonLibraryInterface_CPyRun_SimpleFileExFlags) (maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset;
		Bool (*CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) (maxon::GenericComponent* this_, const Url& url, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset;
		CPyRef (*CPythonLibraryInterface_CPyRun_SimpleStringFlags) (maxon::GenericComponent* this_, const String& code, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset;
		NativePyObject* (*CPythonLibraryInterface_CPyRun_FileExFlags) (maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_FileExFlags_Offset;
		Result<void> (*CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) (maxon::GenericComponent* this_, FILE* fp, const Char* filename, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset;
		PYGILSTATE (*CPythonLibraryInterface_CPyGilState_Ensure) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyGilState_Ensure_Offset;
		void (*CPythonLibraryInterface_CPyGilState_Release) (maxon::GenericComponent* this_, PYGILSTATE state);
		maxon::Int CPythonLibraryInterface_CPyGilState_Release_Offset;
		GILSTATE (*CPythonLibraryInterface_GetGilState) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetGilState_Offset;
		NativePyThreadState* (*CPythonLibraryInterface_CPyGILState_GetThisThreadState) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset;
		NativePyThreadState* (*CPythonLibraryInterface_CPyThreadState_Swap) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyThreadState_Swap_Offset;
		CPyRef (*CPythonLibraryInterface_CPyThreadState_GetDict) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyThreadState_GetDict_Offset;
		CPyCodeRef (*CPythonLibraryInterface_CPy_CompileStringFlags) (maxon::GenericComponent* this_, const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags);
		maxon::Int CPythonLibraryInterface_CPy_CompileStringFlags_Offset;
		void (*CPythonLibraryInterface_CPy_Incref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_Incref_Offset;
		void (*CPythonLibraryInterface_CPy_Decref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_Decref_Offset;
		void (*CPythonLibraryInterface_CPy_SafeIncref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_SafeIncref_Offset;
		void (*CPythonLibraryInterface_CPy_SafeDecref) (const maxon::GenericComponent* this_, NativePyObject* o);
		maxon::Int CPythonLibraryInterface_CPy_SafeDecref_Offset;
		Int64 (*CPythonLibraryInterface_CPyGC_Collect) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyGC_Collect_Offset;
		Int32 (*CPythonLibraryInterface_CPyCode_Addr2Line) (maxon::GenericComponent* this_, const CPyCodeRef& codeObject, Int32 x);
		maxon::Int CPythonLibraryInterface_CPyCode_Addr2Line_Offset;
		CPyRef (*CPythonLibraryInterface_UnpackDataType) (maxon::GenericComponent* this_, const CPyRef& obj);
		maxon::Int CPythonLibraryInterface_UnpackDataType_Offset;
		CPyRef (*CPythonLibraryInterface_UnpackData) (maxon::GenericComponent* this_, const CPyRef& obj);
		maxon::Int CPythonLibraryInterface_UnpackData_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPy_None) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_None_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPy_True) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_True_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPy_False) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_False_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPy_NotImplemented) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_NotImplemented_Offset;
		void (*CPythonLibraryInterface_CPyErr_Print) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyErr_Print_Offset;
		void (*CPythonLibraryInterface_CPyErr_Clear) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyErr_Clear_Offset;
		Bool (*CPythonLibraryInterface_CPyErr_Occurred) (maxon::GenericComponent* this_, CPyRef* type);
		maxon::Int CPythonLibraryInterface_CPyErr_Occurred_Offset;
		CPyRef (*CPythonLibraryInterface_CPyErr_SetString) (maxon::GenericComponent* this_, const CPyRef& errorType, const Char* errorString);
		maxon::Int CPythonLibraryInterface_CPyErr_SetString_Offset;
		CPyRef (*CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) (maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber, const Char* filename);
		maxon::Int CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset;
		CPyRef (*CPythonLibraryInterface_CPyErr_SetWithErrno) (maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber);
		maxon::Int CPythonLibraryInterface_CPyErr_SetWithErrno_Offset;
		CPyRef (*CPythonLibraryInterface_CPyErr_SetString_1) (maxon::GenericComponent* this_, const CPyRef& errorType, const String& errorString);
		maxon::Int CPythonLibraryInterface_CPyErr_SetString_1_Offset;
		void (*CPythonLibraryInterface_CPyErr_SetNone) (maxon::GenericComponent* this_, const CPyRef& errorType);
		maxon::Int CPythonLibraryInterface_CPyErr_SetNone_Offset;
		void (*CPythonLibraryInterface_CPyErr_Fetch) (maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_Fetch_Offset;
		void (*CPythonLibraryInterface_CPyErr_NormalizeException) (maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_NormalizeException_Offset;
		void (*CPythonLibraryInterface_CPyErr_Restore) (maxon::GenericComponent* this_, const CPyRef& type, const CPyRef& value, const CPyRef& traceback);
		maxon::Int CPythonLibraryInterface_CPyErr_Restore_Offset;
		Bool (*CPythonLibraryInterface_CPyErr_ExceptionMatches) (maxon::GenericComponent* this_, const CPyRef& exc);
		maxon::Int CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset;
		Bool (*CPythonLibraryInterface_CPyExceptionClass_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyExceptionClass_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyCapsule_New) (const maxon::GenericComponent* this_, void* pointer, const Char* name, CPyCapsule_Destructor* destructor);
		maxon::Int CPythonLibraryInterface_CPyCapsule_New_Offset;
		Bool (*CPythonLibraryInterface_CPyCapsule_SetPointer) (maxon::GenericComponent* this_, const CPyRef& capsule, void* pointer);
		maxon::Int CPythonLibraryInterface_CPyCapsule_SetPointer_Offset;
		void* (*CPythonLibraryInterface_CPyCapsule_GetPointer) (maxon::GenericComponent* this_, const CPyRef& capsule, const Char* name);
		maxon::Int CPythonLibraryInterface_CPyCapsule_GetPointer_Offset;
		void* (*CPythonLibraryInterface_CPyCapsule_GetContext) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_CPyCapsule_GetContext_Offset;
		Bool (*CPythonLibraryInterface_CPyCapsule_SetContext) (maxon::GenericComponent* this_, const CPyRef& capsule, void* context);
		maxon::Int CPythonLibraryInterface_CPyCapsule_SetContext_Offset;
		Bool (*CPythonLibraryInterface_CPyCapsule_CheckExact) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyCapsule_CheckExact_Offset;
		Bool (*CPythonLibraryInterface_CPyTraceBack_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyTraceBack_Check_Offset;
		Bool (*CPythonLibraryInterface_CPyClass_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyClass_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyTuple_New) (const maxon::GenericComponent* this_, UInt size);
		maxon::Int CPythonLibraryInterface_CPyTuple_New_Offset;
		UInt (*CPythonLibraryInterface_CPyTuple_Size) (maxon::GenericComponent* this_, const CPyRef& tuple);
		maxon::Int CPythonLibraryInterface_CPyTuple_Size_Offset;
		CPyRef (*CPythonLibraryInterface_CPyTuple_GetItem) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt index);
		maxon::Int CPythonLibraryInterface_CPyTuple_GetItem_Offset;
		Bool (*CPythonLibraryInterface_CPyTuple_SetItem) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt index, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyTuple_SetItem_Offset;
		CPyRef (*CPythonLibraryInterface_CPyTuple_GetSlice) (maxon::GenericComponent* this_, const CPyRef& tuple, UInt from, UInt to);
		maxon::Int CPythonLibraryInterface_CPyTuple_GetSlice_Offset;
		Bool (*CPythonLibraryInterface_CPyTuple_CheckExact) (maxon::GenericComponent* this_, const CPyRef& tuple);
		maxon::Int CPythonLibraryInterface_CPyTuple_CheckExact_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_HasAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* attrName);
		maxon::Int CPythonLibraryInterface_CPyObject_HasAttrString_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_SetAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* name, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyObject_SetAttrString_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_GetAttrString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* name);
		maxon::Int CPythonLibraryInterface_CPyObject_GetAttrString_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_Call) (maxon::GenericComponent* this_, const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw);
		maxon::Int CPythonLibraryInterface_CPyObject_Call_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_Str) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Str_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_Repr) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Repr_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_Dir) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Dir_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_RichCompare) (maxon::GenericComponent* this_, const CPyRef& o1, const CPyRef& o2, Int32 opid);
		maxon::Int CPythonLibraryInterface_CPyObject_RichCompare_Offset;
		Int64 (*CPythonLibraryInterface_CPyObject_Hash) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Hash_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_IsTrue) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_IsTrue_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_Not) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Not_Offset;
		Bool (*CPythonLibraryInterface_CPyCallable_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyCallable_Check_Offset;
		Int (*CPythonLibraryInterface_CPyObject_Length) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_Length_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_GetItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItem_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_GetItemInt) (maxon::GenericComponent* this_, const CPyRef& o, Int index);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItemInt_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_GetItemString) (maxon::GenericComponent* this_, const CPyRef& o, const Char* index);
		maxon::Int CPythonLibraryInterface_CPyObject_GetItemString_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_DelItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyObject_DelItem_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_SetItem) (maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyObject_SetItem_Offset;
		Bool (*CPythonLibraryInterface_CPyObject_TypeCheck) (maxon::GenericComponent* this_, const CPyRef& object, const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyObject_TypeCheck_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_CallFunction) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_CallFunction_Offset;
		CPyRef (*CPythonLibraryInterface_CPySys_GetObject) (maxon::GenericComponent* this_, const Char* name);
		maxon::Int CPythonLibraryInterface_CPySys_GetObject_Offset;
		Bool (*CPythonLibraryInterface_CPySys_SetObject) (maxon::GenericComponent* this_, const Char* name, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPySys_SetObject_Offset;
		Result<void> (*CPythonLibraryInterface_CPy_SetPath) (maxon::GenericComponent* this_, const BaseArray<Url>& paths);
		maxon::Int CPythonLibraryInterface_CPy_SetPath_Offset;
		Result<void> (*CPythonLibraryInterface_CPySys_SetPath) (maxon::GenericComponent* this_, const BaseArray<Url>& paths, PATHHANDLE add);
		maxon::Int CPythonLibraryInterface_CPySys_SetPath_Offset;
		Result<void> (*CPythonLibraryInterface_CPySys_SetArgvEx) (maxon::GenericComponent* this_, const BaseArray<String>& args, Bool updatepath);
		maxon::Int CPythonLibraryInterface_CPySys_SetArgvEx_Offset;
		BaseArray<Url> (*CPythonLibraryInterface_CPySys_GetPath) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPySys_GetPath_Offset;
		Result<void> (*CPythonLibraryInterface_CPySite_AddSiteDir) (maxon::GenericComponent* this_, const Url& siteDir);
		maxon::Int CPythonLibraryInterface_CPySite_AddSiteDir_Offset;
		Bool (*CPythonLibraryInterface_CPyUnicode_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyUnicode_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyUnicode_FromString) (const maxon::GenericComponent* this_, const Char* str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_FromString_Offset;
		CPyRef (*CPythonLibraryInterface_CPyUnicode_FromStringAndSize) (maxon::GenericComponent* this_, const Block<const Char>& block);
		maxon::Int CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset;
		Result<String> (*CPythonLibraryInterface_CPyUnicode_AsString) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_AsString_Offset;
		const Char* (*CPythonLibraryInterface_CPyUnicode_AsCString) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_AsCString_Offset;
		Int (*CPythonLibraryInterface_CPyUnicode_GetLength) (maxon::GenericComponent* this_, const CPyRef& str);
		maxon::Int CPythonLibraryInterface_CPyUnicode_GetLength_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_GetIter) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyObject_GetIter_Offset;
		CPyRef (*CPythonLibraryInterface_CPyIter_Next) (const maxon::GenericComponent* this_, const CPyRef& it);
		maxon::Int CPythonLibraryInterface_CPyIter_Next_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_New) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyDict_New_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_GetItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, Bool raiseKeyError);
		maxon::Int CPythonLibraryInterface_CPyDict_GetItem_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_GetItemString) (maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, Bool raiseKeyError);
		maxon::Int CPythonLibraryInterface_CPyDict_GetItemString_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_SetItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyDict_SetItem_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_DelItem) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyDict_DelItem_Offset;
		CONTAINS (*CPythonLibraryInterface_CPyDict_Contains) (maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key);
		maxon::Int CPythonLibraryInterface_CPyDict_Contains_Offset;
		void (*CPythonLibraryInterface_CPyDict_Clear) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Clear_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_Next) (maxon::GenericComponent* this_, const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value);
		maxon::Int CPythonLibraryInterface_CPyDict_Next_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_Keys) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Keys_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_Values) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Values_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_Items) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Items_Offset;
		Int (*CPythonLibraryInterface_CPyDict_Size) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Size_Offset;
		CPyRef (*CPythonLibraryInterface_CPyDict_Copy) (maxon::GenericComponent* this_, const CPyRef& dict);
		maxon::Int CPythonLibraryInterface_CPyDict_Copy_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_SetItemString) (const maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyDict_SetItemString_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_Check) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyDict_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyList_New) (maxon::GenericComponent* this_, UInt size);
		maxon::Int CPythonLibraryInterface_CPyList_New_Offset;
		Bool (*CPythonLibraryInterface_CPyList_CheckExact) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_CheckExact_Offset;
		Bool (*CPythonLibraryInterface_CPyList_Clear) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Clear_Offset;
		Int (*CPythonLibraryInterface_CPyList_Size) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Size_Offset;
		CPyRef (*CPythonLibraryInterface_CPyList_GetItem) (maxon::GenericComponent* this_, const CPyRef& list, UInt index);
		maxon::Int CPythonLibraryInterface_CPyList_GetItem_Offset;
		Bool (*CPythonLibraryInterface_CPyList_SetItem) (maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_SetItem_Offset;
		Bool (*CPythonLibraryInterface_CPyList_Insert) (maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_Insert_Offset;
		Bool (*CPythonLibraryInterface_CPyList_Append) (maxon::GenericComponent* this_, const CPyRef& list, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_Append_Offset;
		CPyRef (*CPythonLibraryInterface_CPyList_GetSlice) (maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to);
		maxon::Int CPythonLibraryInterface_CPyList_GetSlice_Offset;
		Bool (*CPythonLibraryInterface_CPyList_SetSlice) (maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to, const CPyRef& item);
		maxon::Int CPythonLibraryInterface_CPyList_SetSlice_Offset;
		Bool (*CPythonLibraryInterface_CPyList_Sort) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Sort_Offset;
		Bool (*CPythonLibraryInterface_CPyList_Reverse) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_Reverse_Offset;
		CPyRef (*CPythonLibraryInterface_CPyList_AsTuple) (maxon::GenericComponent* this_, const CPyRef& list);
		maxon::Int CPythonLibraryInterface_CPyList_AsTuple_Offset;
		Bool (*CPythonLibraryInterface_CPyDict_DelItemString) (maxon::GenericComponent* this_, const CPyRef& p, const Char* key);
		maxon::Int CPythonLibraryInterface_CPyDict_DelItemString_Offset;
		Bool (*CPythonLibraryInterface_CPyModule_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyModule_Check_Offset;
		Result<Bool> (*CPythonLibraryInterface_CPyModule_AddObject) (maxon::GenericComponent* this_, const CPyRef& module, const Char* name, const CPyRef& value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddObject_Offset;
		Bool (*CPythonLibraryInterface_CPyModule_AddType) (maxon::GenericComponent* this_, const CPyRef& module, const CPyTypeRef& value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddType_Offset;
		CPyRef (*CPythonLibraryInterface_CPyModule_GetDict) (maxon::GenericComponent* this_, const CPyRef& module);
		maxon::Int CPythonLibraryInterface_CPyModule_GetDict_Offset;
		Bool (*CPythonLibraryInterface_CPyModule_AddIntConstant) (maxon::GenericComponent* this_, const CPyRef& mod, const Char* name, long value);
		maxon::Int CPythonLibraryInterface_CPyModule_AddIntConstant_Offset;
		CPyRef (*CPythonLibraryInterface_CPyImport_ImportModule) (maxon::GenericComponent* this_, const Char* name);
		maxon::Int CPythonLibraryInterface_CPyImport_ImportModule_Offset;
		CPyRef (*CPythonLibraryInterface_CPyImport_GetImporter) (maxon::GenericComponent* this_, const CPyRef& path);
		maxon::Int CPythonLibraryInterface_CPyImport_GetImporter_Offset;
		CPyRef (*CPythonLibraryInterface_CPyImport_GetModuleDict) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyImport_GetModuleDict_Offset;
		Bool (*CPythonLibraryInterface_CPyType_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyType_Check_Offset;
		Bool (*CPythonLibraryInterface_CPyType_IsSubtype) (maxon::GenericComponent* this_, const CPyTypeRef& a, const CPyTypeRef& b);
		maxon::Int CPythonLibraryInterface_CPyType_IsSubtype_Offset;
		Bool (*CPythonLibraryInterface_CPyType_HasFeature) (const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f);
		maxon::Int CPythonLibraryInterface_CPyType_HasFeature_Offset;
		Bool (*CPythonLibraryInterface_CPyType_FastSubclass) (const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f);
		maxon::Int CPythonLibraryInterface_CPyType_FastSubclass_Offset;
		Result<String> (*CPythonLibraryInterface_CPyType_GetName) (maxon::GenericComponent* this_, const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyType_GetName_Offset;
		Bool (*CPythonLibraryInterface_CPyType_Ready) (maxon::GenericComponent* this_, CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_CPyType_Ready_Offset;
		NativePyThreadState* (*CPythonLibraryInterface_CPyEval_SaveThread) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyEval_SaveThread_Offset;
		void (*CPythonLibraryInterface_CPyEval_RestoreThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_RestoreThread_Offset;
		Bool (*CPythonLibraryInterface_CPyEval_ThreadsInitialized) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset;
		void (*CPythonLibraryInterface_CPyEval_InitThreads) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyEval_InitThreads_Offset;
		void (*CPythonLibraryInterface_CPyEval_AcquireThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_AcquireThread_Offset;
		void (*CPythonLibraryInterface_CPyEval_ReleaseThread) (maxon::GenericComponent* this_, NativePyThreadState* state);
		maxon::Int CPythonLibraryInterface_CPyEval_ReleaseThread_Offset;
		CPyRef (*CPythonLibraryInterface_CPyEval_GetBuiltins) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyEval_GetBuiltins_Offset;
		CPyRef (*CPythonLibraryInterface_CPyEval_EvalCode) (const maxon::GenericComponent* this_, const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals);
		maxon::Int CPythonLibraryInterface_CPyEval_EvalCode_Offset;
		Bool (*CPythonLibraryInterface_CPyFloat_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyFloat_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyFloat_FromFloat32) (maxon::GenericComponent* this_, Float32 value);
		maxon::Int CPythonLibraryInterface_CPyFloat_FromFloat32_Offset;
		CPyRef (*CPythonLibraryInterface_CPyFloat_FromFloat64) (maxon::GenericComponent* this_, Float64 value);
		maxon::Int CPythonLibraryInterface_CPyFloat_FromFloat64_Offset;
		Float64 (*CPythonLibraryInterface_CPyFloat_AsFloat64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyFloat_AsFloat64_Offset;
		Bool (*CPythonLibraryInterface_CPyLong_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_Check_Offset;
		CPyRef (*CPythonLibraryInterface_CPyBool_FromBool) (maxon::GenericComponent* this_, Bool value);
		maxon::Int CPythonLibraryInterface_CPyBool_FromBool_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromInt16) (maxon::GenericComponent* this_, Int16 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt16_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromUInt16) (maxon::GenericComponent* this_, UInt16 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt16_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromInt32) (maxon::GenericComponent* this_, Int32 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt32_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromUInt32) (maxon::GenericComponent* this_, UInt32 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt32_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromInt64) (maxon::GenericComponent* this_, Int64 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromInt64_Offset;
		CPyRef (*CPythonLibraryInterface_CPyLong_FromUInt64) (maxon::GenericComponent* this_, UInt64 value);
		maxon::Int CPythonLibraryInterface_CPyLong_FromUInt64_Offset;
		Int16 (*CPythonLibraryInterface_CPyLong_AsInt16) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt16_Offset;
		UInt16 (*CPythonLibraryInterface_CPyLong_AsUInt16) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt16_Offset;
		Int32 (*CPythonLibraryInterface_CPyLong_AsInt32) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt32_Offset;
		UInt32 (*CPythonLibraryInterface_CPyLong_AsUInt32) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt32_Offset;
		Int64 (*CPythonLibraryInterface_CPyLong_AsInt64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsInt64_Offset;
		UInt64 (*CPythonLibraryInterface_CPyLong_AsUInt64) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyLong_AsUInt64_Offset;
		Bool (*CPythonLibraryInterface_CPyNumber_Check) (maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_CPyNumber_Check_Offset;
		MPyFunctionRef (*CPythonLibraryInterface_MPyFunction_New) (maxon::GenericComponent* this_, const reflection::Function* func);
		maxon::Int CPythonLibraryInterface_MPyFunction_New_Offset;
		MPyHashMapRef (*CPythonLibraryInterface_MPyHashMap_New) (maxon::GenericComponent* this_, const HashMap<Data, Data>& map);
		maxon::Int CPythonLibraryInterface_MPyHashMap_New_Offset;
		MPyHashMapRef (*CPythonLibraryInterface_MPyHashMap_New_1) (maxon::GenericComponent* this_, HashMap<Data, Data>&& map);
		maxon::Int CPythonLibraryInterface_MPyHashMap_New_1_Offset;
		MPyMemberRef (*CPythonLibraryInterface_MPyMember_New) (maxon::GenericComponent* this_, const reflection::Member* member);
		maxon::Int CPythonLibraryInterface_MPyMember_New_Offset;
		Result<void> (*CPythonLibraryInterface_CPyMem_SetAllocator) (maxon::GenericComponent* this_, CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator);
		maxon::Int CPythonLibraryInterface_CPyMem_SetAllocator_Offset;
		MPyClassRef (*CPythonLibraryInterface_MPyClass_New) (maxon::GenericComponent* this_, const reflection::Class* cls);
		maxon::Int CPythonLibraryInterface_MPyClass_New_Offset;
		Int32* (*CPythonLibraryInterface_CPy_DebugFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_DebugFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_VerboseFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_VerboseFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_InteractiveFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_InteractiveFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_InspectFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_InspectFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_OptimizeFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_OptimizeFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_NoSiteFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_NoSiteFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_BytesWarningFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_BytesWarningFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_FrozenFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_FrozenFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset;
		Int32* (*CPythonLibraryInterface_CPy_NoUserSiteDirectory) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_BaseException) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_BaseException_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_Exception) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_Exception_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_StopIteration) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_StopIteration_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_GeneratorExit) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_GeneratorExit_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_StandardError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_StandardError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ArithmeticError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ArithmeticError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_LookupError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_LookupError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_AssertionError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_AssertionError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_AttributeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_AttributeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_EOFError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_EOFError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_FloatingPointError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_FloatingPointError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_EnvironmentError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_EnvironmentError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_IOError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_IOError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_OSError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_OSError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ImportError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ImportError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_IndexError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_IndexError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_KeyError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_KeyError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_KeyboardInterrupt) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_MemoryError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_MemoryError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_NameError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_NameError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_OverflowError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_OverflowError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_RuntimeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_RuntimeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_NotImplementedError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_NotImplementedError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_SyntaxError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_SyntaxError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_IndentationError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_IndentationError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_TabError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_TabError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ReferenceError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ReferenceError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_SystemError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_SystemError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_SystemExit) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_SystemExit_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_TypeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_TypeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnboundLocalError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnicodeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnicodeEncodeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnicodeDecodeError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnicodeTranslateError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ValueError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ValueError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ZeroDivisionError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_WindowsError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_WindowsError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_BufferError) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_BufferError_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_MemoryErrorInst) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_Warning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_Warning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UserWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UserWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_DeprecationWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_SyntaxWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_RuntimeWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_FutureWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_FutureWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_ImportWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_ImportWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_UnicodeWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset;
		CPyConstRef (*CPythonLibraryInterface_CPyExc_BytesWarning) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyExc_BytesWarning_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyNullImporter_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyNullImporter_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPySuper_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPySuper_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyBool_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyBool_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyObject_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyObject_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyModule_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyModule_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyUnicode_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyUnicode_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyLong_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyLong_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyFloat_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyFloat_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyTuple_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyTuple_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyList_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyList_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyDict_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyDict_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyClass_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyClass_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyTraceBack_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyTraceBack_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPySlice_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPySlice_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyType_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyType_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyMemoryView_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyMemoryView_Type_Offset;
		const PyChar* (*CPythonLibraryInterface_ConvertAndCacheString) (maxon::GenericComponent* this_, const String& str, PyStringEncodings encoding, UInt* size);
		maxon::Int CPythonLibraryInterface_ConvertAndCacheString_Offset;
		Result<void> (*CPythonLibraryInterface_RegisterSpecificPythonClass) (maxon::GenericComponent* this_, const Id& typeId, const CPyTypeRef& type);
		maxon::Int CPythonLibraryInterface_RegisterSpecificPythonClass_Offset;
		Result<void> (*CPythonLibraryInterface_PrivateRegisterBuiltinConverter) (maxon::GenericComponent* this_, const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2);
		maxon::Int CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset;
		Url (*CPythonLibraryInterface_GetSpecialPath) (maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1);
		maxon::Int CPythonLibraryInterface_GetSpecialPath_Offset;
		void (*CPythonLibraryInterface_RegisterSpecialPath) (maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1, const Url& path);
		maxon::Int CPythonLibraryInterface_RegisterSpecialPath_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_MPyDataCapsule_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_MPyDataCapsule_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyData_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyData_Type_Offset;
		CPyTypeConstRef (*CPythonLibraryInterface_CPyCapsule_Type) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CPyCapsule_Type_Offset;
		CPyRef (*CPythonLibraryInterface_PrivateGetCurrentCallerContext) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset;
		CPyRef (*CPythonLibraryInterface_MPyDataType_ToMapperInstance) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset;
		CPyRef (*CPythonLibraryInterface_MPyData_ToMapperInstance) (maxon::GenericComponent* this_, const MPyDataRef& capsule);
		maxon::Int CPythonLibraryInterface_MPyData_ToMapperInstance_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_ToMapperInstance) (maxon::GenericComponent* this_, const DataType& dt, const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset;
		Result<void> (*CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) (maxon::GenericComponent* this_, const DataType& dt, const CPyRef& type);
		maxon::Int CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset;
		Result<CPyRef> (*CPythonLibraryInterface_GetAssociatedDataType) (maxon::GenericComponent* this_, const DataType& dt);
		maxon::Int CPythonLibraryInterface_GetAssociatedDataType_Offset;
		DelegatePyObject_FromData<>* (*CPythonLibraryInterface_GetConverterPyObject_FromData) (maxon::GenericComponent* this_, const DataType& dt);
		maxon::Int CPythonLibraryInterface_GetConverterPyObject_FromData_Offset;
		MPyDataRef (*CPythonLibraryInterface_MPyData_New) (maxon::GenericComponent* this_, Data& data);
		maxon::Int CPythonLibraryInterface_MPyData_New_Offset;
		MPyDataRef (*CPythonLibraryInterface_MPyData_New_1) (maxon::GenericComponent* this_, const DataType& dt, Generic* data, Bool owner, const DataType& mapDt);
		maxon::Int CPythonLibraryInterface_MPyData_New_1_Offset;
		MPyDataTypeRef (*CPythonLibraryInterface_MPyDataType_New) (maxon::GenericComponent* this_, const DataType& dt);
		maxon::Int CPythonLibraryInterface_MPyDataType_New_Offset;
		Bool (*CPythonLibraryInterface_MPyDataType_CheckExact) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_MPyDataType_CheckExact_Offset;
		const DataType& (*CPythonLibraryInterface_MPyDataType_GetDataType) (const maxon::GenericComponent* this_, const MPyDataTypeRef& o);
		maxon::Int CPythonLibraryInterface_MPyDataType_GetDataType_Offset;
		Bool (*CPythonLibraryInterface_MPyData_CheckExact) (const maxon::GenericComponent* this_, const CPyRef& o);
		maxon::Int CPythonLibraryInterface_MPyData_CheckExact_Offset;
		Result<Data*> (*CPythonLibraryInterface_CPyObject_AsData) (maxon::GenericComponent* this_, Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n);
		maxon::Int CPythonLibraryInterface_CPyObject_AsData_Offset;
		Result<BaseArray<TYPE_CONVERSION_TUPLE>> (*CPythonLibraryInterface_GetRegisteredTypesWithConversions) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset;
		Result<DataType> (*CPythonLibraryInterface_ParseDataType) (maxon::GenericComponent* this_, const CPyRef& args, Int32 argIndex, Bool canBeNone);
		maxon::Int CPythonLibraryInterface_ParseDataType_Offset;
		void (*CPythonLibraryInterface_SetError) (maxon::GenericComponent* this_, const Error& err);
		maxon::Int CPythonLibraryInterface_SetError_Offset;
		void (*CPythonLibraryInterface_SetError_1) (maxon::GenericComponent* this_, const ErrorPtr& err);
		maxon::Int CPythonLibraryInterface_SetError_1_Offset;
		CPyRef (*CPythonLibraryInterface_MaxonConvertAuto) (maxon::GenericComponent* this_, const CPyRef& capsule);
		maxon::Int CPythonLibraryInterface_MaxonConvertAuto_Offset;
		CPyRef (*CPythonLibraryInterface_CPyObject_FromGeneric) (maxon::GenericComponent* this_, const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count);
		maxon::Int CPythonLibraryInterface_CPyObject_FromGeneric_Offset;
		CPyRef (*CPythonLibraryInterface_CreateGlobalDictionary) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_CreateGlobalDictionary_Offset;
		Result<BaseArray<SourceLocation>> (*CPythonLibraryInterface_GetCurrentTraceback) (maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCurrentTraceback_Offset;
		Class<CPyRef> (*CPythonLibraryInterface_GetCPyRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCPyRefClass_Offset;
		Class<CPyTypeRef> (*CPythonLibraryInterface_GetCPyTypeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCPyTypeRefClass_Offset;
		Class<CPyFrameRef> (*CPythonLibraryInterface_GetCPyFrameRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCPyFrameRefClass_Offset;
		Class<CPyTracebackRef> (*CPythonLibraryInterface_GetCPyTracebackRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCPyTracebackRefClass_Offset;
		Class<CPyCodeRef> (*CPythonLibraryInterface_GetCPyCodeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetCPyCodeRefClass_Offset;
		Class<MPyClassRef> (*CPythonLibraryInterface_GetMPyClassRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyClassRefClass_Offset;
		Class<MPyMemberRef> (*CPythonLibraryInterface_GetMPyMemberRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyMemberRefClass_Offset;
		Class<MPyFunctionRef> (*CPythonLibraryInterface_GetMPyFunctionRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyFunctionRefClass_Offset;
		Class<MPyHashMapRef> (*CPythonLibraryInterface_GetMPyHashMapRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyHashMapRefClass_Offset;
		Class<MPyDataTypeRef> (*CPythonLibraryInterface_GetMPyDataTypeRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset;
		Class<MPyDataRef> (*CPythonLibraryInterface_GetMPyDataRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyDataRefClass_Offset;
		Class<MPyCallerContextRef> (*CPythonLibraryInterface_GetMPyCallerContextRefClass) (const maxon::GenericComponent* this_);
		maxon::Int CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset;
		template <typename W> void Init(maxon::Int offset)
		{
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, Init))
		{
			CPythonLibraryInterface_Init = &W::CPythonLibraryInterface_Init;
			CPythonLibraryInterface_Init_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, InitTypes))
		{
			CPythonLibraryInterface_InitTypes = &W::CPythonLibraryInterface_InitTypes;
			CPythonLibraryInterface_InitTypes_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, InitBuiltinModules))
		{
			CPythonLibraryInterface_InitBuiltinModules = &W::CPythonLibraryInterface_InitBuiltinModules;
			CPythonLibraryInterface_InitBuiltinModules_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Initialize))
		{
			CPythonLibraryInterface_CPy_Initialize = &W::CPythonLibraryInterface_CPy_Initialize;
			CPythonLibraryInterface_CPy_Initialize_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Finalize))
		{
			CPythonLibraryInterface_CPy_Finalize = &W::CPythonLibraryInterface_CPy_Finalize;
			CPythonLibraryInterface_CPy_Finalize_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Create))
		{
			CPythonLibraryInterface_CPyModule_Create = &W::CPythonLibraryInterface_CPyModule_Create;
			CPythonLibraryInterface_CPyModule_Create_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, Free))
		{
			CPythonLibraryInterface_Free = &W::CPythonLibraryInterface_Free;
			CPythonLibraryInterface_Free_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetDll))
		{
			CPythonLibraryInterface_GetDll = &W::CPythonLibraryInterface_GetDll;
			CPythonLibraryInterface_GetDll_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, FopenNative))
		{
			CPythonLibraryInterface_FopenNative = &W::CPythonLibraryInterface_FopenNative;
			CPythonLibraryInterface_FopenNative_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, LastPythonCallFailed))
		{
			CPythonLibraryInterface_LastPythonCallFailed = &W::CPythonLibraryInterface_LastPythonCallFailed;
			CPythonLibraryInterface_LastPythonCallFailed_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterComponentProxy))
		{
			CPythonLibraryInterface_RegisterComponentProxy = &W::CPythonLibraryInterface_RegisterComponentProxy;
			CPythonLibraryInterface_RegisterComponentProxy_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_IsInitialized))
		{
			CPythonLibraryInterface_CPy_IsInitialized = &W::CPythonLibraryInterface_CPy_IsInitialized;
			CPythonLibraryInterface_CPy_IsInitialized_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetVersion))
		{
			CPythonLibraryInterface_CPy_GetVersion = &W::CPythonLibraryInterface_CPy_GetVersion;
			CPythonLibraryInterface_CPy_GetVersion_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetPlatform))
		{
			CPythonLibraryInterface_CPy_GetPlatform = &W::CPythonLibraryInterface_CPy_GetPlatform;
			CPythonLibraryInterface_CPy_GetPlatform_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetCopyright))
		{
			CPythonLibraryInterface_CPy_GetCopyright = &W::CPythonLibraryInterface_CPy_GetCopyright;
			CPythonLibraryInterface_CPy_GetCopyright_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetCompiler))
		{
			CPythonLibraryInterface_CPy_GetCompiler = &W::CPythonLibraryInterface_CPy_GetCompiler;
			CPythonLibraryInterface_CPy_GetCompiler_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetBuildInfo))
		{
			CPythonLibraryInterface_CPy_GetBuildInfo = &W::CPythonLibraryInterface_CPy_GetBuildInfo;
			CPythonLibraryInterface_CPy_GetBuildInfo_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetProgramName))
		{
			CPythonLibraryInterface_CPy_SetProgramName = &W::CPythonLibraryInterface_CPy_SetProgramName;
			CPythonLibraryInterface_CPy_SetProgramName_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetPythonHome))
		{
			CPythonLibraryInterface_CPy_SetPythonHome = &W::CPythonLibraryInterface_CPy_SetPythonHome;
			CPythonLibraryInterface_CPy_SetPythonHome_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetProgramName))
		{
			CPythonLibraryInterface_CPy_GetProgramName = &W::CPythonLibraryInterface_CPy_GetProgramName;
			CPythonLibraryInterface_CPy_GetProgramName_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_GetPythonHome))
		{
			CPythonLibraryInterface_CPy_GetPythonHome = &W::CPythonLibraryInterface_CPy_GetPythonHome;
			CPythonLibraryInterface_CPy_GetPythonHome_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ExecuteModule))
		{
			CPythonLibraryInterface_ExecuteModule = &W::CPythonLibraryInterface_ExecuteModule;
			CPythonLibraryInterface_ExecuteModule_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCallerContext_New))
		{
			CPythonLibraryInterface_CPyCallerContext_New = &W::CPythonLibraryInterface_CPyCallerContext_New;
			CPythonLibraryInterface_CPyCallerContext_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
		{
			CPythonLibraryInterface_CPyRun_SimpleFileExFlags = &W::CPythonLibraryInterface_CPyRun_SimpleFileExFlags;
			CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleFileExFlags))
		{
			CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1 = &W::CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1;
			CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_SimpleStringFlags))
		{
			CPythonLibraryInterface_CPyRun_SimpleStringFlags = &W::CPythonLibraryInterface_CPyRun_SimpleStringFlags;
			CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_FileExFlags))
		{
			CPythonLibraryInterface_CPyRun_FileExFlags = &W::CPythonLibraryInterface_CPyRun_FileExFlags;
			CPythonLibraryInterface_CPyRun_FileExFlags_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyRun_InteractiveLoopFlags))
		{
			CPythonLibraryInterface_CPyRun_InteractiveLoopFlags = &W::CPythonLibraryInterface_CPyRun_InteractiveLoopFlags;
			CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGilState_Ensure))
		{
			CPythonLibraryInterface_CPyGilState_Ensure = &W::CPythonLibraryInterface_CPyGilState_Ensure;
			CPythonLibraryInterface_CPyGilState_Ensure_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGilState_Release))
		{
			CPythonLibraryInterface_CPyGilState_Release = &W::CPythonLibraryInterface_CPyGilState_Release;
			CPythonLibraryInterface_CPyGilState_Release_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetGilState))
		{
			CPythonLibraryInterface_GetGilState = &W::CPythonLibraryInterface_GetGilState;
			CPythonLibraryInterface_GetGilState_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGILState_GetThisThreadState))
		{
			CPythonLibraryInterface_CPyGILState_GetThisThreadState = &W::CPythonLibraryInterface_CPyGILState_GetThisThreadState;
			CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyThreadState_Swap))
		{
			CPythonLibraryInterface_CPyThreadState_Swap = &W::CPythonLibraryInterface_CPyThreadState_Swap;
			CPythonLibraryInterface_CPyThreadState_Swap_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyThreadState_GetDict))
		{
			CPythonLibraryInterface_CPyThreadState_GetDict = &W::CPythonLibraryInterface_CPyThreadState_GetDict;
			CPythonLibraryInterface_CPyThreadState_GetDict_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_CompileStringFlags))
		{
			CPythonLibraryInterface_CPy_CompileStringFlags = &W::CPythonLibraryInterface_CPy_CompileStringFlags;
			CPythonLibraryInterface_CPy_CompileStringFlags_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Incref))
		{
			CPythonLibraryInterface_CPy_Incref = &W::CPythonLibraryInterface_CPy_Incref;
			CPythonLibraryInterface_CPy_Incref_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_Decref))
		{
			CPythonLibraryInterface_CPy_Decref = &W::CPythonLibraryInterface_CPy_Decref;
			CPythonLibraryInterface_CPy_Decref_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SafeIncref))
		{
			CPythonLibraryInterface_CPy_SafeIncref = &W::CPythonLibraryInterface_CPy_SafeIncref;
			CPythonLibraryInterface_CPy_SafeIncref_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SafeDecref))
		{
			CPythonLibraryInterface_CPy_SafeDecref = &W::CPythonLibraryInterface_CPy_SafeDecref;
			CPythonLibraryInterface_CPy_SafeDecref_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyGC_Collect))
		{
			CPythonLibraryInterface_CPyGC_Collect = &W::CPythonLibraryInterface_CPyGC_Collect;
			CPythonLibraryInterface_CPyGC_Collect_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCode_Addr2Line))
		{
			CPythonLibraryInterface_CPyCode_Addr2Line = &W::CPythonLibraryInterface_CPyCode_Addr2Line;
			CPythonLibraryInterface_CPyCode_Addr2Line_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, UnpackDataType))
		{
			CPythonLibraryInterface_UnpackDataType = &W::CPythonLibraryInterface_UnpackDataType;
			CPythonLibraryInterface_UnpackDataType_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, UnpackData))
		{
			CPythonLibraryInterface_UnpackData = &W::CPythonLibraryInterface_UnpackData;
			CPythonLibraryInterface_UnpackData_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_None))
		{
			CPythonLibraryInterface_CPy_None = &W::CPythonLibraryInterface_CPy_None;
			CPythonLibraryInterface_CPy_None_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_True))
		{
			CPythonLibraryInterface_CPy_True = &W::CPythonLibraryInterface_CPy_True;
			CPythonLibraryInterface_CPy_True_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_False))
		{
			CPythonLibraryInterface_CPy_False = &W::CPythonLibraryInterface_CPy_False;
			CPythonLibraryInterface_CPy_False_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NotImplemented))
		{
			CPythonLibraryInterface_CPy_NotImplemented = &W::CPythonLibraryInterface_CPy_NotImplemented;
			CPythonLibraryInterface_CPy_NotImplemented_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Print))
		{
			CPythonLibraryInterface_CPyErr_Print = &W::CPythonLibraryInterface_CPyErr_Print;
			CPythonLibraryInterface_CPyErr_Print_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Clear))
		{
			CPythonLibraryInterface_CPyErr_Clear = &W::CPythonLibraryInterface_CPyErr_Clear;
			CPythonLibraryInterface_CPyErr_Clear_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Occurred))
		{
			CPythonLibraryInterface_CPyErr_Occurred = &W::CPythonLibraryInterface_CPyErr_Occurred;
			CPythonLibraryInterface_CPyErr_Occurred_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
		{
			CPythonLibraryInterface_CPyErr_SetString = &W::CPythonLibraryInterface_CPyErr_SetString;
			CPythonLibraryInterface_CPyErr_SetString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrnoAndFilename))
		{
			CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename = &W::CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename;
			CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetWithErrno))
		{
			CPythonLibraryInterface_CPyErr_SetWithErrno = &W::CPythonLibraryInterface_CPyErr_SetWithErrno;
			CPythonLibraryInterface_CPyErr_SetWithErrno_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetString))
		{
			CPythonLibraryInterface_CPyErr_SetString_1 = &W::CPythonLibraryInterface_CPyErr_SetString_1;
			CPythonLibraryInterface_CPyErr_SetString_1_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_SetNone))
		{
			CPythonLibraryInterface_CPyErr_SetNone = &W::CPythonLibraryInterface_CPyErr_SetNone;
			CPythonLibraryInterface_CPyErr_SetNone_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Fetch))
		{
			CPythonLibraryInterface_CPyErr_Fetch = &W::CPythonLibraryInterface_CPyErr_Fetch;
			CPythonLibraryInterface_CPyErr_Fetch_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_NormalizeException))
		{
			CPythonLibraryInterface_CPyErr_NormalizeException = &W::CPythonLibraryInterface_CPyErr_NormalizeException;
			CPythonLibraryInterface_CPyErr_NormalizeException_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_Restore))
		{
			CPythonLibraryInterface_CPyErr_Restore = &W::CPythonLibraryInterface_CPyErr_Restore;
			CPythonLibraryInterface_CPyErr_Restore_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyErr_ExceptionMatches))
		{
			CPythonLibraryInterface_CPyErr_ExceptionMatches = &W::CPythonLibraryInterface_CPyErr_ExceptionMatches;
			CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExceptionClass_Check))
		{
			CPythonLibraryInterface_CPyExceptionClass_Check = &W::CPythonLibraryInterface_CPyExceptionClass_Check;
			CPythonLibraryInterface_CPyExceptionClass_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_New))
		{
			CPythonLibraryInterface_CPyCapsule_New = &W::CPythonLibraryInterface_CPyCapsule_New;
			CPythonLibraryInterface_CPyCapsule_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_SetPointer))
		{
			CPythonLibraryInterface_CPyCapsule_SetPointer = &W::CPythonLibraryInterface_CPyCapsule_SetPointer;
			CPythonLibraryInterface_CPyCapsule_SetPointer_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_GetPointer))
		{
			CPythonLibraryInterface_CPyCapsule_GetPointer = &W::CPythonLibraryInterface_CPyCapsule_GetPointer;
			CPythonLibraryInterface_CPyCapsule_GetPointer_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_GetContext))
		{
			CPythonLibraryInterface_CPyCapsule_GetContext = &W::CPythonLibraryInterface_CPyCapsule_GetContext;
			CPythonLibraryInterface_CPyCapsule_GetContext_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_SetContext))
		{
			CPythonLibraryInterface_CPyCapsule_SetContext = &W::CPythonLibraryInterface_CPyCapsule_SetContext;
			CPythonLibraryInterface_CPyCapsule_SetContext_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_CheckExact))
		{
			CPythonLibraryInterface_CPyCapsule_CheckExact = &W::CPythonLibraryInterface_CPyCapsule_CheckExact;
			CPythonLibraryInterface_CPyCapsule_CheckExact_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTraceBack_Check))
		{
			CPythonLibraryInterface_CPyTraceBack_Check = &W::CPythonLibraryInterface_CPyTraceBack_Check;
			CPythonLibraryInterface_CPyTraceBack_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyClass_Check))
		{
			CPythonLibraryInterface_CPyClass_Check = &W::CPythonLibraryInterface_CPyClass_Check;
			CPythonLibraryInterface_CPyClass_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_New))
		{
			CPythonLibraryInterface_CPyTuple_New = &W::CPythonLibraryInterface_CPyTuple_New;
			CPythonLibraryInterface_CPyTuple_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_Size))
		{
			CPythonLibraryInterface_CPyTuple_Size = &W::CPythonLibraryInterface_CPyTuple_Size;
			CPythonLibraryInterface_CPyTuple_Size_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_GetItem))
		{
			CPythonLibraryInterface_CPyTuple_GetItem = &W::CPythonLibraryInterface_CPyTuple_GetItem;
			CPythonLibraryInterface_CPyTuple_GetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_SetItem))
		{
			CPythonLibraryInterface_CPyTuple_SetItem = &W::CPythonLibraryInterface_CPyTuple_SetItem;
			CPythonLibraryInterface_CPyTuple_SetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_GetSlice))
		{
			CPythonLibraryInterface_CPyTuple_GetSlice = &W::CPythonLibraryInterface_CPyTuple_GetSlice;
			CPythonLibraryInterface_CPyTuple_GetSlice_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_CheckExact))
		{
			CPythonLibraryInterface_CPyTuple_CheckExact = &W::CPythonLibraryInterface_CPyTuple_CheckExact;
			CPythonLibraryInterface_CPyTuple_CheckExact_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_HasAttrString))
		{
			CPythonLibraryInterface_CPyObject_HasAttrString = &W::CPythonLibraryInterface_CPyObject_HasAttrString;
			CPythonLibraryInterface_CPyObject_HasAttrString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_SetAttrString))
		{
			CPythonLibraryInterface_CPyObject_SetAttrString = &W::CPythonLibraryInterface_CPyObject_SetAttrString;
			CPythonLibraryInterface_CPyObject_SetAttrString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetAttrString))
		{
			CPythonLibraryInterface_CPyObject_GetAttrString = &W::CPythonLibraryInterface_CPyObject_GetAttrString;
			CPythonLibraryInterface_CPyObject_GetAttrString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Call))
		{
			CPythonLibraryInterface_CPyObject_Call = &W::CPythonLibraryInterface_CPyObject_Call;
			CPythonLibraryInterface_CPyObject_Call_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Str))
		{
			CPythonLibraryInterface_CPyObject_Str = &W::CPythonLibraryInterface_CPyObject_Str;
			CPythonLibraryInterface_CPyObject_Str_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Repr))
		{
			CPythonLibraryInterface_CPyObject_Repr = &W::CPythonLibraryInterface_CPyObject_Repr;
			CPythonLibraryInterface_CPyObject_Repr_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Dir))
		{
			CPythonLibraryInterface_CPyObject_Dir = &W::CPythonLibraryInterface_CPyObject_Dir;
			CPythonLibraryInterface_CPyObject_Dir_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_RichCompare))
		{
			CPythonLibraryInterface_CPyObject_RichCompare = &W::CPythonLibraryInterface_CPyObject_RichCompare;
			CPythonLibraryInterface_CPyObject_RichCompare_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Hash))
		{
			CPythonLibraryInterface_CPyObject_Hash = &W::CPythonLibraryInterface_CPyObject_Hash;
			CPythonLibraryInterface_CPyObject_Hash_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_IsTrue))
		{
			CPythonLibraryInterface_CPyObject_IsTrue = &W::CPythonLibraryInterface_CPyObject_IsTrue;
			CPythonLibraryInterface_CPyObject_IsTrue_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Not))
		{
			CPythonLibraryInterface_CPyObject_Not = &W::CPythonLibraryInterface_CPyObject_Not;
			CPythonLibraryInterface_CPyObject_Not_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCallable_Check))
		{
			CPythonLibraryInterface_CPyCallable_Check = &W::CPythonLibraryInterface_CPyCallable_Check;
			CPythonLibraryInterface_CPyCallable_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Length))
		{
			CPythonLibraryInterface_CPyObject_Length = &W::CPythonLibraryInterface_CPyObject_Length;
			CPythonLibraryInterface_CPyObject_Length_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItem))
		{
			CPythonLibraryInterface_CPyObject_GetItem = &W::CPythonLibraryInterface_CPyObject_GetItem;
			CPythonLibraryInterface_CPyObject_GetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItemInt))
		{
			CPythonLibraryInterface_CPyObject_GetItemInt = &W::CPythonLibraryInterface_CPyObject_GetItemInt;
			CPythonLibraryInterface_CPyObject_GetItemInt_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetItemString))
		{
			CPythonLibraryInterface_CPyObject_GetItemString = &W::CPythonLibraryInterface_CPyObject_GetItemString;
			CPythonLibraryInterface_CPyObject_GetItemString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_DelItem))
		{
			CPythonLibraryInterface_CPyObject_DelItem = &W::CPythonLibraryInterface_CPyObject_DelItem;
			CPythonLibraryInterface_CPyObject_DelItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_SetItem))
		{
			CPythonLibraryInterface_CPyObject_SetItem = &W::CPythonLibraryInterface_CPyObject_SetItem;
			CPythonLibraryInterface_CPyObject_SetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_TypeCheck))
		{
			CPythonLibraryInterface_CPyObject_TypeCheck = &W::CPythonLibraryInterface_CPyObject_TypeCheck;
			CPythonLibraryInterface_CPyObject_TypeCheck_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_CallFunction))
		{
			CPythonLibraryInterface_CPyObject_CallFunction = &W::CPythonLibraryInterface_CPyObject_CallFunction;
			CPythonLibraryInterface_CPyObject_CallFunction_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_GetObject))
		{
			CPythonLibraryInterface_CPySys_GetObject = &W::CPythonLibraryInterface_CPySys_GetObject;
			CPythonLibraryInterface_CPySys_GetObject_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetObject))
		{
			CPythonLibraryInterface_CPySys_SetObject = &W::CPythonLibraryInterface_CPySys_SetObject;
			CPythonLibraryInterface_CPySys_SetObject_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_SetPath))
		{
			CPythonLibraryInterface_CPy_SetPath = &W::CPythonLibraryInterface_CPy_SetPath;
			CPythonLibraryInterface_CPy_SetPath_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetPath))
		{
			CPythonLibraryInterface_CPySys_SetPath = &W::CPythonLibraryInterface_CPySys_SetPath;
			CPythonLibraryInterface_CPySys_SetPath_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_SetArgvEx))
		{
			CPythonLibraryInterface_CPySys_SetArgvEx = &W::CPythonLibraryInterface_CPySys_SetArgvEx;
			CPythonLibraryInterface_CPySys_SetArgvEx_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySys_GetPath))
		{
			CPythonLibraryInterface_CPySys_GetPath = &W::CPythonLibraryInterface_CPySys_GetPath;
			CPythonLibraryInterface_CPySys_GetPath_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySite_AddSiteDir))
		{
			CPythonLibraryInterface_CPySite_AddSiteDir = &W::CPythonLibraryInterface_CPySite_AddSiteDir;
			CPythonLibraryInterface_CPySite_AddSiteDir_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_Check))
		{
			CPythonLibraryInterface_CPyUnicode_Check = &W::CPythonLibraryInterface_CPyUnicode_Check;
			CPythonLibraryInterface_CPyUnicode_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_FromString))
		{
			CPythonLibraryInterface_CPyUnicode_FromString = &W::CPythonLibraryInterface_CPyUnicode_FromString;
			CPythonLibraryInterface_CPyUnicode_FromString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_FromStringAndSize))
		{
			CPythonLibraryInterface_CPyUnicode_FromStringAndSize = &W::CPythonLibraryInterface_CPyUnicode_FromStringAndSize;
			CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_AsString))
		{
			CPythonLibraryInterface_CPyUnicode_AsString = &W::CPythonLibraryInterface_CPyUnicode_AsString;
			CPythonLibraryInterface_CPyUnicode_AsString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_AsCString))
		{
			CPythonLibraryInterface_CPyUnicode_AsCString = &W::CPythonLibraryInterface_CPyUnicode_AsCString;
			CPythonLibraryInterface_CPyUnicode_AsCString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_GetLength))
		{
			CPythonLibraryInterface_CPyUnicode_GetLength = &W::CPythonLibraryInterface_CPyUnicode_GetLength;
			CPythonLibraryInterface_CPyUnicode_GetLength_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_GetIter))
		{
			CPythonLibraryInterface_CPyObject_GetIter = &W::CPythonLibraryInterface_CPyObject_GetIter;
			CPythonLibraryInterface_CPyObject_GetIter_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyIter_Next))
		{
			CPythonLibraryInterface_CPyIter_Next = &W::CPythonLibraryInterface_CPyIter_Next;
			CPythonLibraryInterface_CPyIter_Next_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_New))
		{
			CPythonLibraryInterface_CPyDict_New = &W::CPythonLibraryInterface_CPyDict_New;
			CPythonLibraryInterface_CPyDict_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_GetItem))
		{
			CPythonLibraryInterface_CPyDict_GetItem = &W::CPythonLibraryInterface_CPyDict_GetItem;
			CPythonLibraryInterface_CPyDict_GetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_GetItemString))
		{
			CPythonLibraryInterface_CPyDict_GetItemString = &W::CPythonLibraryInterface_CPyDict_GetItemString;
			CPythonLibraryInterface_CPyDict_GetItemString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_SetItem))
		{
			CPythonLibraryInterface_CPyDict_SetItem = &W::CPythonLibraryInterface_CPyDict_SetItem;
			CPythonLibraryInterface_CPyDict_SetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_DelItem))
		{
			CPythonLibraryInterface_CPyDict_DelItem = &W::CPythonLibraryInterface_CPyDict_DelItem;
			CPythonLibraryInterface_CPyDict_DelItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Contains))
		{
			CPythonLibraryInterface_CPyDict_Contains = &W::CPythonLibraryInterface_CPyDict_Contains;
			CPythonLibraryInterface_CPyDict_Contains_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Clear))
		{
			CPythonLibraryInterface_CPyDict_Clear = &W::CPythonLibraryInterface_CPyDict_Clear;
			CPythonLibraryInterface_CPyDict_Clear_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Next))
		{
			CPythonLibraryInterface_CPyDict_Next = &W::CPythonLibraryInterface_CPyDict_Next;
			CPythonLibraryInterface_CPyDict_Next_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Keys))
		{
			CPythonLibraryInterface_CPyDict_Keys = &W::CPythonLibraryInterface_CPyDict_Keys;
			CPythonLibraryInterface_CPyDict_Keys_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Values))
		{
			CPythonLibraryInterface_CPyDict_Values = &W::CPythonLibraryInterface_CPyDict_Values;
			CPythonLibraryInterface_CPyDict_Values_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Items))
		{
			CPythonLibraryInterface_CPyDict_Items = &W::CPythonLibraryInterface_CPyDict_Items;
			CPythonLibraryInterface_CPyDict_Items_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Size))
		{
			CPythonLibraryInterface_CPyDict_Size = &W::CPythonLibraryInterface_CPyDict_Size;
			CPythonLibraryInterface_CPyDict_Size_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Copy))
		{
			CPythonLibraryInterface_CPyDict_Copy = &W::CPythonLibraryInterface_CPyDict_Copy;
			CPythonLibraryInterface_CPyDict_Copy_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_SetItemString))
		{
			CPythonLibraryInterface_CPyDict_SetItemString = &W::CPythonLibraryInterface_CPyDict_SetItemString;
			CPythonLibraryInterface_CPyDict_SetItemString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Check))
		{
			CPythonLibraryInterface_CPyDict_Check = &W::CPythonLibraryInterface_CPyDict_Check;
			CPythonLibraryInterface_CPyDict_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_New))
		{
			CPythonLibraryInterface_CPyList_New = &W::CPythonLibraryInterface_CPyList_New;
			CPythonLibraryInterface_CPyList_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_CheckExact))
		{
			CPythonLibraryInterface_CPyList_CheckExact = &W::CPythonLibraryInterface_CPyList_CheckExact;
			CPythonLibraryInterface_CPyList_CheckExact_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Clear))
		{
			CPythonLibraryInterface_CPyList_Clear = &W::CPythonLibraryInterface_CPyList_Clear;
			CPythonLibraryInterface_CPyList_Clear_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Size))
		{
			CPythonLibraryInterface_CPyList_Size = &W::CPythonLibraryInterface_CPyList_Size;
			CPythonLibraryInterface_CPyList_Size_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_GetItem))
		{
			CPythonLibraryInterface_CPyList_GetItem = &W::CPythonLibraryInterface_CPyList_GetItem;
			CPythonLibraryInterface_CPyList_GetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_SetItem))
		{
			CPythonLibraryInterface_CPyList_SetItem = &W::CPythonLibraryInterface_CPyList_SetItem;
			CPythonLibraryInterface_CPyList_SetItem_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Insert))
		{
			CPythonLibraryInterface_CPyList_Insert = &W::CPythonLibraryInterface_CPyList_Insert;
			CPythonLibraryInterface_CPyList_Insert_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Append))
		{
			CPythonLibraryInterface_CPyList_Append = &W::CPythonLibraryInterface_CPyList_Append;
			CPythonLibraryInterface_CPyList_Append_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_GetSlice))
		{
			CPythonLibraryInterface_CPyList_GetSlice = &W::CPythonLibraryInterface_CPyList_GetSlice;
			CPythonLibraryInterface_CPyList_GetSlice_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_SetSlice))
		{
			CPythonLibraryInterface_CPyList_SetSlice = &W::CPythonLibraryInterface_CPyList_SetSlice;
			CPythonLibraryInterface_CPyList_SetSlice_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Sort))
		{
			CPythonLibraryInterface_CPyList_Sort = &W::CPythonLibraryInterface_CPyList_Sort;
			CPythonLibraryInterface_CPyList_Sort_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Reverse))
		{
			CPythonLibraryInterface_CPyList_Reverse = &W::CPythonLibraryInterface_CPyList_Reverse;
			CPythonLibraryInterface_CPyList_Reverse_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_AsTuple))
		{
			CPythonLibraryInterface_CPyList_AsTuple = &W::CPythonLibraryInterface_CPyList_AsTuple;
			CPythonLibraryInterface_CPyList_AsTuple_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_DelItemString))
		{
			CPythonLibraryInterface_CPyDict_DelItemString = &W::CPythonLibraryInterface_CPyDict_DelItemString;
			CPythonLibraryInterface_CPyDict_DelItemString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Check))
		{
			CPythonLibraryInterface_CPyModule_Check = &W::CPythonLibraryInterface_CPyModule_Check;
			CPythonLibraryInterface_CPyModule_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddObject))
		{
			CPythonLibraryInterface_CPyModule_AddObject = &W::CPythonLibraryInterface_CPyModule_AddObject;
			CPythonLibraryInterface_CPyModule_AddObject_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddType))
		{
			CPythonLibraryInterface_CPyModule_AddType = &W::CPythonLibraryInterface_CPyModule_AddType;
			CPythonLibraryInterface_CPyModule_AddType_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_GetDict))
		{
			CPythonLibraryInterface_CPyModule_GetDict = &W::CPythonLibraryInterface_CPyModule_GetDict;
			CPythonLibraryInterface_CPyModule_GetDict_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_AddIntConstant))
		{
			CPythonLibraryInterface_CPyModule_AddIntConstant = &W::CPythonLibraryInterface_CPyModule_AddIntConstant;
			CPythonLibraryInterface_CPyModule_AddIntConstant_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_ImportModule))
		{
			CPythonLibraryInterface_CPyImport_ImportModule = &W::CPythonLibraryInterface_CPyImport_ImportModule;
			CPythonLibraryInterface_CPyImport_ImportModule_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_GetImporter))
		{
			CPythonLibraryInterface_CPyImport_GetImporter = &W::CPythonLibraryInterface_CPyImport_GetImporter;
			CPythonLibraryInterface_CPyImport_GetImporter_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyImport_GetModuleDict))
		{
			CPythonLibraryInterface_CPyImport_GetModuleDict = &W::CPythonLibraryInterface_CPyImport_GetModuleDict;
			CPythonLibraryInterface_CPyImport_GetModuleDict_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Check))
		{
			CPythonLibraryInterface_CPyType_Check = &W::CPythonLibraryInterface_CPyType_Check;
			CPythonLibraryInterface_CPyType_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_IsSubtype))
		{
			CPythonLibraryInterface_CPyType_IsSubtype = &W::CPythonLibraryInterface_CPyType_IsSubtype;
			CPythonLibraryInterface_CPyType_IsSubtype_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_HasFeature))
		{
			CPythonLibraryInterface_CPyType_HasFeature = &W::CPythonLibraryInterface_CPyType_HasFeature;
			CPythonLibraryInterface_CPyType_HasFeature_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_FastSubclass))
		{
			CPythonLibraryInterface_CPyType_FastSubclass = &W::CPythonLibraryInterface_CPyType_FastSubclass;
			CPythonLibraryInterface_CPyType_FastSubclass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_GetName))
		{
			CPythonLibraryInterface_CPyType_GetName = &W::CPythonLibraryInterface_CPyType_GetName;
			CPythonLibraryInterface_CPyType_GetName_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Ready))
		{
			CPythonLibraryInterface_CPyType_Ready = &W::CPythonLibraryInterface_CPyType_Ready;
			CPythonLibraryInterface_CPyType_Ready_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_SaveThread))
		{
			CPythonLibraryInterface_CPyEval_SaveThread = &W::CPythonLibraryInterface_CPyEval_SaveThread;
			CPythonLibraryInterface_CPyEval_SaveThread_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_RestoreThread))
		{
			CPythonLibraryInterface_CPyEval_RestoreThread = &W::CPythonLibraryInterface_CPyEval_RestoreThread;
			CPythonLibraryInterface_CPyEval_RestoreThread_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_ThreadsInitialized))
		{
			CPythonLibraryInterface_CPyEval_ThreadsInitialized = &W::CPythonLibraryInterface_CPyEval_ThreadsInitialized;
			CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_InitThreads))
		{
			CPythonLibraryInterface_CPyEval_InitThreads = &W::CPythonLibraryInterface_CPyEval_InitThreads;
			CPythonLibraryInterface_CPyEval_InitThreads_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_AcquireThread))
		{
			CPythonLibraryInterface_CPyEval_AcquireThread = &W::CPythonLibraryInterface_CPyEval_AcquireThread;
			CPythonLibraryInterface_CPyEval_AcquireThread_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_ReleaseThread))
		{
			CPythonLibraryInterface_CPyEval_ReleaseThread = &W::CPythonLibraryInterface_CPyEval_ReleaseThread;
			CPythonLibraryInterface_CPyEval_ReleaseThread_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_GetBuiltins))
		{
			CPythonLibraryInterface_CPyEval_GetBuiltins = &W::CPythonLibraryInterface_CPyEval_GetBuiltins;
			CPythonLibraryInterface_CPyEval_GetBuiltins_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyEval_EvalCode))
		{
			CPythonLibraryInterface_CPyEval_EvalCode = &W::CPythonLibraryInterface_CPyEval_EvalCode;
			CPythonLibraryInterface_CPyEval_EvalCode_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_Check))
		{
			CPythonLibraryInterface_CPyFloat_Check = &W::CPythonLibraryInterface_CPyFloat_Check;
			CPythonLibraryInterface_CPyFloat_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat32))
		{
			CPythonLibraryInterface_CPyFloat_FromFloat32 = &W::CPythonLibraryInterface_CPyFloat_FromFloat32;
			CPythonLibraryInterface_CPyFloat_FromFloat32_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_FromFloat64))
		{
			CPythonLibraryInterface_CPyFloat_FromFloat64 = &W::CPythonLibraryInterface_CPyFloat_FromFloat64;
			CPythonLibraryInterface_CPyFloat_FromFloat64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_AsFloat64))
		{
			CPythonLibraryInterface_CPyFloat_AsFloat64 = &W::CPythonLibraryInterface_CPyFloat_AsFloat64;
			CPythonLibraryInterface_CPyFloat_AsFloat64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_Check))
		{
			CPythonLibraryInterface_CPyLong_Check = &W::CPythonLibraryInterface_CPyLong_Check;
			CPythonLibraryInterface_CPyLong_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyBool_FromBool))
		{
			CPythonLibraryInterface_CPyBool_FromBool = &W::CPythonLibraryInterface_CPyBool_FromBool;
			CPythonLibraryInterface_CPyBool_FromBool_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt16))
		{
			CPythonLibraryInterface_CPyLong_FromInt16 = &W::CPythonLibraryInterface_CPyLong_FromInt16;
			CPythonLibraryInterface_CPyLong_FromInt16_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt16))
		{
			CPythonLibraryInterface_CPyLong_FromUInt16 = &W::CPythonLibraryInterface_CPyLong_FromUInt16;
			CPythonLibraryInterface_CPyLong_FromUInt16_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt32))
		{
			CPythonLibraryInterface_CPyLong_FromInt32 = &W::CPythonLibraryInterface_CPyLong_FromInt32;
			CPythonLibraryInterface_CPyLong_FromInt32_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt32))
		{
			CPythonLibraryInterface_CPyLong_FromUInt32 = &W::CPythonLibraryInterface_CPyLong_FromUInt32;
			CPythonLibraryInterface_CPyLong_FromUInt32_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromInt64))
		{
			CPythonLibraryInterface_CPyLong_FromInt64 = &W::CPythonLibraryInterface_CPyLong_FromInt64;
			CPythonLibraryInterface_CPyLong_FromInt64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_FromUInt64))
		{
			CPythonLibraryInterface_CPyLong_FromUInt64 = &W::CPythonLibraryInterface_CPyLong_FromUInt64;
			CPythonLibraryInterface_CPyLong_FromUInt64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt16))
		{
			CPythonLibraryInterface_CPyLong_AsInt16 = &W::CPythonLibraryInterface_CPyLong_AsInt16;
			CPythonLibraryInterface_CPyLong_AsInt16_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt16))
		{
			CPythonLibraryInterface_CPyLong_AsUInt16 = &W::CPythonLibraryInterface_CPyLong_AsUInt16;
			CPythonLibraryInterface_CPyLong_AsUInt16_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt32))
		{
			CPythonLibraryInterface_CPyLong_AsInt32 = &W::CPythonLibraryInterface_CPyLong_AsInt32;
			CPythonLibraryInterface_CPyLong_AsInt32_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt32))
		{
			CPythonLibraryInterface_CPyLong_AsUInt32 = &W::CPythonLibraryInterface_CPyLong_AsUInt32;
			CPythonLibraryInterface_CPyLong_AsUInt32_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsInt64))
		{
			CPythonLibraryInterface_CPyLong_AsInt64 = &W::CPythonLibraryInterface_CPyLong_AsInt64;
			CPythonLibraryInterface_CPyLong_AsInt64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_AsUInt64))
		{
			CPythonLibraryInterface_CPyLong_AsUInt64 = &W::CPythonLibraryInterface_CPyLong_AsUInt64;
			CPythonLibraryInterface_CPyLong_AsUInt64_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyNumber_Check))
		{
			CPythonLibraryInterface_CPyNumber_Check = &W::CPythonLibraryInterface_CPyNumber_Check;
			CPythonLibraryInterface_CPyNumber_Check_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyFunction_New))
		{
			CPythonLibraryInterface_MPyFunction_New = &W::CPythonLibraryInterface_MPyFunction_New;
			CPythonLibraryInterface_MPyFunction_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyHashMap_New))
		{
			CPythonLibraryInterface_MPyHashMap_New = &W::CPythonLibraryInterface_MPyHashMap_New;
			CPythonLibraryInterface_MPyHashMap_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyHashMap_New))
		{
			CPythonLibraryInterface_MPyHashMap_New_1 = &W::CPythonLibraryInterface_MPyHashMap_New_1;
			CPythonLibraryInterface_MPyHashMap_New_1_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyMember_New))
		{
			CPythonLibraryInterface_MPyMember_New = &W::CPythonLibraryInterface_MPyMember_New;
			CPythonLibraryInterface_MPyMember_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyMem_SetAllocator))
		{
			CPythonLibraryInterface_CPyMem_SetAllocator = &W::CPythonLibraryInterface_CPyMem_SetAllocator;
			CPythonLibraryInterface_CPyMem_SetAllocator_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyClass_New))
		{
			CPythonLibraryInterface_MPyClass_New = &W::CPythonLibraryInterface_MPyClass_New;
			CPythonLibraryInterface_MPyClass_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_DebugFlag))
		{
			CPythonLibraryInterface_CPy_DebugFlag = &W::CPythonLibraryInterface_CPy_DebugFlag;
			CPythonLibraryInterface_CPy_DebugFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_VerboseFlag))
		{
			CPythonLibraryInterface_CPy_VerboseFlag = &W::CPythonLibraryInterface_CPy_VerboseFlag;
			CPythonLibraryInterface_CPy_VerboseFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_InteractiveFlag))
		{
			CPythonLibraryInterface_CPy_InteractiveFlag = &W::CPythonLibraryInterface_CPy_InteractiveFlag;
			CPythonLibraryInterface_CPy_InteractiveFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_InspectFlag))
		{
			CPythonLibraryInterface_CPy_InspectFlag = &W::CPythonLibraryInterface_CPy_InspectFlag;
			CPythonLibraryInterface_CPy_InspectFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_OptimizeFlag))
		{
			CPythonLibraryInterface_CPy_OptimizeFlag = &W::CPythonLibraryInterface_CPy_OptimizeFlag;
			CPythonLibraryInterface_CPy_OptimizeFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NoSiteFlag))
		{
			CPythonLibraryInterface_CPy_NoSiteFlag = &W::CPythonLibraryInterface_CPy_NoSiteFlag;
			CPythonLibraryInterface_CPy_NoSiteFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_BytesWarningFlag))
		{
			CPythonLibraryInterface_CPy_BytesWarningFlag = &W::CPythonLibraryInterface_CPy_BytesWarningFlag;
			CPythonLibraryInterface_CPy_BytesWarningFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_FrozenFlag))
		{
			CPythonLibraryInterface_CPy_FrozenFlag = &W::CPythonLibraryInterface_CPy_FrozenFlag;
			CPythonLibraryInterface_CPy_FrozenFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_IgnoreEnvironmentFlag))
		{
			CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag = &W::CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag;
			CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_DontWriteBytecodeFlag))
		{
			CPythonLibraryInterface_CPy_DontWriteBytecodeFlag = &W::CPythonLibraryInterface_CPy_DontWriteBytecodeFlag;
			CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPy_NoUserSiteDirectory))
		{
			CPythonLibraryInterface_CPy_NoUserSiteDirectory = &W::CPythonLibraryInterface_CPy_NoUserSiteDirectory;
			CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BaseException))
		{
			CPythonLibraryInterface_CPyExc_BaseException = &W::CPythonLibraryInterface_CPyExc_BaseException;
			CPythonLibraryInterface_CPyExc_BaseException_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_Exception))
		{
			CPythonLibraryInterface_CPyExc_Exception = &W::CPythonLibraryInterface_CPyExc_Exception;
			CPythonLibraryInterface_CPyExc_Exception_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_StopIteration))
		{
			CPythonLibraryInterface_CPyExc_StopIteration = &W::CPythonLibraryInterface_CPyExc_StopIteration;
			CPythonLibraryInterface_CPyExc_StopIteration_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_GeneratorExit))
		{
			CPythonLibraryInterface_CPyExc_GeneratorExit = &W::CPythonLibraryInterface_CPyExc_GeneratorExit;
			CPythonLibraryInterface_CPyExc_GeneratorExit_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_StandardError))
		{
			CPythonLibraryInterface_CPyExc_StandardError = &W::CPythonLibraryInterface_CPyExc_StandardError;
			CPythonLibraryInterface_CPyExc_StandardError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ArithmeticError))
		{
			CPythonLibraryInterface_CPyExc_ArithmeticError = &W::CPythonLibraryInterface_CPyExc_ArithmeticError;
			CPythonLibraryInterface_CPyExc_ArithmeticError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_LookupError))
		{
			CPythonLibraryInterface_CPyExc_LookupError = &W::CPythonLibraryInterface_CPyExc_LookupError;
			CPythonLibraryInterface_CPyExc_LookupError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_AssertionError))
		{
			CPythonLibraryInterface_CPyExc_AssertionError = &W::CPythonLibraryInterface_CPyExc_AssertionError;
			CPythonLibraryInterface_CPyExc_AssertionError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_AttributeError))
		{
			CPythonLibraryInterface_CPyExc_AttributeError = &W::CPythonLibraryInterface_CPyExc_AttributeError;
			CPythonLibraryInterface_CPyExc_AttributeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_EOFError))
		{
			CPythonLibraryInterface_CPyExc_EOFError = &W::CPythonLibraryInterface_CPyExc_EOFError;
			CPythonLibraryInterface_CPyExc_EOFError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_FloatingPointError))
		{
			CPythonLibraryInterface_CPyExc_FloatingPointError = &W::CPythonLibraryInterface_CPyExc_FloatingPointError;
			CPythonLibraryInterface_CPyExc_FloatingPointError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_EnvironmentError))
		{
			CPythonLibraryInterface_CPyExc_EnvironmentError = &W::CPythonLibraryInterface_CPyExc_EnvironmentError;
			CPythonLibraryInterface_CPyExc_EnvironmentError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IOError))
		{
			CPythonLibraryInterface_CPyExc_IOError = &W::CPythonLibraryInterface_CPyExc_IOError;
			CPythonLibraryInterface_CPyExc_IOError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_OSError))
		{
			CPythonLibraryInterface_CPyExc_OSError = &W::CPythonLibraryInterface_CPyExc_OSError;
			CPythonLibraryInterface_CPyExc_OSError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ImportError))
		{
			CPythonLibraryInterface_CPyExc_ImportError = &W::CPythonLibraryInterface_CPyExc_ImportError;
			CPythonLibraryInterface_CPyExc_ImportError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IndexError))
		{
			CPythonLibraryInterface_CPyExc_IndexError = &W::CPythonLibraryInterface_CPyExc_IndexError;
			CPythonLibraryInterface_CPyExc_IndexError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_KeyError))
		{
			CPythonLibraryInterface_CPyExc_KeyError = &W::CPythonLibraryInterface_CPyExc_KeyError;
			CPythonLibraryInterface_CPyExc_KeyError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_KeyboardInterrupt))
		{
			CPythonLibraryInterface_CPyExc_KeyboardInterrupt = &W::CPythonLibraryInterface_CPyExc_KeyboardInterrupt;
			CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_MemoryError))
		{
			CPythonLibraryInterface_CPyExc_MemoryError = &W::CPythonLibraryInterface_CPyExc_MemoryError;
			CPythonLibraryInterface_CPyExc_MemoryError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_NameError))
		{
			CPythonLibraryInterface_CPyExc_NameError = &W::CPythonLibraryInterface_CPyExc_NameError;
			CPythonLibraryInterface_CPyExc_NameError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_OverflowError))
		{
			CPythonLibraryInterface_CPyExc_OverflowError = &W::CPythonLibraryInterface_CPyExc_OverflowError;
			CPythonLibraryInterface_CPyExc_OverflowError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeError))
		{
			CPythonLibraryInterface_CPyExc_RuntimeError = &W::CPythonLibraryInterface_CPyExc_RuntimeError;
			CPythonLibraryInterface_CPyExc_RuntimeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_NotImplementedError))
		{
			CPythonLibraryInterface_CPyExc_NotImplementedError = &W::CPythonLibraryInterface_CPyExc_NotImplementedError;
			CPythonLibraryInterface_CPyExc_NotImplementedError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxError))
		{
			CPythonLibraryInterface_CPyExc_SyntaxError = &W::CPythonLibraryInterface_CPyExc_SyntaxError;
			CPythonLibraryInterface_CPyExc_SyntaxError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_IndentationError))
		{
			CPythonLibraryInterface_CPyExc_IndentationError = &W::CPythonLibraryInterface_CPyExc_IndentationError;
			CPythonLibraryInterface_CPyExc_IndentationError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_TabError))
		{
			CPythonLibraryInterface_CPyExc_TabError = &W::CPythonLibraryInterface_CPyExc_TabError;
			CPythonLibraryInterface_CPyExc_TabError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ReferenceError))
		{
			CPythonLibraryInterface_CPyExc_ReferenceError = &W::CPythonLibraryInterface_CPyExc_ReferenceError;
			CPythonLibraryInterface_CPyExc_ReferenceError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SystemError))
		{
			CPythonLibraryInterface_CPyExc_SystemError = &W::CPythonLibraryInterface_CPyExc_SystemError;
			CPythonLibraryInterface_CPyExc_SystemError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SystemExit))
		{
			CPythonLibraryInterface_CPyExc_SystemExit = &W::CPythonLibraryInterface_CPyExc_SystemExit;
			CPythonLibraryInterface_CPyExc_SystemExit_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_TypeError))
		{
			CPythonLibraryInterface_CPyExc_TypeError = &W::CPythonLibraryInterface_CPyExc_TypeError;
			CPythonLibraryInterface_CPyExc_TypeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnboundLocalError))
		{
			CPythonLibraryInterface_CPyExc_UnboundLocalError = &W::CPythonLibraryInterface_CPyExc_UnboundLocalError;
			CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeError))
		{
			CPythonLibraryInterface_CPyExc_UnicodeError = &W::CPythonLibraryInterface_CPyExc_UnicodeError;
			CPythonLibraryInterface_CPyExc_UnicodeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeEncodeError))
		{
			CPythonLibraryInterface_CPyExc_UnicodeEncodeError = &W::CPythonLibraryInterface_CPyExc_UnicodeEncodeError;
			CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeDecodeError))
		{
			CPythonLibraryInterface_CPyExc_UnicodeDecodeError = &W::CPythonLibraryInterface_CPyExc_UnicodeDecodeError;
			CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeTranslateError))
		{
			CPythonLibraryInterface_CPyExc_UnicodeTranslateError = &W::CPythonLibraryInterface_CPyExc_UnicodeTranslateError;
			CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ValueError))
		{
			CPythonLibraryInterface_CPyExc_ValueError = &W::CPythonLibraryInterface_CPyExc_ValueError;
			CPythonLibraryInterface_CPyExc_ValueError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ZeroDivisionError))
		{
			CPythonLibraryInterface_CPyExc_ZeroDivisionError = &W::CPythonLibraryInterface_CPyExc_ZeroDivisionError;
			CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_WindowsError))
		{
			CPythonLibraryInterface_CPyExc_WindowsError = &W::CPythonLibraryInterface_CPyExc_WindowsError;
			CPythonLibraryInterface_CPyExc_WindowsError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BufferError))
		{
			CPythonLibraryInterface_CPyExc_BufferError = &W::CPythonLibraryInterface_CPyExc_BufferError;
			CPythonLibraryInterface_CPyExc_BufferError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_MemoryErrorInst))
		{
			CPythonLibraryInterface_CPyExc_MemoryErrorInst = &W::CPythonLibraryInterface_CPyExc_MemoryErrorInst;
			CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_Warning))
		{
			CPythonLibraryInterface_CPyExc_Warning = &W::CPythonLibraryInterface_CPyExc_Warning;
			CPythonLibraryInterface_CPyExc_Warning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UserWarning))
		{
			CPythonLibraryInterface_CPyExc_UserWarning = &W::CPythonLibraryInterface_CPyExc_UserWarning;
			CPythonLibraryInterface_CPyExc_UserWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_DeprecationWarning))
		{
			CPythonLibraryInterface_CPyExc_DeprecationWarning = &W::CPythonLibraryInterface_CPyExc_DeprecationWarning;
			CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_PendingDeprecationWarning))
		{
			CPythonLibraryInterface_CPyExc_PendingDeprecationWarning = &W::CPythonLibraryInterface_CPyExc_PendingDeprecationWarning;
			CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_SyntaxWarning))
		{
			CPythonLibraryInterface_CPyExc_SyntaxWarning = &W::CPythonLibraryInterface_CPyExc_SyntaxWarning;
			CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_RuntimeWarning))
		{
			CPythonLibraryInterface_CPyExc_RuntimeWarning = &W::CPythonLibraryInterface_CPyExc_RuntimeWarning;
			CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_FutureWarning))
		{
			CPythonLibraryInterface_CPyExc_FutureWarning = &W::CPythonLibraryInterface_CPyExc_FutureWarning;
			CPythonLibraryInterface_CPyExc_FutureWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_ImportWarning))
		{
			CPythonLibraryInterface_CPyExc_ImportWarning = &W::CPythonLibraryInterface_CPyExc_ImportWarning;
			CPythonLibraryInterface_CPyExc_ImportWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_UnicodeWarning))
		{
			CPythonLibraryInterface_CPyExc_UnicodeWarning = &W::CPythonLibraryInterface_CPyExc_UnicodeWarning;
			CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyExc_BytesWarning))
		{
			CPythonLibraryInterface_CPyExc_BytesWarning = &W::CPythonLibraryInterface_CPyExc_BytesWarning;
			CPythonLibraryInterface_CPyExc_BytesWarning_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyNullImporter_Type))
		{
			CPythonLibraryInterface_CPyNullImporter_Type = &W::CPythonLibraryInterface_CPyNullImporter_Type;
			CPythonLibraryInterface_CPyNullImporter_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySuper_Type))
		{
			CPythonLibraryInterface_CPySuper_Type = &W::CPythonLibraryInterface_CPySuper_Type;
			CPythonLibraryInterface_CPySuper_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyBool_Type))
		{
			CPythonLibraryInterface_CPyBool_Type = &W::CPythonLibraryInterface_CPyBool_Type;
			CPythonLibraryInterface_CPyBool_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_Type))
		{
			CPythonLibraryInterface_CPyObject_Type = &W::CPythonLibraryInterface_CPyObject_Type;
			CPythonLibraryInterface_CPyObject_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyModule_Type))
		{
			CPythonLibraryInterface_CPyModule_Type = &W::CPythonLibraryInterface_CPyModule_Type;
			CPythonLibraryInterface_CPyModule_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyUnicode_Type))
		{
			CPythonLibraryInterface_CPyUnicode_Type = &W::CPythonLibraryInterface_CPyUnicode_Type;
			CPythonLibraryInterface_CPyUnicode_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyLong_Type))
		{
			CPythonLibraryInterface_CPyLong_Type = &W::CPythonLibraryInterface_CPyLong_Type;
			CPythonLibraryInterface_CPyLong_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyFloat_Type))
		{
			CPythonLibraryInterface_CPyFloat_Type = &W::CPythonLibraryInterface_CPyFloat_Type;
			CPythonLibraryInterface_CPyFloat_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTuple_Type))
		{
			CPythonLibraryInterface_CPyTuple_Type = &W::CPythonLibraryInterface_CPyTuple_Type;
			CPythonLibraryInterface_CPyTuple_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyList_Type))
		{
			CPythonLibraryInterface_CPyList_Type = &W::CPythonLibraryInterface_CPyList_Type;
			CPythonLibraryInterface_CPyList_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyDict_Type))
		{
			CPythonLibraryInterface_CPyDict_Type = &W::CPythonLibraryInterface_CPyDict_Type;
			CPythonLibraryInterface_CPyDict_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyClass_Type))
		{
			CPythonLibraryInterface_CPyClass_Type = &W::CPythonLibraryInterface_CPyClass_Type;
			CPythonLibraryInterface_CPyClass_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyTraceBack_Type))
		{
			CPythonLibraryInterface_CPyTraceBack_Type = &W::CPythonLibraryInterface_CPyTraceBack_Type;
			CPythonLibraryInterface_CPyTraceBack_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPySlice_Type))
		{
			CPythonLibraryInterface_CPySlice_Type = &W::CPythonLibraryInterface_CPySlice_Type;
			CPythonLibraryInterface_CPySlice_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyType_Type))
		{
			CPythonLibraryInterface_CPyType_Type = &W::CPythonLibraryInterface_CPyType_Type;
			CPythonLibraryInterface_CPyType_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyMemoryView_Type))
		{
			CPythonLibraryInterface_CPyMemoryView_Type = &W::CPythonLibraryInterface_CPyMemoryView_Type;
			CPythonLibraryInterface_CPyMemoryView_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ConvertAndCacheString))
		{
			CPythonLibraryInterface_ConvertAndCacheString = &W::CPythonLibraryInterface_ConvertAndCacheString;
			CPythonLibraryInterface_ConvertAndCacheString_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterSpecificPythonClass))
		{
			CPythonLibraryInterface_RegisterSpecificPythonClass = &W::CPythonLibraryInterface_RegisterSpecificPythonClass;
			CPythonLibraryInterface_RegisterSpecificPythonClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, PrivateRegisterBuiltinConverter))
		{
			CPythonLibraryInterface_PrivateRegisterBuiltinConverter = &W::CPythonLibraryInterface_PrivateRegisterBuiltinConverter;
			CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetSpecialPath))
		{
			CPythonLibraryInterface_GetSpecialPath = &W::CPythonLibraryInterface_GetSpecialPath;
			CPythonLibraryInterface_GetSpecialPath_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, RegisterSpecialPath))
		{
			CPythonLibraryInterface_RegisterSpecialPath = &W::CPythonLibraryInterface_RegisterSpecialPath;
			CPythonLibraryInterface_RegisterSpecialPath_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataCapsule_Type))
		{
			CPythonLibraryInterface_MPyDataCapsule_Type = &W::CPythonLibraryInterface_MPyDataCapsule_Type;
			CPythonLibraryInterface_MPyDataCapsule_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyData_Type))
		{
			CPythonLibraryInterface_CPyData_Type = &W::CPythonLibraryInterface_CPyData_Type;
			CPythonLibraryInterface_CPyData_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyCapsule_Type))
		{
			CPythonLibraryInterface_CPyCapsule_Type = &W::CPythonLibraryInterface_CPyCapsule_Type;
			CPythonLibraryInterface_CPyCapsule_Type_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, PrivateGetCurrentCallerContext))
		{
			CPythonLibraryInterface_PrivateGetCurrentCallerContext = &W::CPythonLibraryInterface_PrivateGetCurrentCallerContext;
			CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_ToMapperInstance))
		{
			CPythonLibraryInterface_MPyDataType_ToMapperInstance = &W::CPythonLibraryInterface_MPyDataType_ToMapperInstance;
			CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_ToMapperInstance))
		{
			CPythonLibraryInterface_MPyData_ToMapperInstance = &W::CPythonLibraryInterface_MPyData_ToMapperInstance;
			CPythonLibraryInterface_MPyData_ToMapperInstance_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_ToMapperInstance))
		{
			CPythonLibraryInterface_CPyObject_ToMapperInstance = &W::CPythonLibraryInterface_CPyObject_ToMapperInstance;
			CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, AssociateDataTypeWithPythonTypes))
		{
			CPythonLibraryInterface_AssociateDataTypeWithPythonTypes = &W::CPythonLibraryInterface_AssociateDataTypeWithPythonTypes;
			CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetAssociatedDataType))
		{
			CPythonLibraryInterface_GetAssociatedDataType = &W::CPythonLibraryInterface_GetAssociatedDataType;
			CPythonLibraryInterface_GetAssociatedDataType_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetConverterPyObject_FromData))
		{
			CPythonLibraryInterface_GetConverterPyObject_FromData = &W::CPythonLibraryInterface_GetConverterPyObject_FromData;
			CPythonLibraryInterface_GetConverterPyObject_FromData_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_New))
		{
			CPythonLibraryInterface_MPyData_New = &W::CPythonLibraryInterface_MPyData_New;
			CPythonLibraryInterface_MPyData_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_New))
		{
			CPythonLibraryInterface_MPyData_New_1 = &W::CPythonLibraryInterface_MPyData_New_1;
			CPythonLibraryInterface_MPyData_New_1_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_New))
		{
			CPythonLibraryInterface_MPyDataType_New = &W::CPythonLibraryInterface_MPyDataType_New;
			CPythonLibraryInterface_MPyDataType_New_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_CheckExact))
		{
			CPythonLibraryInterface_MPyDataType_CheckExact = &W::CPythonLibraryInterface_MPyDataType_CheckExact;
			CPythonLibraryInterface_MPyDataType_CheckExact_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyDataType_GetDataType))
		{
			CPythonLibraryInterface_MPyDataType_GetDataType = &W::CPythonLibraryInterface_MPyDataType_GetDataType;
			CPythonLibraryInterface_MPyDataType_GetDataType_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MPyData_CheckExact))
		{
			CPythonLibraryInterface_MPyData_CheckExact = &W::CPythonLibraryInterface_MPyData_CheckExact;
			CPythonLibraryInterface_MPyData_CheckExact_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_AsData))
		{
			CPythonLibraryInterface_CPyObject_AsData = &W::CPythonLibraryInterface_CPyObject_AsData;
			CPythonLibraryInterface_CPyObject_AsData_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetRegisteredTypesWithConversions))
		{
			CPythonLibraryInterface_GetRegisteredTypesWithConversions = &W::CPythonLibraryInterface_GetRegisteredTypesWithConversions;
			CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, ParseDataType))
		{
			CPythonLibraryInterface_ParseDataType = &W::CPythonLibraryInterface_ParseDataType;
			CPythonLibraryInterface_ParseDataType_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, SetError))
		{
			CPythonLibraryInterface_SetError = &W::CPythonLibraryInterface_SetError;
			CPythonLibraryInterface_SetError_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, SetError))
		{
			CPythonLibraryInterface_SetError_1 = &W::CPythonLibraryInterface_SetError_1;
			CPythonLibraryInterface_SetError_1_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, MaxonConvertAuto))
		{
			CPythonLibraryInterface_MaxonConvertAuto = &W::CPythonLibraryInterface_MaxonConvertAuto;
			CPythonLibraryInterface_MaxonConvertAuto_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CPyObject_FromGeneric))
		{
			CPythonLibraryInterface_CPyObject_FromGeneric = &W::CPythonLibraryInterface_CPyObject_FromGeneric;
			CPythonLibraryInterface_CPyObject_FromGeneric_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, CreateGlobalDictionary))
		{
			CPythonLibraryInterface_CreateGlobalDictionary = &W::CPythonLibraryInterface_CreateGlobalDictionary;
			CPythonLibraryInterface_CreateGlobalDictionary_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCurrentTraceback))
		{
			CPythonLibraryInterface_GetCurrentTraceback = &W::CPythonLibraryInterface_GetCurrentTraceback;
			CPythonLibraryInterface_GetCurrentTraceback_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyRefClass))
		{
			CPythonLibraryInterface_GetCPyRefClass = &W::CPythonLibraryInterface_GetCPyRefClass;
			CPythonLibraryInterface_GetCPyRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyTypeRefClass))
		{
			CPythonLibraryInterface_GetCPyTypeRefClass = &W::CPythonLibraryInterface_GetCPyTypeRefClass;
			CPythonLibraryInterface_GetCPyTypeRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyFrameRefClass))
		{
			CPythonLibraryInterface_GetCPyFrameRefClass = &W::CPythonLibraryInterface_GetCPyFrameRefClass;
			CPythonLibraryInterface_GetCPyFrameRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyTracebackRefClass))
		{
			CPythonLibraryInterface_GetCPyTracebackRefClass = &W::CPythonLibraryInterface_GetCPyTracebackRefClass;
			CPythonLibraryInterface_GetCPyTracebackRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetCPyCodeRefClass))
		{
			CPythonLibraryInterface_GetCPyCodeRefClass = &W::CPythonLibraryInterface_GetCPyCodeRefClass;
			CPythonLibraryInterface_GetCPyCodeRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyClassRefClass))
		{
			CPythonLibraryInterface_GetMPyClassRefClass = &W::CPythonLibraryInterface_GetMPyClassRefClass;
			CPythonLibraryInterface_GetMPyClassRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyMemberRefClass))
		{
			CPythonLibraryInterface_GetMPyMemberRefClass = &W::CPythonLibraryInterface_GetMPyMemberRefClass;
			CPythonLibraryInterface_GetMPyMemberRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyFunctionRefClass))
		{
			CPythonLibraryInterface_GetMPyFunctionRefClass = &W::CPythonLibraryInterface_GetMPyFunctionRefClass;
			CPythonLibraryInterface_GetMPyFunctionRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyHashMapRefClass))
		{
			CPythonLibraryInterface_GetMPyHashMapRefClass = &W::CPythonLibraryInterface_GetMPyHashMapRefClass;
			CPythonLibraryInterface_GetMPyHashMapRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyDataTypeRefClass))
		{
			CPythonLibraryInterface_GetMPyDataTypeRefClass = &W::CPythonLibraryInterface_GetMPyDataTypeRefClass;
			CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyDataRefClass))
		{
			CPythonLibraryInterface_GetMPyDataRefClass = &W::CPythonLibraryInterface_GetMPyDataRefClass;
			CPythonLibraryInterface_GetMPyDataRefClass_Offset = offset;
		}
		if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, CPythonLibraryInterface, GetMPyCallerContextRefClass))
		{
			CPythonLibraryInterface_GetMPyCallerContextRefClass = &W::CPythonLibraryInterface_GetMPyCallerContextRefClass;
			CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset = offset;
		}
		}
		template <typename S> using CombinedMTable = maxon::CombinedMTable<CPythonLibraryInterface, typename LibraryInterface::MTable::template CombinedMTable<S>>;
		template <typename SUPER> using CompBase = maxon::PrivateComponentBase<CPythonLibraryInterface, SUPER>;
		template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
	};

	struct CPythonLibraryInterface::Hxx2
	{
		class Unresolved;
		struct StaticMTable
		{
			static StaticMTable _instance;
			static StaticMTable _unresolvedInstance;
			static maxon::Bool InitUnresolved(maxon::NonvirtualInterfaceReference::UnresolvedAssembler assembler, StaticMTable* tbl);
			static const maxon::Char* const _ids;
			static const maxon::NULL_RETURN_TYPE _returnTypes[];
		Result<PYSTARTOPERATION> (*CPythonLibraryInterface_ParseCommandLine) (BaseArray<String>* args, Data* res, PYTHONFLAG* flags);
		Result<void> (*CPythonLibraryInterface_GetUrl) (DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome);
			StaticMTable() = default;
			template <typename IMPL> static void Init(StaticMTable* tbl)
			{
			tbl->CPythonLibraryInterface_ParseCommandLine = &IMPL::CPythonLibraryInterface_ParseCommandLine;
			tbl->CPythonLibraryInterface_GetUrl = &IMPL::CPythonLibraryInterface_GetUrl;
			}
		};
		template <typename S> class CWrapper : public LibraryInterface::Hxx2::template CWrapper<S>
		{
		public:
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(AssociateDataTypeWithPythonTypes);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_FromBool);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyBool_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallable_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCallerContext_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_GetPointer);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_SetPointer);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCapsule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyClass_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyCode_Addr2Line);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyData_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Contains);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Copy);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_DelItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_GetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Items);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Keys);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Next);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_SetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyDict_Values);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_ExceptionMatches);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Fetch);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_NormalizeException);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Occurred);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Print);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_Restore);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetNone);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrno);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyErr_SetWithErrnoAndFilename);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_AcquireThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_EvalCode);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_GetBuiltins);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_InitThreads);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ReleaseThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_RestoreThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_SaveThread);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyEval_ThreadsInitialized);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ArithmeticError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AssertionError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_AttributeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BaseException);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BufferError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_BytesWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_DeprecationWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EOFError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_EnvironmentError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Exception);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FloatingPointError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_FutureWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_GeneratorExit);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IOError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ImportWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndentationError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_IndexError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_KeyboardInterrupt);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_LookupError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_MemoryErrorInst);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NameError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_NotImplementedError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OSError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_OverflowError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_PendingDeprecationWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ReferenceError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_RuntimeWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StandardError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_StopIteration);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SyntaxWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_SystemExit);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TabError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_TypeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnboundLocalError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeDecodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeEncodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeTranslateError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UnicodeWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_UserWarning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ValueError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_Warning);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_WindowsError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExc_ZeroDivisionError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyExceptionClass_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_AsFloat64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_FromFloat64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyFloat_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGC_Collect);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGILState_GetThisThreadState);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Ensure);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyGilState_Release);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_GetImporter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_GetModuleDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyImport_ImportModule);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyIter_Next);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Append);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_AsTuple);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Clear);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_GetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Insert);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Reverse);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_SetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Sort);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyList_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_AsUInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt16);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt32);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_FromUInt64);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyLong_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyMem_SetAllocator);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyMemoryView_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddIntConstant);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_AddType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Create);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_GetDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyModule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNullImporter_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyNumber_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_AsData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Call);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_CallFunction);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_DelItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Dir);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_FromGeneric);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemInt);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetItemString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_GetIter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_HasAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Hash);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_IsTrue);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Length);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Not);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Repr);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_RichCompare);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetAttrString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Str);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyObject_TypeCheck);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_FileExFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_InteractiveLoopFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleFileExFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyRun_SimpleStringFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySite_AddSiteDir);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySlice_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySuper_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_GetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetArgvEx);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetObject);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPySys_SetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_GetDict);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyThreadState_Swap);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTraceBack_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_GetSlice);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_SetItem);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Size);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyTuple_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_FastSubclass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_GetName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_HasFeature);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_IsSubtype);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Ready);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyType_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_AsCString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_AsString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_Check);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_FromString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_FromStringAndSize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_GetLength);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPyUnicode_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_BytesWarningFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_CompileStringFlags);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DebugFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Decref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_DontWriteBytecodeFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_False);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Finalize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_FrozenFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetBuildInfo);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCompiler);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetCopyright);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPlatform);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetProgramName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetPythonHome);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_GetVersion);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IgnoreEnvironmentFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Incref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_Initialize);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InspectFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_InteractiveFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_IsInitialized);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoSiteFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NoUserSiteDirectory);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_None);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_NotImplemented);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_OptimizeFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeDecref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SafeIncref);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetProgramName);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_SetPythonHome);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_True);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CPy_VerboseFlag);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ConvertAndCacheString);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(CreateGlobalDictionary);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ExecuteModule);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(FopenNative);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Free);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetAssociatedDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyCodeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyFrameRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTracebackRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCPyTypeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConverterPyObject_FromData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetCurrentTraceback);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetDll);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetGilState);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyCallerContextRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyClassRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyDataTypeRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyFunctionRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyHashMapRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetMPyMemberRefClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetRegisteredTypesWithConversions);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetSpecialPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(Init);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitBuiltinModules);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(InitTypes);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(LastPythonCallFailed);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyClass_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataCapsule_Type);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_GetDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyDataType_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_CheckExact);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyData_ToMapperInstance);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyFunction_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyHashMap_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MPyMember_New);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(MaxonConvertAuto);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(ParseDataType);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateGetCurrentCallerContext);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(PrivateRegisterBuiltinConverter);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterComponentProxy);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecialPath);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(RegisterSpecificPythonClass);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(SetError);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackData);
			PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(UnpackDataType);
			static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
			{
				using Super0 = typename LibraryInterface::Hxx2::template CWrapper<S>;
				if (!S::Implementation::PROXY && !(Super0::InitMTablesWithBases(info, offset))) return false;
				auto* vt = (CPythonLibraryInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, CPythonLibraryInterface::_interface); if (!vt) return false;
				vt->template Init<CWrapper>(offset);
				return true;
			}
			static Result<PYSTARTOPERATION> CPythonLibraryInterface_ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) { return S::Implementation::ParseCommandLine(args, res, flags); }
			static Result<void> CPythonLibraryInterface_Init(maxon::GenericComponent* this_, const Url& librarypath, Bool createSubLibrary) { return ((typename S::Implementation*) this_)->Init(librarypath, createSubLibrary); }
			static Result<void> CPythonLibraryInterface_InitTypes(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->InitTypes(); }
			static Result<void> CPythonLibraryInterface_InitBuiltinModules(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->InitBuiltinModules(); }
			static void CPythonLibraryInterface_CPy_Initialize(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_Initialize(); }
			static void CPythonLibraryInterface_CPy_Finalize(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_Finalize(); }
			static CPyRef CPythonLibraryInterface_CPyModule_Create(maxon::GenericComponent* this_, const ModuleDefinition& module) { return ((typename S::Implementation*) this_)->CPyModule_Create(module); }
			static void CPythonLibraryInterface_Free(maxon::GenericComponent* this_, const Delegate<void()>& shutdownEngine) { return ((typename S::Implementation*) this_)->Free(shutdownEngine); }
			static const PythonDll& CPythonLibraryInterface_GetDll(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetDll(); }
			static FILE_native* CPythonLibraryInterface_FopenNative(maxon::GenericComponent* this_, const Char* name, const Char* mode) { return ((typename S::Implementation*) this_)->FopenNative(name, mode); }
			static Error CPythonLibraryInterface_LastPythonCallFailed(maxon::GenericComponent* this_, const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) { return ((typename S::Implementation*) this_)->LastPythonCallFailed(allocLocation, withTraceback, restoreError); }
			static Result<MPyDataRef> CPythonLibraryInterface_RegisterComponentProxy(maxon::GenericComponent* this_, const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) { return ((typename S::Implementation*) this_)->RegisterComponentProxy(type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject); }
			static Bool CPythonLibraryInterface_CPy_IsInitialized(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_IsInitialized(); }
			static const Char* CPythonLibraryInterface_CPy_GetVersion(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetVersion(); }
			static const Char* CPythonLibraryInterface_CPy_GetPlatform(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetPlatform(); }
			static const Char* CPythonLibraryInterface_CPy_GetCopyright(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetCopyright(); }
			static const Char* CPythonLibraryInterface_CPy_GetCompiler(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetCompiler(); }
			static const Char* CPythonLibraryInterface_CPy_GetBuildInfo(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetBuildInfo(); }
			static Result<void> CPythonLibraryInterface_CPy_SetProgramName(maxon::GenericComponent* this_, const String& name) { return ((typename S::Implementation*) this_)->CPy_SetProgramName(name); }
			static Result<void> CPythonLibraryInterface_CPy_SetPythonHome(maxon::GenericComponent* this_, const Url& name) { return ((typename S::Implementation*) this_)->CPy_SetPythonHome(name); }
			static String CPythonLibraryInterface_CPy_GetProgramName(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetProgramName(); }
			static String CPythonLibraryInterface_CPy_GetPythonHome(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_GetPythonHome(); }
			static Bool CPythonLibraryInterface_ExecuteModule(maxon::GenericComponent* this_, const String& name) { return ((typename S::Implementation*) this_)->ExecuteModule(name); }
			static MPyCallerContextRef CPythonLibraryInterface_CPyCallerContext_New(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyCallerContext_New(); }
			static Bool CPythonLibraryInterface_CPyRun_SimpleFileExFlags(maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleFileExFlags(fp, filename, closeit, flags); }
			static Bool CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(maxon::GenericComponent* this_, const Url& url, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleFileExFlags(url, flags); }
			static CPyRef CPythonLibraryInterface_CPyRun_SimpleStringFlags(maxon::GenericComponent* this_, const String& code, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_SimpleStringFlags(code, flags); }
			static NativePyObject* CPythonLibraryInterface_CPyRun_FileExFlags(maxon::GenericComponent* this_, FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_FileExFlags(fp, filename, start, globals, locals, closeit, flags); }
			static Result<void> CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(maxon::GenericComponent* this_, FILE* fp, const Char* filename, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPyRun_InteractiveLoopFlags(fp, filename, flags); }
			static PYGILSTATE CPythonLibraryInterface_CPyGilState_Ensure(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGilState_Ensure(); }
			static void CPythonLibraryInterface_CPyGilState_Release(maxon::GenericComponent* this_, PYGILSTATE state) { return ((typename S::Implementation*) this_)->CPyGilState_Release(state); }
			static GILSTATE CPythonLibraryInterface_GetGilState(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetGilState(); }
			static NativePyThreadState* CPythonLibraryInterface_CPyGILState_GetThisThreadState(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGILState_GetThisThreadState(); }
			static NativePyThreadState* CPythonLibraryInterface_CPyThreadState_Swap(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyThreadState_Swap(state); }
			static CPyRef CPythonLibraryInterface_CPyThreadState_GetDict(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyThreadState_GetDict(); }
			static CPyCodeRef CPythonLibraryInterface_CPy_CompileStringFlags(maxon::GenericComponent* this_, const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) { return ((typename S::Implementation*) this_)->CPy_CompileStringFlags(code, filename, start, flags); }
			static void CPythonLibraryInterface_CPy_Incref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_Incref(o); }
			static void CPythonLibraryInterface_CPy_Decref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_Decref(o); }
			static void CPythonLibraryInterface_CPy_SafeIncref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_SafeIncref(o); }
			static void CPythonLibraryInterface_CPy_SafeDecref(const maxon::GenericComponent* this_, NativePyObject* o) { return ((const typename S::Implementation*) this_)->CPy_SafeDecref(o); }
			static Int64 CPythonLibraryInterface_CPyGC_Collect(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyGC_Collect(); }
			static Int32 CPythonLibraryInterface_CPyCode_Addr2Line(maxon::GenericComponent* this_, const CPyCodeRef& codeObject, Int32 x) { return ((typename S::Implementation*) this_)->CPyCode_Addr2Line(codeObject, x); }
			static CPyRef CPythonLibraryInterface_UnpackDataType(maxon::GenericComponent* this_, const CPyRef& obj) { return ((typename S::Implementation*) this_)->UnpackDataType(obj); }
			static CPyRef CPythonLibraryInterface_UnpackData(maxon::GenericComponent* this_, const CPyRef& obj) { return ((typename S::Implementation*) this_)->UnpackData(obj); }
			static CPyConstRef CPythonLibraryInterface_CPy_None(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_None(); }
			static CPyConstRef CPythonLibraryInterface_CPy_True(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_True(); }
			static CPyConstRef CPythonLibraryInterface_CPy_False(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_False(); }
			static CPyConstRef CPythonLibraryInterface_CPy_NotImplemented(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPy_NotImplemented(); }
			static void CPythonLibraryInterface_CPyErr_Print(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyErr_Print(); }
			static void CPythonLibraryInterface_CPyErr_Clear(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyErr_Clear(); }
			static Bool CPythonLibraryInterface_CPyErr_Occurred(maxon::GenericComponent* this_, CPyRef* type) { return ((typename S::Implementation*) this_)->CPyErr_Occurred(type); }
			static CPyRef CPythonLibraryInterface_CPyErr_SetString(maxon::GenericComponent* this_, const CPyRef& errorType, const Char* errorString) { return ((typename S::Implementation*) this_)->CPyErr_SetString(errorType, errorString); }
			static CPyRef CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber, const Char* filename) { return ((typename S::Implementation*) this_)->CPyErr_SetWithErrnoAndFilename(errorType, errorNumber, filename); }
			static CPyRef CPythonLibraryInterface_CPyErr_SetWithErrno(maxon::GenericComponent* this_, const CPyRef& errorType, Int32 errorNumber) { return ((typename S::Implementation*) this_)->CPyErr_SetWithErrno(errorType, errorNumber); }
			static CPyRef CPythonLibraryInterface_CPyErr_SetString_1(maxon::GenericComponent* this_, const CPyRef& errorType, const String& errorString) { return ((typename S::Implementation*) this_)->CPyErr_SetString(errorType, errorString); }
			static void CPythonLibraryInterface_CPyErr_SetNone(maxon::GenericComponent* this_, const CPyRef& errorType) { return ((typename S::Implementation*) this_)->CPyErr_SetNone(errorType); }
			static void CPythonLibraryInterface_CPyErr_Fetch(maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_Fetch(type, value, traceback); }
			static void CPythonLibraryInterface_CPyErr_NormalizeException(maxon::GenericComponent* this_, CPyRef& type, CPyRef& value, CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_NormalizeException(type, value, traceback); }
			static void CPythonLibraryInterface_CPyErr_Restore(maxon::GenericComponent* this_, const CPyRef& type, const CPyRef& value, const CPyRef& traceback) { return ((typename S::Implementation*) this_)->CPyErr_Restore(type, value, traceback); }
			static Bool CPythonLibraryInterface_CPyErr_ExceptionMatches(maxon::GenericComponent* this_, const CPyRef& exc) { return ((typename S::Implementation*) this_)->CPyErr_ExceptionMatches(exc); }
			static Bool CPythonLibraryInterface_CPyExceptionClass_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyExceptionClass_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyCapsule_New(const maxon::GenericComponent* this_, void* pointer, const Char* name, CPyCapsule_Destructor* destructor) { return ((const typename S::Implementation*) this_)->CPyCapsule_New(pointer, name, destructor); }
			static Bool CPythonLibraryInterface_CPyCapsule_SetPointer(maxon::GenericComponent* this_, const CPyRef& capsule, void* pointer) { return ((typename S::Implementation*) this_)->CPyCapsule_SetPointer(capsule, pointer); }
			static void* CPythonLibraryInterface_CPyCapsule_GetPointer(maxon::GenericComponent* this_, const CPyRef& capsule, const Char* name) { return ((typename S::Implementation*) this_)->CPyCapsule_GetPointer(capsule, name); }
			static void* CPythonLibraryInterface_CPyCapsule_GetContext(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->CPyCapsule_GetContext(capsule); }
			static Bool CPythonLibraryInterface_CPyCapsule_SetContext(maxon::GenericComponent* this_, const CPyRef& capsule, void* context) { return ((typename S::Implementation*) this_)->CPyCapsule_SetContext(capsule, context); }
			static Bool CPythonLibraryInterface_CPyCapsule_CheckExact(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyCapsule_CheckExact(o); }
			static Bool CPythonLibraryInterface_CPyTraceBack_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyTraceBack_Check(o); }
			static Bool CPythonLibraryInterface_CPyClass_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyClass_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyTuple_New(const maxon::GenericComponent* this_, UInt size) { return ((const typename S::Implementation*) this_)->CPyTuple_New(size); }
			static UInt CPythonLibraryInterface_CPyTuple_Size(maxon::GenericComponent* this_, const CPyRef& tuple) { return ((typename S::Implementation*) this_)->CPyTuple_Size(tuple); }
			static CPyRef CPythonLibraryInterface_CPyTuple_GetItem(maxon::GenericComponent* this_, const CPyRef& tuple, UInt index) { return ((typename S::Implementation*) this_)->CPyTuple_GetItem(tuple, index); }
			static Bool CPythonLibraryInterface_CPyTuple_SetItem(maxon::GenericComponent* this_, const CPyRef& tuple, UInt index, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyTuple_SetItem(tuple, index, item); }
			static CPyRef CPythonLibraryInterface_CPyTuple_GetSlice(maxon::GenericComponent* this_, const CPyRef& tuple, UInt from, UInt to) { return ((typename S::Implementation*) this_)->CPyTuple_GetSlice(tuple, from, to); }
			static Bool CPythonLibraryInterface_CPyTuple_CheckExact(maxon::GenericComponent* this_, const CPyRef& tuple) { return ((typename S::Implementation*) this_)->CPyTuple_CheckExact(tuple); }
			static Bool CPythonLibraryInterface_CPyObject_HasAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* attrName) { return ((typename S::Implementation*) this_)->CPyObject_HasAttrString(o, attrName); }
			static Bool CPythonLibraryInterface_CPyObject_SetAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* name, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyObject_SetAttrString(o, name, item); }
			static CPyRef CPythonLibraryInterface_CPyObject_GetAttrString(maxon::GenericComponent* this_, const CPyRef& o, const Char* name) { return ((typename S::Implementation*) this_)->CPyObject_GetAttrString(o, name); }
			static CPyRef CPythonLibraryInterface_CPyObject_Call(maxon::GenericComponent* this_, const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) { return ((typename S::Implementation*) this_)->CPyObject_Call(callable_object, tupleArg, kw); }
			static CPyRef CPythonLibraryInterface_CPyObject_Str(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Str(o); }
			static CPyRef CPythonLibraryInterface_CPyObject_Repr(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Repr(o); }
			static CPyRef CPythonLibraryInterface_CPyObject_Dir(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Dir(o); }
			static CPyRef CPythonLibraryInterface_CPyObject_RichCompare(maxon::GenericComponent* this_, const CPyRef& o1, const CPyRef& o2, Int32 opid) { return ((typename S::Implementation*) this_)->CPyObject_RichCompare(o1, o2, opid); }
			static Int64 CPythonLibraryInterface_CPyObject_Hash(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Hash(o); }
			static Bool CPythonLibraryInterface_CPyObject_IsTrue(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_IsTrue(o); }
			static Bool CPythonLibraryInterface_CPyObject_Not(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Not(o); }
			static Bool CPythonLibraryInterface_CPyCallable_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyCallable_Check(o); }
			static Int CPythonLibraryInterface_CPyObject_Length(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_Length(o); }
			static CPyRef CPythonLibraryInterface_CPyObject_GetItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyObject_GetItem(o, key); }
			static CPyRef CPythonLibraryInterface_CPyObject_GetItemInt(maxon::GenericComponent* this_, const CPyRef& o, Int index) { return ((typename S::Implementation*) this_)->CPyObject_GetItemInt(o, index); }
			static CPyRef CPythonLibraryInterface_CPyObject_GetItemString(maxon::GenericComponent* this_, const CPyRef& o, const Char* index) { return ((typename S::Implementation*) this_)->CPyObject_GetItemString(o, index); }
			static Bool CPythonLibraryInterface_CPyObject_DelItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyObject_DelItem(o, key); }
			static Bool CPythonLibraryInterface_CPyObject_SetItem(maxon::GenericComponent* this_, const CPyRef& o, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyObject_SetItem(o, key, item); }
			static Bool CPythonLibraryInterface_CPyObject_TypeCheck(maxon::GenericComponent* this_, const CPyRef& object, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyObject_TypeCheck(object, type); }
			static CPyRef CPythonLibraryInterface_CPyObject_CallFunction(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyObject_CallFunction(o); }
			static CPyRef CPythonLibraryInterface_CPySys_GetObject(maxon::GenericComponent* this_, const Char* name) { return ((typename S::Implementation*) this_)->CPySys_GetObject(name); }
			static Bool CPythonLibraryInterface_CPySys_SetObject(maxon::GenericComponent* this_, const Char* name, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPySys_SetObject(name, o); }
			static Result<void> CPythonLibraryInterface_CPy_SetPath(maxon::GenericComponent* this_, const BaseArray<Url>& paths) { return ((typename S::Implementation*) this_)->CPy_SetPath(paths); }
			static Result<void> CPythonLibraryInterface_CPySys_SetPath(maxon::GenericComponent* this_, const BaseArray<Url>& paths, PATHHANDLE add) { return ((typename S::Implementation*) this_)->CPySys_SetPath(paths, add); }
			static Result<void> CPythonLibraryInterface_CPySys_SetArgvEx(maxon::GenericComponent* this_, const BaseArray<String>& args, Bool updatepath) { return ((typename S::Implementation*) this_)->CPySys_SetArgvEx(args, updatepath); }
			static BaseArray<Url> CPythonLibraryInterface_CPySys_GetPath(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySys_GetPath(); }
			static Result<void> CPythonLibraryInterface_CPySite_AddSiteDir(maxon::GenericComponent* this_, const Url& siteDir) { return ((typename S::Implementation*) this_)->CPySite_AddSiteDir(siteDir); }
			static Bool CPythonLibraryInterface_CPyUnicode_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyUnicode_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyUnicode_FromString(const maxon::GenericComponent* this_, const Char* str) { return ((const typename S::Implementation*) this_)->CPyUnicode_FromString(str); }
			static CPyRef CPythonLibraryInterface_CPyUnicode_FromStringAndSize(maxon::GenericComponent* this_, const Block<const Char>& block) { return ((typename S::Implementation*) this_)->CPyUnicode_FromStringAndSize(block); }
			static Result<String> CPythonLibraryInterface_CPyUnicode_AsString(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyUnicode_AsString(str); }
			static const Char* CPythonLibraryInterface_CPyUnicode_AsCString(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyUnicode_AsCString(str); }
			static Int CPythonLibraryInterface_CPyUnicode_GetLength(maxon::GenericComponent* this_, const CPyRef& str) { return ((typename S::Implementation*) this_)->CPyUnicode_GetLength(str); }
			static CPyRef CPythonLibraryInterface_CPyObject_GetIter(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->CPyObject_GetIter(o); }
			static CPyRef CPythonLibraryInterface_CPyIter_Next(const maxon::GenericComponent* this_, const CPyRef& it) { return ((const typename S::Implementation*) this_)->CPyIter_Next(it); }
			static CPyRef CPythonLibraryInterface_CPyDict_New(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPyDict_New(); }
			static CPyRef CPythonLibraryInterface_CPyDict_GetItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) { return ((typename S::Implementation*) this_)->CPyDict_GetItem(dict, key, raiseKeyError); }
			static CPyRef CPythonLibraryInterface_CPyDict_GetItemString(maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, Bool raiseKeyError) { return ((typename S::Implementation*) this_)->CPyDict_GetItemString(dict, key, raiseKeyError); }
			static Bool CPythonLibraryInterface_CPyDict_SetItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyDict_SetItem(dict, key, item); }
			static Bool CPythonLibraryInterface_CPyDict_DelItem(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyDict_DelItem(dict, key); }
			static CONTAINS CPythonLibraryInterface_CPyDict_Contains(maxon::GenericComponent* this_, const CPyRef& dict, const CPyRef& key) { return ((typename S::Implementation*) this_)->CPyDict_Contains(dict, key); }
			static void CPythonLibraryInterface_CPyDict_Clear(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Clear(dict); }
			static Bool CPythonLibraryInterface_CPyDict_Next(maxon::GenericComponent* this_, const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) { return ((typename S::Implementation*) this_)->CPyDict_Next(dict, pos, key, value); }
			static CPyRef CPythonLibraryInterface_CPyDict_Keys(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Keys(dict); }
			static CPyRef CPythonLibraryInterface_CPyDict_Values(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Values(dict); }
			static CPyRef CPythonLibraryInterface_CPyDict_Items(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Items(dict); }
			static Int CPythonLibraryInterface_CPyDict_Size(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Size(dict); }
			static CPyRef CPythonLibraryInterface_CPyDict_Copy(maxon::GenericComponent* this_, const CPyRef& dict) { return ((typename S::Implementation*) this_)->CPyDict_Copy(dict); }
			static Bool CPythonLibraryInterface_CPyDict_SetItemString(const maxon::GenericComponent* this_, const CPyRef& dict, const Char* key, const CPyRef& item) { return ((const typename S::Implementation*) this_)->CPyDict_SetItemString(dict, key, item); }
			static Bool CPythonLibraryInterface_CPyDict_Check(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->CPyDict_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyList_New(maxon::GenericComponent* this_, UInt size) { return ((typename S::Implementation*) this_)->CPyList_New(size); }
			static Bool CPythonLibraryInterface_CPyList_CheckExact(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_CheckExact(list); }
			static Bool CPythonLibraryInterface_CPyList_Clear(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Clear(list); }
			static Int CPythonLibraryInterface_CPyList_Size(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Size(list); }
			static CPyRef CPythonLibraryInterface_CPyList_GetItem(maxon::GenericComponent* this_, const CPyRef& list, UInt index) { return ((typename S::Implementation*) this_)->CPyList_GetItem(list, index); }
			static Bool CPythonLibraryInterface_CPyList_SetItem(maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_SetItem(list, anonymous_param_2, item); }
			static Bool CPythonLibraryInterface_CPyList_Insert(maxon::GenericComponent* this_, const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_Insert(list, anonymous_param_2, item); }
			static Bool CPythonLibraryInterface_CPyList_Append(maxon::GenericComponent* this_, const CPyRef& list, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_Append(list, item); }
			static CPyRef CPythonLibraryInterface_CPyList_GetSlice(maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to) { return ((typename S::Implementation*) this_)->CPyList_GetSlice(list, from, to); }
			static Bool CPythonLibraryInterface_CPyList_SetSlice(maxon::GenericComponent* this_, const CPyRef& list, UInt from, UInt to, const CPyRef& item) { return ((typename S::Implementation*) this_)->CPyList_SetSlice(list, from, to, item); }
			static Bool CPythonLibraryInterface_CPyList_Sort(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Sort(list); }
			static Bool CPythonLibraryInterface_CPyList_Reverse(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_Reverse(list); }
			static CPyRef CPythonLibraryInterface_CPyList_AsTuple(maxon::GenericComponent* this_, const CPyRef& list) { return ((typename S::Implementation*) this_)->CPyList_AsTuple(list); }
			static Bool CPythonLibraryInterface_CPyDict_DelItemString(maxon::GenericComponent* this_, const CPyRef& p, const Char* key) { return ((typename S::Implementation*) this_)->CPyDict_DelItemString(p, key); }
			static Bool CPythonLibraryInterface_CPyModule_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyModule_Check(o); }
			static Result<Bool> CPythonLibraryInterface_CPyModule_AddObject(maxon::GenericComponent* this_, const CPyRef& module, const Char* name, const CPyRef& value) { return ((typename S::Implementation*) this_)->CPyModule_AddObject(module, name, value); }
			static Bool CPythonLibraryInterface_CPyModule_AddType(maxon::GenericComponent* this_, const CPyRef& module, const CPyTypeRef& value) { return ((typename S::Implementation*) this_)->CPyModule_AddType(module, value); }
			static CPyRef CPythonLibraryInterface_CPyModule_GetDict(maxon::GenericComponent* this_, const CPyRef& module) { return ((typename S::Implementation*) this_)->CPyModule_GetDict(module); }
			static Bool CPythonLibraryInterface_CPyModule_AddIntConstant(maxon::GenericComponent* this_, const CPyRef& mod, const Char* name, long value) { return ((typename S::Implementation*) this_)->CPyModule_AddIntConstant(mod, name, value); }
			static CPyRef CPythonLibraryInterface_CPyImport_ImportModule(maxon::GenericComponent* this_, const Char* name) { return ((typename S::Implementation*) this_)->CPyImport_ImportModule(name); }
			static CPyRef CPythonLibraryInterface_CPyImport_GetImporter(maxon::GenericComponent* this_, const CPyRef& path) { return ((typename S::Implementation*) this_)->CPyImport_GetImporter(path); }
			static CPyRef CPythonLibraryInterface_CPyImport_GetModuleDict(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyImport_GetModuleDict(); }
			static Bool CPythonLibraryInterface_CPyType_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyType_Check(o); }
			static Bool CPythonLibraryInterface_CPyType_IsSubtype(maxon::GenericComponent* this_, const CPyTypeRef& a, const CPyTypeRef& b) { return ((typename S::Implementation*) this_)->CPyType_IsSubtype(a, b); }
			static Bool CPythonLibraryInterface_CPyType_HasFeature(const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) this_)->CPyType_HasFeature(type, f); }
			static Bool CPythonLibraryInterface_CPyType_FastSubclass(const maxon::GenericComponent* this_, const CPyTypeRef& type, Int64 f) { return ((const typename S::Implementation*) this_)->CPyType_FastSubclass(type, f); }
			static Result<String> CPythonLibraryInterface_CPyType_GetName(maxon::GenericComponent* this_, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyType_GetName(type); }
			static Bool CPythonLibraryInterface_CPyType_Ready(maxon::GenericComponent* this_, CPyTypeRef& type) { return ((typename S::Implementation*) this_)->CPyType_Ready(type); }
			static NativePyThreadState* CPythonLibraryInterface_CPyEval_SaveThread(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_SaveThread(); }
			static void CPythonLibraryInterface_CPyEval_RestoreThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_RestoreThread(state); }
			static Bool CPythonLibraryInterface_CPyEval_ThreadsInitialized(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_ThreadsInitialized(); }
			static void CPythonLibraryInterface_CPyEval_InitThreads(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyEval_InitThreads(); }
			static void CPythonLibraryInterface_CPyEval_AcquireThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_AcquireThread(state); }
			static void CPythonLibraryInterface_CPyEval_ReleaseThread(maxon::GenericComponent* this_, NativePyThreadState* state) { return ((typename S::Implementation*) this_)->CPyEval_ReleaseThread(state); }
			static CPyRef CPythonLibraryInterface_CPyEval_GetBuiltins(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CPyEval_GetBuiltins(); }
			static CPyRef CPythonLibraryInterface_CPyEval_EvalCode(const maxon::GenericComponent* this_, const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) { return ((const typename S::Implementation*) this_)->CPyEval_EvalCode(code, globals, locals); }
			static Bool CPythonLibraryInterface_CPyFloat_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyFloat_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyFloat_FromFloat32(maxon::GenericComponent* this_, Float32 value) { return ((typename S::Implementation*) this_)->CPyFloat_FromFloat32(value); }
			static CPyRef CPythonLibraryInterface_CPyFloat_FromFloat64(maxon::GenericComponent* this_, Float64 value) { return ((typename S::Implementation*) this_)->CPyFloat_FromFloat64(value); }
			static Float64 CPythonLibraryInterface_CPyFloat_AsFloat64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyFloat_AsFloat64(o); }
			static Bool CPythonLibraryInterface_CPyLong_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_Check(o); }
			static CPyRef CPythonLibraryInterface_CPyBool_FromBool(maxon::GenericComponent* this_, Bool value) { return ((typename S::Implementation*) this_)->CPyBool_FromBool(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromInt16(maxon::GenericComponent* this_, Int16 value) { return ((typename S::Implementation*) this_)->CPyLong_FromInt16(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromUInt16(maxon::GenericComponent* this_, UInt16 value) { return ((typename S::Implementation*) this_)->CPyLong_FromUInt16(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromInt32(maxon::GenericComponent* this_, Int32 value) { return ((typename S::Implementation*) this_)->CPyLong_FromInt32(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromUInt32(maxon::GenericComponent* this_, UInt32 value) { return ((typename S::Implementation*) this_)->CPyLong_FromUInt32(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromInt64(maxon::GenericComponent* this_, Int64 value) { return ((typename S::Implementation*) this_)->CPyLong_FromInt64(value); }
			static CPyRef CPythonLibraryInterface_CPyLong_FromUInt64(maxon::GenericComponent* this_, UInt64 value) { return ((typename S::Implementation*) this_)->CPyLong_FromUInt64(value); }
			static Int16 CPythonLibraryInterface_CPyLong_AsInt16(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsInt16(o); }
			static UInt16 CPythonLibraryInterface_CPyLong_AsUInt16(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsUInt16(o); }
			static Int32 CPythonLibraryInterface_CPyLong_AsInt32(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsInt32(o); }
			static UInt32 CPythonLibraryInterface_CPyLong_AsUInt32(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsUInt32(o); }
			static Int64 CPythonLibraryInterface_CPyLong_AsInt64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsInt64(o); }
			static UInt64 CPythonLibraryInterface_CPyLong_AsUInt64(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyLong_AsUInt64(o); }
			static Bool CPythonLibraryInterface_CPyNumber_Check(maxon::GenericComponent* this_, const CPyRef& o) { return ((typename S::Implementation*) this_)->CPyNumber_Check(o); }
			static MPyFunctionRef CPythonLibraryInterface_MPyFunction_New(maxon::GenericComponent* this_, const reflection::Function* func) { return ((typename S::Implementation*) this_)->MPyFunction_New(func); }
			static MPyHashMapRef CPythonLibraryInterface_MPyHashMap_New(maxon::GenericComponent* this_, const HashMap<Data, Data>& map) { return ((typename S::Implementation*) this_)->MPyHashMap_New(map); }
			static MPyHashMapRef CPythonLibraryInterface_MPyHashMap_New_1(maxon::GenericComponent* this_, HashMap<Data, Data>&& map) { return ((typename S::Implementation*) this_)->MPyHashMap_New(std::forward<HashMap<Data, Data>>(map)); }
			static MPyMemberRef CPythonLibraryInterface_MPyMember_New(maxon::GenericComponent* this_, const reflection::Member* member) { return ((typename S::Implementation*) this_)->MPyMember_New(member); }
			static Result<void> CPythonLibraryInterface_CPyMem_SetAllocator(maxon::GenericComponent* this_, CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) { return ((typename S::Implementation*) this_)->CPyMem_SetAllocator(std::forward<CPyMemAllocatorDomain>(domain), allocator); }
			static MPyClassRef CPythonLibraryInterface_MPyClass_New(maxon::GenericComponent* this_, const reflection::Class* cls) { return ((typename S::Implementation*) this_)->MPyClass_New(cls); }
			static Int32* CPythonLibraryInterface_CPy_DebugFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_DebugFlag(); }
			static Int32* CPythonLibraryInterface_CPy_VerboseFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_VerboseFlag(); }
			static Int32* CPythonLibraryInterface_CPy_InteractiveFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_InteractiveFlag(); }
			static Int32* CPythonLibraryInterface_CPy_InspectFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_InspectFlag(); }
			static Int32* CPythonLibraryInterface_CPy_OptimizeFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_OptimizeFlag(); }
			static Int32* CPythonLibraryInterface_CPy_NoSiteFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_NoSiteFlag(); }
			static Int32* CPythonLibraryInterface_CPy_BytesWarningFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_BytesWarningFlag(); }
			static Int32* CPythonLibraryInterface_CPy_FrozenFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_FrozenFlag(); }
			static Int32* CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_IgnoreEnvironmentFlag(); }
			static Int32* CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_DontWriteBytecodeFlag(); }
			static Int32* CPythonLibraryInterface_CPy_NoUserSiteDirectory(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPy_NoUserSiteDirectory(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_BaseException(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BaseException(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_Exception(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_Exception(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_StopIteration(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_StopIteration(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_GeneratorExit(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_GeneratorExit(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_StandardError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_StandardError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ArithmeticError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ArithmeticError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_LookupError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_LookupError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_AssertionError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_AssertionError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_AttributeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_AttributeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_EOFError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_EOFError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_FloatingPointError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_FloatingPointError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_EnvironmentError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_EnvironmentError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_IOError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IOError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_OSError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_OSError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ImportError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ImportError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_IndexError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IndexError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_KeyError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_KeyError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_KeyboardInterrupt(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_KeyboardInterrupt(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_MemoryError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_MemoryError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_NameError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_NameError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_OverflowError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_OverflowError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_RuntimeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_RuntimeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_NotImplementedError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_NotImplementedError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_SyntaxError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SyntaxError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_IndentationError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_IndentationError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_TabError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_TabError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ReferenceError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ReferenceError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_SystemError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SystemError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_SystemExit(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SystemExit(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_TypeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_TypeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnboundLocalError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnboundLocalError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnicodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnicodeEncodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeEncodeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnicodeDecodeError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeDecodeError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnicodeTranslateError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeTranslateError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ValueError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ValueError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ZeroDivisionError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ZeroDivisionError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_WindowsError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_WindowsError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_BufferError(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BufferError(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_MemoryErrorInst(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_MemoryErrorInst(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_Warning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_Warning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UserWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UserWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_DeprecationWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_DeprecationWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_PendingDeprecationWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_SyntaxWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_SyntaxWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_RuntimeWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_RuntimeWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_FutureWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_FutureWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_ImportWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_ImportWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_UnicodeWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_UnicodeWarning(); }
			static CPyConstRef CPythonLibraryInterface_CPyExc_BytesWarning(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyExc_BytesWarning(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyNullImporter_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyNullImporter_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPySuper_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySuper_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyBool_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyBool_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyObject_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyObject_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyModule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyModule_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyUnicode_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyUnicode_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyLong_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyLong_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyFloat_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyFloat_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyTuple_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyTuple_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyList_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyList_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyDict_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyDict_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyClass_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyClass_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyTraceBack_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyTraceBack_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPySlice_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPySlice_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyType_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyType_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyMemoryView_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyMemoryView_Type(); }
			static const PyChar* CPythonLibraryInterface_ConvertAndCacheString(maxon::GenericComponent* this_, const String& str, PyStringEncodings encoding, UInt* size) { return ((typename S::Implementation*) this_)->ConvertAndCacheString(str, std::forward<PyStringEncodings>(encoding), size); }
			static Result<void> CPythonLibraryInterface_RegisterSpecificPythonClass(maxon::GenericComponent* this_, const Id& typeId, const CPyTypeRef& type) { return ((typename S::Implementation*) this_)->RegisterSpecificPythonClass(typeId, type); }
			static Result<void> CPythonLibraryInterface_PrivateRegisterBuiltinConverter(maxon::GenericComponent* this_, const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) { return ((typename S::Implementation*) this_)->PrivateRegisterBuiltinConverter(dt, f1, f2); }
			static Result<void> CPythonLibraryInterface_GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) { return S::Implementation::GetUrl(pythonPath, pythonLibrary, pythonHome); }
			static Url CPythonLibraryInterface_GetSpecialPath(maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1) { return ((typename S::Implementation*) this_)->GetSpecialPath(anonymous_param_1); }
			static void CPythonLibraryInterface_RegisterSpecialPath(maxon::GenericComponent* this_, SPECIALPATH anonymous_param_1, const Url& path) { return ((typename S::Implementation*) this_)->RegisterSpecialPath(anonymous_param_1, path); }
			static CPyTypeConstRef CPythonLibraryInterface_MPyDataCapsule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->MPyDataCapsule_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyData_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyData_Type(); }
			static CPyTypeConstRef CPythonLibraryInterface_CPyCapsule_Type(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->CPyCapsule_Type(); }
			static CPyRef CPythonLibraryInterface_PrivateGetCurrentCallerContext(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->PrivateGetCurrentCallerContext(); }
			static CPyRef CPythonLibraryInterface_MPyDataType_ToMapperInstance(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->MPyDataType_ToMapperInstance(capsule); }
			static CPyRef CPythonLibraryInterface_MPyData_ToMapperInstance(maxon::GenericComponent* this_, const MPyDataRef& capsule) { return ((typename S::Implementation*) this_)->MPyData_ToMapperInstance(capsule); }
			static CPyRef CPythonLibraryInterface_CPyObject_ToMapperInstance(maxon::GenericComponent* this_, const DataType& dt, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->CPyObject_ToMapperInstance(dt, capsule); }
			static Result<void> CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(maxon::GenericComponent* this_, const DataType& dt, const CPyRef& type) { return ((typename S::Implementation*) this_)->AssociateDataTypeWithPythonTypes(dt, type); }
			static Result<CPyRef> CPythonLibraryInterface_GetAssociatedDataType(maxon::GenericComponent* this_, const DataType& dt) { return ((typename S::Implementation*) this_)->GetAssociatedDataType(dt); }
			static DelegatePyObject_FromData<>* CPythonLibraryInterface_GetConverterPyObject_FromData(maxon::GenericComponent* this_, const DataType& dt) { return ((typename S::Implementation*) this_)->GetConverterPyObject_FromData(dt); }
			static MPyDataRef CPythonLibraryInterface_MPyData_New(maxon::GenericComponent* this_, Data& data) { return ((typename S::Implementation*) this_)->MPyData_New(data); }
			static MPyDataRef CPythonLibraryInterface_MPyData_New_1(maxon::GenericComponent* this_, const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) { return ((typename S::Implementation*) this_)->MPyData_New(dt, data, owner, mapDt); }
			static MPyDataTypeRef CPythonLibraryInterface_MPyDataType_New(maxon::GenericComponent* this_, const DataType& dt) { return ((typename S::Implementation*) this_)->MPyDataType_New(dt); }
			static Bool CPythonLibraryInterface_MPyDataType_CheckExact(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->MPyDataType_CheckExact(o); }
			static const DataType& CPythonLibraryInterface_MPyDataType_GetDataType(const maxon::GenericComponent* this_, const MPyDataTypeRef& o) { return ((const typename S::Implementation*) this_)->MPyDataType_GetDataType(o); }
			static Bool CPythonLibraryInterface_MPyData_CheckExact(const maxon::GenericComponent* this_, const CPyRef& o) { return ((const typename S::Implementation*) this_)->MPyData_CheckExact(o); }
			static Result<Data*> CPythonLibraryInterface_CPyObject_AsData(maxon::GenericComponent* this_, Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) { return ((typename S::Implementation*) this_)->CPyObject_AsData(stackDepth, obj, expected, k, n); }
			static Result<BaseArray<TYPE_CONVERSION_TUPLE>> CPythonLibraryInterface_GetRegisteredTypesWithConversions(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->GetRegisteredTypesWithConversions(); }
			static Result<DataType> CPythonLibraryInterface_ParseDataType(maxon::GenericComponent* this_, const CPyRef& args, Int32 argIndex, Bool canBeNone) { return ((typename S::Implementation*) this_)->ParseDataType(args, argIndex, canBeNone); }
			static void CPythonLibraryInterface_SetError(maxon::GenericComponent* this_, const Error& err) { return ((typename S::Implementation*) this_)->SetError(err); }
			static void CPythonLibraryInterface_SetError_1(maxon::GenericComponent* this_, const ErrorPtr& err) { return ((typename S::Implementation*) this_)->SetError(err); }
			static CPyRef CPythonLibraryInterface_MaxonConvertAuto(maxon::GenericComponent* this_, const CPyRef& capsule) { return ((typename S::Implementation*) this_)->MaxonConvertAuto(capsule); }
			static CPyRef CPythonLibraryInterface_CPyObject_FromGeneric(maxon::GenericComponent* this_, const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) { return ((typename S::Implementation*) this_)->CPyObject_FromGeneric(origDt, object, ownership, expected, count); }
			static CPyRef CPythonLibraryInterface_CreateGlobalDictionary(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->CreateGlobalDictionary(); }
			static Result<BaseArray<SourceLocation>> CPythonLibraryInterface_GetCurrentTraceback(maxon::GenericComponent* this_) { return ((typename S::Implementation*) this_)->GetCurrentTraceback(); }
			static Class<CPyRef> CPythonLibraryInterface_GetCPyRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyRefClass(); }
			static Class<CPyTypeRef> CPythonLibraryInterface_GetCPyTypeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyTypeRefClass(); }
			static Class<CPyFrameRef> CPythonLibraryInterface_GetCPyFrameRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyFrameRefClass(); }
			static Class<CPyTracebackRef> CPythonLibraryInterface_GetCPyTracebackRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyTracebackRefClass(); }
			static Class<CPyCodeRef> CPythonLibraryInterface_GetCPyCodeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetCPyCodeRefClass(); }
			static Class<MPyClassRef> CPythonLibraryInterface_GetMPyClassRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyClassRefClass(); }
			static Class<MPyMemberRef> CPythonLibraryInterface_GetMPyMemberRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyMemberRefClass(); }
			static Class<MPyFunctionRef> CPythonLibraryInterface_GetMPyFunctionRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyFunctionRefClass(); }
			static Class<MPyHashMapRef> CPythonLibraryInterface_GetMPyHashMapRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyHashMapRefClass(); }
			static Class<MPyDataTypeRef> CPythonLibraryInterface_GetMPyDataTypeRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyDataTypeRefClass(); }
			static Class<MPyDataRef> CPythonLibraryInterface_GetMPyDataRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyDataRefClass(); }
			static Class<MPyCallerContextRef> CPythonLibraryInterface_GetMPyCallerContextRefClass(const maxon::GenericComponent* this_) { return ((const typename S::Implementation*) this_)->GetMPyCallerContextRefClass(); }
		};

	};
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION>
	{
		return Hxx2::StaticMTable::_instance.CPythonLibraryInterface_ParseCommandLine(args, res, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_Init((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitTypes() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_InitTypes((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_InitTypes_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::InitBuiltinModules() -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_InitBuiltinModules((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Initialize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_Initialize((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Initialize_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Finalize() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_Finalize((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Finalize_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Create(const ModuleDefinition& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_Create((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Create_Offset, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Free(const Delegate<void()>& shutdownEngine) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_Free((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_Free_Offset, shutdownEngine);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetDll() const -> const PythonDll&
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetDll((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetDll_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::FopenNative(const Char* name, const Char* mode) -> FILE_native*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_FopenNative((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_FopenNative_Offset, name, mode);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> Error
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_LastPythonCallFailed((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) -> Result<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_RegisterComponentProxy((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_IsInitialized((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetVersion() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetVersion((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPlatform() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetPlatform((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCopyright() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetCopyright((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetCompiler() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetCompiler((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetBuildInfo() -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetBuildInfo((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetProgramName(const String& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_SetProgramName((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_SetPythonHome((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetProgramName() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetProgramName((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_GetPythonHome() -> String
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_GetPythonHome((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ExecuteModule(const String& name) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_ExecuteModule((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ExecuteModule_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallerContext_New() -> MPyCallerContextRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCallerContext_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> NativePyObject*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyRun_FileExFlags((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Ensure() -> PYGILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyGilState_Ensure((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGilState_Release(PYGILSTATE state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyGilState_Release((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetGilState() const -> GILSTATE
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetGilState((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetGilState_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGILState_GetThisThreadState() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_Swap(NativePyThreadState* state) -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyThreadState_Swap((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyThreadState_GetDict() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyThreadState_GetDict((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> CPyCodeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_CompileStringFlags((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Incref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_Incref((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Incref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_Decref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_Decref((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_Decref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeIncref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_SafeIncref((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SafeIncref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SafeDecref(NativePyObject* o) const -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_SafeDecref((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SafeDecref_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyGC_Collect() -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyGC_Collect((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCode_Addr2Line((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackDataType(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_UnpackDataType((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_UnpackDataType_Offset, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::UnpackData(const CPyRef& obj) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_UnpackData((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_UnpackData_Offset, obj);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_None() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_None((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_None_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_True() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_True((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_True_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_False() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_False((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_False_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NotImplemented() const -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_NotImplemented((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NotImplemented_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Print() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_Print((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Print_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Clear() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_Clear((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Occurred(CPyRef* type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_Occurred((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_SetString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_SetWithErrno((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_SetString_1((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_SetNone(const CPyRef& errorType) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_SetNone((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_Fetch((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_NormalizeException((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_Restore((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyErr_ExceptionMatches(const CPyRef& exc) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExceptionClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExceptionClass_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_New((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_New_Offset, pointer, name, destructor);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_SetPointer((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_GetPointer((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_GetContext(const CPyRef& capsule) -> void*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_GetContext((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_SetContext((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_CheckExact(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_CheckExact((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTraceBack_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyClass_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyClass_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_New(UInt size) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_New((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_New_Offset, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Size(const CPyRef& tuple) -> UInt
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_Size((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_GetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_SetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_GetSlice((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_CheckExact(const CPyRef& tuple) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_CheckExact((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_HasAttrString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_SetAttrString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_GetAttrString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Call((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Str(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Str((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Str_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Repr(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Repr((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Dir(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Dir((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_RichCompare((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Hash(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Hash((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_IsTrue(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_IsTrue((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Not(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Not((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Not_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCallable_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCallable_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Length(const CPyRef& o) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Length((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Length_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_GetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemInt(const CPyRef& o, Int index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_GetItemInt((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_GetItemString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_DelItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_SetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_TypeCheck((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_CallFunction(const CPyRef& o) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_CallFunction((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetObject(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySys_GetObject((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetObject(const Char* name, const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySys_SetObject((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset, name, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_SetPath(const BaseArray<Url>& paths) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_SetPath((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_SetPath_Offset, paths);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySys_SetPath((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySys_SetArgvEx((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySys_GetPath() -> BaseArray<Url>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySys_GetPath((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySite_AddSiteDir((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_FromString(const Char* str) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_FromString((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_FromString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_FromStringAndSize(const Block<const Char>& block) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset, block);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_AsString(const CPyRef& str) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_AsString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_AsCString(const CPyRef& str) -> const Char*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_AsCString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_GetLength(const CPyRef& str) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_GetLength((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset, str);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_GetIter(const CPyRef& o) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_GetIter((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_GetIter_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyIter_Next(const CPyRef& it) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyIter_Next((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyIter_Next_Offset, it);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_New() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_New((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_New_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_GetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_GetItemString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_SetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_DelItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> CONTAINS
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Contains((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Clear(const CPyRef& dict) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Clear((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Next((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Keys(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Keys((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Values(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Values((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Values_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Items(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Items((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Items_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Size(const CPyRef& dict) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Size((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Size_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Copy(const CPyRef& dict) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Copy((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset, dict);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_SetItemString((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_SetItemString_Offset, dict, key, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Check(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Check((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_New(UInt size) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_New_Offset, size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_CheckExact(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_CheckExact((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Clear(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Clear((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Clear_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Size(const CPyRef& list) -> Int
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Size((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Size_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetItem(const CPyRef& list, UInt index) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_GetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset, list, index);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_SetItem((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Insert((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Append(const CPyRef& list, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Append((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Append_Offset, list, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_GetSlice((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_SetSlice((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Sort(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Sort((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Sort_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Reverse(const CPyRef& list) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Reverse((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_AsTuple(const CPyRef& list) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_AsTuple((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset, list);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_DelItemString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> Result<Bool>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_AddObject((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_AddType((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset, module, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_GetDict(const CPyRef& module) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_GetDict((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset, module);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_AddIntConstant((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_ImportModule(const Char* name) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyImport_ImportModule((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset, name);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_GetImporter(const CPyRef& path) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyImport_GetImporter((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyImport_GetModuleDict() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyImport_GetModuleDict((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_IsSubtype((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_HasFeature((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_HasFeature_Offset, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_FastSubclass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_FastSubclass_Offset, type, f);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_GetName((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_GetName_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Ready(CPyTypeRef& type) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_Ready((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Ready_Offset, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_SaveThread() -> NativePyThreadState*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_SaveThread((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_RestoreThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_RestoreThread((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ThreadsInitialized() -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_InitThreads() -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_InitThreads((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_AcquireThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_AcquireThread((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_ReleaseThread(NativePyThreadState* state) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_ReleaseThread((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_GetBuiltins() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_GetBuiltins((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_GetBuiltins_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyEval_EvalCode((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyEval_EvalCode_Offset, code, globals, locals);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyFloat_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat32(Float32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyFloat_FromFloat32((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_FromFloat64(Float64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyFloat_FromFloat64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_AsFloat64(const CPyRef& o) -> Float64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyFloat_AsFloat64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_FromBool(Bool value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyBool_FromBool((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt16(Int16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromInt16((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt16(UInt16 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromUInt16((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt32(Int32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromInt32((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt32(UInt32 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromUInt32((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromInt64(Int64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromInt64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_FromUInt64(UInt64 value) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_FromUInt64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset, value);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt16(const CPyRef& o) -> Int16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsInt16((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt16(const CPyRef& o) -> UInt16
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsUInt16((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt32(const CPyRef& o) -> Int32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsInt32((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt32(const CPyRef& o) -> UInt32
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsUInt32((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsInt64(const CPyRef& o) -> Int64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsInt64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_AsUInt64(const CPyRef& o) -> UInt64
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_AsUInt64((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNumber_Check(const CPyRef& o) -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyNumber_Check((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyFunction_New(const reflection::Function* func) -> MPyFunctionRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyFunction_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyFunction_New_Offset, func);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyHashMap_New(const HashMap<Data, Data>& map) -> MPyHashMapRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyHashMap_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset, map);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyHashMap_New(HashMap<Data, Data>&& map) -> MPyHashMapRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyHashMap_New_1((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset, std::forward<HashMap<Data, Data>>(map));
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyMember_New(const reflection::Member* member) -> MPyMemberRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyMember_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyMember_New_Offset, member);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyMem_SetAllocator((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset, std::forward<CPyMemAllocatorDomain>(domain), allocator);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyClass_New(const reflection::Class* cls) -> MPyClassRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyClass_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyClass_New_Offset, cls);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DebugFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_DebugFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_VerboseFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_VerboseFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InteractiveFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_InteractiveFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_InspectFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_InspectFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_OptimizeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_OptimizeFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoSiteFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_NoSiteFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_BytesWarningFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_BytesWarningFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_FrozenFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_FrozenFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_IgnoreEnvironmentFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_DontWriteBytecodeFlag() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPy_NoUserSiteDirectory() -> Int32*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BaseException() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_BaseException((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Exception() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_Exception((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StopIteration() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_StopIteration((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_GeneratorExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_GeneratorExit((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_StandardError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_StandardError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ArithmeticError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ArithmeticError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_LookupError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_LookupError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AssertionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_AssertionError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_AttributeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_AttributeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EOFError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_EOFError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FloatingPointError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_FloatingPointError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_EnvironmentError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_EnvironmentError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IOError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_IOError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OSError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_OSError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ImportError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndexError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_IndexError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_KeyError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_KeyboardInterrupt() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_MemoryError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NameError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_NameError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_OverflowError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_OverflowError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_RuntimeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_NotImplementedError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_NotImplementedError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_SyntaxError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_IndentationError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_IndentationError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TabError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_TabError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ReferenceError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ReferenceError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_SystemError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SystemExit() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_SystemExit((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_TypeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_TypeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnboundLocalError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnicodeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeEncodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeDecodeError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeTranslateError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ValueError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ValueError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ZeroDivisionError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_WindowsError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_WindowsError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BufferError() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_BufferError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_MemoryErrorInst() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_Warning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_Warning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UserWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UserWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_DeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_PendingDeprecationWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_SyntaxWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_RuntimeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_FutureWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_FutureWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_ImportWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_ImportWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_UnicodeWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyExc_BytesWarning() -> CPyConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyExc_BytesWarning((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyNullImporter_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyNullImporter_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySuper_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySuper_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySuper_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyBool_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyBool_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyBool_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyModule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyModule_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyModule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyUnicode_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyUnicode_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyLong_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyLong_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyLong_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyFloat_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyFloat_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTuple_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTuple_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyList_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyList_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyList_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyDict_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyDict_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyDict_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyClass_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyClass_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyClass_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyTraceBack_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyTraceBack_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPySlice_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPySlice_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPySlice_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyType_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyType_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyType_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyMemoryView_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyMemoryView_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) -> const PyChar*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_ConvertAndCacheString((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset, str, std::forward<PyStringEncodings>(encoding), size);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_RegisterSpecificPythonClass((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void>
	{
		return Hxx2::StaticMTable::_instance.CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetSpecialPath(SPECIALPATH anonymous_param_1) -> Url
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetSpecialPath((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_RegisterSpecialPath((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyDataCapsule_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyData_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyData_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyData_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyCapsule_Type() -> CPyTypeConstRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyCapsule_Type((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::PrivateGetCurrentCallerContext() -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyData_ToMapperInstance((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) -> Result<void>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetAssociatedDataType(const DataType& dt) -> Result<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetAssociatedDataType((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetConverterPyObject_FromData(const DataType& dt) -> DelegatePyObject_FromData<>*
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetConverterPyObject_FromData((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(Data& data) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyData_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_New_Offset, data);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) -> MPyDataRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyData_New_1((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_New(const DataType& dt) -> MPyDataTypeRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyDataType_New((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_New_Offset, dt);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyDataType_CheckExact((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> const DataType&
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyDataType_GetDataType((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyDataType_GetDataType_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MPyData_CheckExact(const CPyRef& o) const -> Bool
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MPyData_CheckExact((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MPyData_CheckExact_Offset, o);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_AsData((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<DataType>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_ParseDataType((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const Error& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_SetError((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_SetError_Offset, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::SetError(const ErrorPtr& err) -> void
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_SetError_1((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_SetError_1_Offset, err);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::MaxonConvertAuto(const CPyRef& capsule) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_MaxonConvertAuto((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CPyObject_FromGeneric((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::CreateGlobalDictionary() const -> CPyRef
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_CreateGlobalDictionary((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_CreateGlobalDictionary_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCurrentTraceback((maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyRefClass() const -> Class<CPyRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCPyRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTypeRefClass() const -> Class<CPyTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCPyTypeRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyTypeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyFrameRefClass() const -> Class<CPyFrameRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCPyFrameRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyFrameRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyTracebackRefClass() const -> Class<CPyTracebackRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCPyTracebackRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyTracebackRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetCPyCodeRefClass() const -> Class<CPyCodeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetCPyCodeRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetCPyCodeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyClassRefClass() const -> Class<MPyClassRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyClassRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyClassRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyMemberRefClass() const -> Class<MPyMemberRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyMemberRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyMemberRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyFunctionRefClass() const -> Class<MPyFunctionRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyFunctionRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyFunctionRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyHashMapRefClass() const -> Class<MPyHashMapRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyHashMapRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyHashMapRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataTypeRefClass() const -> Class<MPyDataTypeRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyDataRefClass() const -> Class<MPyDataRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyDataRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyDataRefClass_Offset);
	}
	MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::GetMPyCallerContextRefClass() const -> Class<MPyCallerContextRef>
	{
		const CPythonLibraryInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, this); return mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass((const maxon::GenericComponent*) this + mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset);
	}

	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::ParseCommandLine(BaseArray<String>* args, Data* res, PYTHONFLAG* flags) -> Result<PYSTARTOPERATION>
	{
		return (Hxx2::StaticMTable::_instance.CPythonLibraryInterface_ParseCommandLine(args, res, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Init(const Url& librarypath, Bool createSubLibrary) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Init(const Url& librarypath, Bool createSubLibrary) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Init) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_Init(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Init_Offset, librarypath, createSubLibrary));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::InitTypes() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_InitTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitTypes_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::InitTypes() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_InitTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitTypes_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::InitBuiltinModules() const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_InitBuiltinModules(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::InitBuiltinModules() -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_InitBuiltinModules) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_InitBuiltinModules(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_InitBuiltinModules_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_Initialize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Initialize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Initialize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_Initialize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Initialize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Initialize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Initialize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_Finalize() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Finalize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Finalize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_Finalize() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Finalize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Finalize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Finalize_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Create(const ModuleDefinition& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Create) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Create(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Create_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Create(const ModuleDefinition& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Create) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Create(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Create_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Free(const Delegate<void()>& shutdownEngine) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_Free(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Free_Offset, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Free(const Delegate<void()>& shutdownEngine) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_Free) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_Free(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_Free_Offset, shutdownEngine);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetDll() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PythonDll&>, const PythonDll&>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const PythonDll&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetDll) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetDll(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetDll_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::FopenNative(const Char* name, const Char* mode) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<FILE_native*>, FILE_native*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_FopenNative(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_FopenNative_Offset, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::FopenNative(const Char* name, const Char* mode) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), FILE_native*, maxon::Result<FILE_native*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_FopenNative) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_FopenNative(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_FopenNative_Offset, name, mode));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Error>, Error>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<Error>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_LastPythonCallFailed(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::LastPythonCallFailed(const maxon::SourceLocation& allocLocation, Bool withTraceback, Bool restoreError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Error, maxon::Result<Error>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_LastPythonCallFailed) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_LastPythonCallFailed(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_LastPythonCallFailed_Offset, allocLocation, withTraceback, restoreError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) const -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<MPyDataRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_RegisterComponentProxy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterComponentProxy(const CPyRef& type, const Id& registryId, const ProxyDefinition& baseAndInterfaceIds, const Id& cid, Bool printErrors, ClassInterface::KIND kind, const SourceLocation& loc, Bool createObject, const DataType& dtOfObject) -> Result<MPyDataRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<MPyDataRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterComponentProxy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_RegisterComponentProxy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterComponentProxy_Offset, type, registryId, baseAndInterfaceIds, cid, printErrors, kind, loc, createObject, dtOfObject));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_IsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_IsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_IsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_IsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetVersion() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetVersion(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetVersion() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetVersion) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetVersion(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetVersion_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetPlatform() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetPlatform(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetPlatform() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPlatform) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetPlatform(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPlatform_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetCopyright() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetCopyright(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetCopyright() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCopyright) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetCopyright(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCopyright_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetCompiler() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetCompiler(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetCompiler() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetCompiler) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetCompiler(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetCompiler_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetBuildInfo() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetBuildInfo(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetBuildInfo() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetBuildInfo) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetBuildInfo(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetBuildInfo_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetProgramName(const String& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetProgramName(const String& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetProgramName_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetPythonHome(const Url& name) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetPythonHome(const Url& name) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPythonHome_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetProgramName() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetProgramName() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetProgramName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetProgramName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetProgramName_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_GetPythonHome() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<String>, String>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<String>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_GetPythonHome() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), String, maxon::Result<String>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_GetPythonHome) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_GetPythonHome(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_GetPythonHome_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ExecuteModule(const String& name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ExecuteModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ExecuteModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ExecuteModule(const String& name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ExecuteModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ExecuteModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ExecuteModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCallerContext_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyCallerContextRef>, MPyCallerContextRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyCallerContextRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCallerContext_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCallerContext_New() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyCallerContextRef, maxon::Result<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallerContext_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCallerContext_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallerContext_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleFileExFlags(FILE_native* fp, const Char* filename, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_Offset, fp, filename, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleFileExFlags(const Url& url, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleFileExFlags_1_Offset, url, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_SimpleStringFlags(const String& code, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_SimpleStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_SimpleStringFlags_Offset, code, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyObject*>, NativePyObject*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_FileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_FileExFlags(FILE_native* fp, const Char* filename, Int32 start, NativePyObject* globals, NativePyObject* locals, Int32 closeit, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyObject*, maxon::Result<NativePyObject*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_FileExFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_FileExFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_FileExFlags_Offset, fp, filename, start, globals, locals, closeit, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyRun_InteractiveLoopFlags(FILE* fp, const Char* filename, CPyCompilerFlags* flags) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyRun_InteractiveLoopFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyRun_InteractiveLoopFlags_Offset, fp, filename, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGilState_Ensure() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<PYGILSTATE>, PYGILSTATE>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<PYGILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGilState_Ensure(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGilState_Ensure() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), PYGILSTATE, maxon::Result<PYGILSTATE>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Ensure) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGilState_Ensure(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Ensure_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGilState_Release(PYGILSTATE state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyGilState_Release(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGilState_Release(PYGILSTATE state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGilState_Release) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyGilState_Release(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGilState_Release_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetGilState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<GILSTATE>, GILSTATE>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<GILSTATE>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetGilState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetGilState(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetGilState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGILState_GetThisThreadState() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGILState_GetThisThreadState() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGILState_GetThisThreadState) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGILState_GetThisThreadState_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyThreadState_Swap(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyThreadState_Swap(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyThreadState_Swap(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_Swap) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyThreadState_Swap(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_Swap_Offset, state));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyThreadState_GetDict() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyThreadState_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyThreadState_GetDict() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyThreadState_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyThreadState_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyThreadState_GetDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyCodeRef>, CPyCodeRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyCodeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_CompileStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_CompileStringFlags(const Char* code, const Char* filename, PYINPUT start, CPyCompilerFlags* flags) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyCodeRef, maxon::Result<CPyCodeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_CompileStringFlags) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_CompileStringFlags(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_CompileStringFlags_Offset, code, filename, start, flags));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_Incref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Incref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Incref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Incref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_Decref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_Decref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_Decref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_Decref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeIncref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeIncref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_SafeIncref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SafeIncref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeDecref(NativePyObject* o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SafeDecref) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPy_SafeDecref(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SafeDecref_Offset, o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_SafeClear(T*& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPy_SafeClear on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(); } 
		o_->CPy_SafeClear<T>(o);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyGC_Collect() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGC_Collect(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyGC_Collect() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyGC_Collect) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyGC_Collect(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyGC_Collect_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCode_Addr2Line(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCode_Addr2Line(const CPyCodeRef& codeObject, Int32 x) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCode_Addr2Line) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCode_Addr2Line(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCode_Addr2Line_Offset, codeObject, x));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::UnpackDataType(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_UnpackDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackDataType_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::UnpackDataType(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_UnpackDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackDataType_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::UnpackData(const CPyRef& obj) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_UnpackData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackData_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::UnpackData(const CPyRef& obj) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_UnpackData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_UnpackData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_UnpackData_Offset, obj));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_None() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_None) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_None(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_None_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_True() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_True) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_True(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_True_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_False() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_False) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_False(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_False_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPy_NotImplemented() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NotImplemented) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_NotImplemented(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NotImplemented_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Print() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Print(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Print_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Print() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Print) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Print(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Print_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Clear() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Clear() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Clear_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Occurred(CPyRef* type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_Occurred(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Occurred(CPyRef* type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Occurred) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_Occurred(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Occurred_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetString(const CPyRef& errorType, const Char* errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetWithErrnoAndFilename(const CPyRef& errorType, Int32 errorNumber, const Char* filename) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrnoAndFilename_Offset, errorType, errorNumber, filename));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetWithErrno(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetWithErrno(const CPyRef& errorType, Int32 errorNumber) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetWithErrno) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetWithErrno(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetWithErrno_Offset, errorType, errorNumber));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetString_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetString(const CPyRef& errorType, const String& errorString) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetString_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_SetString_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetString_1_Offset, errorType, errorString));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_SetNone(const CPyRef& errorType) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_SetNone(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_SetNone(const CPyRef& errorType) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_SetNone) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_SetNone(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_SetNone_Offset, errorType);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Fetch(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Fetch(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Fetch) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Fetch(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Fetch_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_NormalizeException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_NormalizeException(CPyRef& type, CPyRef& value, CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_NormalizeException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_NormalizeException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_NormalizeException_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Restore(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_Restore(const CPyRef& type, const CPyRef& value, const CPyRef& traceback) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_Restore) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyErr_Restore(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_Restore_Offset, type, value, traceback);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyErr_ExceptionMatches(const CPyRef& exc) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyErr_ExceptionMatches(const CPyRef& exc) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyErr_ExceptionMatches) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyErr_ExceptionMatches_Offset, exc));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExceptionClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExceptionClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExceptionClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExceptionClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExceptionClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExceptionClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyCapsule_New(void* pointer, const Char* name, CPyCapsule_Destructor* destructor) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_New_Offset, pointer, name, destructor));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_SetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_SetPointer(const CPyRef& capsule, void* pointer) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_SetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetPointer_Offset, capsule, pointer));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_GetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_GetPointer(const CPyRef& capsule, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetPointer) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_GetPointer(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetPointer_Offset, capsule, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_GetContext(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void*>, void*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_GetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_GetContext(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void*, maxon::Result<void*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_GetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_GetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_GetContext_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_SetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_SetContext(const CPyRef& capsule, void* context) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_SetContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_SetContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_SetContext_Offset, capsule, context));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_CheckExact(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTraceBack_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTraceBack_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTraceBack_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTraceBack_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyClass_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyClass_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyClass_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyTuple_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_Size(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt>, UInt>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_Size(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt, maxon::Result<UInt>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Size_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_GetItem(const CPyRef& tuple, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetItem_Offset, tuple, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_SetItem(const CPyRef& tuple, UInt index, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_SetItem_Offset, tuple, index, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_GetSlice(const CPyRef& tuple, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_GetSlice_Offset, tuple, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_CheckExact(const CPyRef& tuple) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_CheckExact(const CPyRef& tuple) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_CheckExact_Offset, tuple));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_HasAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_HasAttrString(const CPyRef& o, const Char* attrName) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_HasAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_HasAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_HasAttrString_Offset, o, attrName));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_SetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_SetAttrString(const CPyRef& o, const Char* name, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_SetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetAttrString_Offset, o, name, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetAttrString(const CPyRef& o, const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetAttrString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetAttrString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetAttrString_Offset, o, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Call(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Call(const CPyRef& callable_object, const CPyRef& tupleArg, const CPyRef& kw) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Call) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Call(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Call_Offset, callable_object, tupleArg, kw));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Str(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Str(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Str_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Str(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Str) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Str(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Str_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Repr(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Repr(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Repr(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Repr) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Repr(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Repr_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Dir(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Dir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Dir(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Dir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Dir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Dir_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_RichCompare(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_RichCompare(const CPyRef& o1, const CPyRef& o2, Int32 opid) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_RichCompare) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_RichCompare(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_RichCompare_Offset, o1, o2, opid));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Hash(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Hash(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Hash(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Hash) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Hash(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Hash_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_IsTrue(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_IsTrue(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_IsTrue(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_IsTrue) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_IsTrue(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_IsTrue_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Not(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Not(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Not_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Not(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Not) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Not(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Not_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCallable_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCallable_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCallable_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCallable_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCallable_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCallable_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Length(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Length(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Length_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Length(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Length) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Length(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Length_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItemInt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItemInt(const CPyRef& o, Int index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemInt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItemInt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemInt_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_GetItemString(const CPyRef& o, const Char* index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetItemString_Offset, o, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_DelItem(const CPyRef& o, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_DelItem_Offset, o, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_SetItem(const CPyRef& o, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_SetItem_Offset, o, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_TypeCheck(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_TypeCheck(const CPyRef& object, const CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_TypeCheck) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_TypeCheck(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_TypeCheck_Offset, object, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_CallFunction(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_CallFunction(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_CallFunction(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_CallFunction) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_CallFunction(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_CallFunction_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_GetObject(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_GetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_GetObject(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_GetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetObject_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetObject(const Char* name, const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetObject(const Char* name, const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetObject_Offset, name, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_SetPath(const BaseArray<Url>& paths) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPath_Offset, paths));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_SetPath(const BaseArray<Url>& paths) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_SetPath_Offset, paths));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetPath(const BaseArray<Url>& paths, PATHHANDLE add) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetPath_Offset, paths, add));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetArgvEx(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_SetArgvEx(const BaseArray<String>& args, Bool updatepath) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_SetArgvEx) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_SetArgvEx(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_SetArgvEx_Offset, args, updatepath));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySys_GetPath() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<BaseArray<Url>>, BaseArray<Url>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<BaseArray<Url>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_GetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySys_GetPath() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), BaseArray<Url>, maxon::Result<BaseArray<Url>>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySys_GetPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySys_GetPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySys_GetPath_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySite_AddSiteDir(const Url& siteDir) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySite_AddSiteDir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySite_AddSiteDir(const Url& siteDir) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySite_AddSiteDir) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySite_AddSiteDir(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySite_AddSiteDir_Offset, siteDir));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyUnicode_FromString(const Char* str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_FromString(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_FromStringAndSize(const Block<const Char>& block) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_FromStringAndSize(const Block<const Char>& block) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_FromStringAndSize) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_FromStringAndSize_Offset, block));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_AsString(const CPyRef& str) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_AsString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_AsString(const CPyRef& str) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_AsString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_AsCString(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const Char*>, const Char*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_AsCString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_AsCString(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const Char*, maxon::Result<const Char*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_AsCString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_AsCString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_AsCString_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_GetLength(const CPyRef& str) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_GetLength) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_GetLength(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_GetLength(const CPyRef& str) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_GetLength) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_GetLength(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_GetLength_Offset, str));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyObject_GetIter(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_GetIter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_GetIter(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_GetIter_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyIter_Next(const CPyRef& it) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyIter_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyIter_Next(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyIter_Next_Offset, it));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_New() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_New(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_New_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_GetItem(const CPyRef& dict, const CPyRef& key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItem_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_GetItemString(const CPyRef& dict, const Char* key, Bool raiseKeyError) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_GetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_GetItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_GetItemString_Offset, dict, key, raiseKeyError));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_SetItem(const CPyRef& dict, const CPyRef& key, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItem_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_DelItem(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_DelItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItem_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CONTAINS>, CONTAINS>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CONTAINS>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Contains(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Contains(const CPyRef& dict, const CPyRef& key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CONTAINS, maxon::Result<CONTAINS>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Contains) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Contains(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Contains_Offset, dict, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Clear(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyDict_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Clear(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyDict_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Clear_Offset, dict);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Next(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Next(const CPyRef& dict, Int& pos, CPyRef& key, CPyRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Next) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Next(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Next_Offset, dict, pos, key, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Keys(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Keys(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Keys(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Keys) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Keys(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Keys_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Values(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Values(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Values_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Values(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Values) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Values(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Values_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Items(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Items(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Items_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Items(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Items) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Items(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Items_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Size(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Size_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Size(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Size_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Copy(const CPyRef& dict) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Copy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Copy(const CPyRef& dict) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Copy) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Copy(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Copy_Offset, dict));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_SetItemString(const CPyRef& dict, const Char* key, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_SetItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_SetItemString(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_SetItemString_Offset, dict, key, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyDict_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Check(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_New(UInt size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_New(UInt size) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_New_Offset, size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_CheckExact(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_CheckExact(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_CheckExact(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_CheckExact_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Clear(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Clear_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Clear(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Clear) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Clear(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Clear_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Size(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int>, Int>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Size_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Size(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int, maxon::Result<Int>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Size) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Size(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Size_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_GetItem(const CPyRef& list, UInt index) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_GetItem(const CPyRef& list, UInt index) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_GetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetItem_Offset, list, index));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_SetItem(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetItem) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_SetItem(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetItem_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Insert(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Insert(const CPyRef& list, UInt anonymous_param_2, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Insert) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Insert(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Insert_Offset, list, anonymous_param_2, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Append(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Append_Offset, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Append(const CPyRef& list, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Append) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Append(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Append_Offset, list, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_GetSlice(const CPyRef& list, UInt from, UInt to) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_GetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_GetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_GetSlice_Offset, list, from, to));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_SetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_SetSlice(const CPyRef& list, UInt from, UInt to, const CPyRef& item) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_SetSlice) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_SetSlice(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_SetSlice_Offset, list, from, to, item));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Sort(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Sort(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Sort_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Sort(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Sort) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Sort(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Sort_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Reverse(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Reverse(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Reverse(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Reverse) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Reverse(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Reverse_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_AsTuple(const CPyRef& list) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_AsTuple(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_AsTuple(const CPyRef& list) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_AsTuple) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_AsTuple(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_AsTuple_Offset, list));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_DelItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_DelItemString(const CPyRef& p, const Char* key) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_DelItemString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_DelItemString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_DelItemString_Offset, p, key));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) const -> Result<Bool>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Bool>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddObject(const CPyRef& module, const Char* name, const CPyRef& value) -> Result<Bool>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Bool>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddObject) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddObject(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddObject_Offset, module, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset, module, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddType(const CPyRef& module, const CPyTypeRef& value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddType_Offset, module, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_GetDict(const CPyRef& module) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_GetDict(const CPyRef& module) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_GetDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_GetDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_GetDict_Offset, module));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddIntConstant(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_AddIntConstant(const CPyRef& mod, const Char* name, long value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_AddIntConstant) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_AddIntConstant(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_AddIntConstant_Offset, mod, name, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_ImportModule(const Char* name) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_ImportModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_ImportModule(const Char* name) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_ImportModule) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_ImportModule(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_ImportModule_Offset, name));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_GetImporter(const CPyRef& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_GetImporter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_GetImporter(const CPyRef& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetImporter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_GetImporter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetImporter_Offset, path));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyImport_GetModuleDict() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetModuleDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_GetModuleDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyImport_GetModuleDict() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyImport_GetModuleDict) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyImport_GetModuleDict(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyImport_GetModuleDict_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_IsSubtype(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_IsSubtype(const CPyTypeRef& a, const CPyTypeRef& b) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_IsSubtype) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_IsSubtype(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_IsSubtype_Offset, a, b));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyType_HasFeature(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_HasFeature) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_HasFeature(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_HasFeature_Offset, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyType_FastSubclass(const CPyTypeRef& type, Int64 f) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_FastSubclass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_FastSubclass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_FastSubclass_Offset, type, f));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_GetName(const CPyTypeRef& type) const -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_GetName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_GetName_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_GetName(const CPyTypeRef& type) -> Result<String>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<String>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_GetName) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_GetName(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_GetName_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Ready(CPyTypeRef& type) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Ready(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Ready_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Ready(CPyTypeRef& type) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Ready) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Ready(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Ready_Offset, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_SaveThread() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<NativePyThreadState*>, NativePyThreadState*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_SaveThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_SaveThread() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), NativePyThreadState*, maxon::Result<NativePyThreadState*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_SaveThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_SaveThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_SaveThread_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_RestoreThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_RestoreThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_RestoreThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_RestoreThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_RestoreThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_RestoreThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_ThreadsInitialized() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_ThreadsInitialized() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ThreadsInitialized) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ThreadsInitialized_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_InitThreads() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_InitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_InitThreads() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_InitThreads) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_InitThreads(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_InitThreads_Offset);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_AcquireThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_AcquireThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_AcquireThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_AcquireThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_AcquireThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_AcquireThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyEval_ReleaseThread(NativePyThreadState* state) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_ReleaseThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyEval_ReleaseThread(NativePyThreadState* state) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_ReleaseThread) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_CPyEval_ReleaseThread(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_ReleaseThread_Offset, state);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyEval_GetBuiltins() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_GetBuiltins) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_GetBuiltins(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_GetBuiltins_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CPyEval_EvalCode(const CPyCodeRef& code, const CPyRef& globals, const CPyRef& locals) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyEval_EvalCode) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyEval_EvalCode(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyEval_EvalCode_Offset, code, globals, locals));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_FromFloat32(Float32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_FromFloat32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_FromFloat32(Float32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_FromFloat32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_FromFloat64(Float64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_FromFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_FromFloat64(Float64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_FromFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_FromFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_FromFloat64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_AsFloat64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Float64>, Float64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_AsFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_AsFloat64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Float64, maxon::Result<Float64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_AsFloat64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_AsFloat64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_AsFloat64_Offset, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_As on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float32), Float32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_From(std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyFloat_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyFloat_From<T>(std::forward<std::enable_if_t<STD_IS_REPLACEMENT(same,T,Float64), Float64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyBool_FromBool(Bool value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyBool_FromBool(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyBool_FromBool(Bool value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_FromBool) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyBool_FromBool(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_FromBool_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt16(Int16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt16(Int16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt16(UInt16 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt16(UInt16 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt16_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt32(Int32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt32(Int32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt32(UInt32 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt32(UInt32 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt32_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromInt64(Int64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromInt64(Int64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_FromUInt64(UInt64 value) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_FromUInt64(UInt64 value) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_FromUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_FromUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_FromUInt64_Offset, value));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int16>, Int16>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int16, maxon::Result<Int16>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt16(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt16>, UInt16>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt16(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt16, maxon::Result<UInt16>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt16) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt16(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt16_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32>, Int32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32, maxon::Result<Int32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt32(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt32>, UInt32>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt32(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt32, maxon::Result<UInt32>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt32) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt32(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt32_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int64>, Int64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int64, maxon::Result<Int64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_AsUInt64(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<UInt64>, UInt64>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return 0; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_AsUInt64(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), UInt64, maxon::Result<UInt64>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_AsUInt64) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_AsUInt64(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_AsUInt64_Offset, o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_As(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<T>, T>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<T>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_As(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), T, maxon::Result<T>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_As on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_As<T>(o));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int32>::value, Int32> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int32>::value, Int32>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_From(std::enable_if_t<std::is_same<T, Int64>::value, Int64> o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::CPyLong_From on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->CPyLong_From<T>(std::forward<std::enable_if_t<std::is_same<T, Int64>::value, Int64>>(o)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyNumber_Check(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyNumber_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyNumber_Check(const CPyRef& o) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Bool, maxon::Result<Bool>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNumber_Check) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyNumber_Check(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNumber_Check_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyFunction_New(const reflection::Function* func) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyFunctionRef>, MPyFunctionRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyFunctionRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyFunction_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyFunction_New_Offset, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyFunction_New(const reflection::Function* func) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyFunctionRef, maxon::Result<MPyFunctionRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyFunction_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyFunction_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyFunction_New_Offset, func));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(const HashMap<Data, Data>& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyHashMap_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset, map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(const HashMap<Data, Data>& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyHashMap_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_Offset, map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(HashMap<Data, Data>&& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyHashMap_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset, std::forward<HashMap<Data, Data>>(map)));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(HashMap<Data, Data>&& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyHashMap_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyHashMap_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyHashMap_New_1_Offset, std::forward<HashMap<Data, Data>>(map)));
	}
	template <typename S> template <typename KEY, typename VALUE> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyHashMap_New(HashMap<KEY, VALUE>& map) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyHashMapRef>, MPyHashMapRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<MPyHashMapRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->MPyHashMap_New<KEY, VALUE>(map));
	}
	template <typename S> template <typename KEY, typename VALUE> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyHashMap_New(HashMap<KEY, VALUE>& map) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyHashMapRef, maxon::Result<MPyHashMapRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::MPyHashMap_New on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->MPyHashMap_New<KEY, VALUE>(map));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyMember_New(const reflection::Member* member) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyMemberRef>, MPyMemberRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyMemberRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyMember_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyMember_New_Offset, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyMember_New(const reflection::Member* member) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyMemberRef, maxon::Result<MPyMemberRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyMember_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyMember_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyMember_New_Offset, member));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMem_SetAllocator) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyMem_SetAllocator(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset, std::forward<CPyMemAllocatorDomain>(domain), allocator));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyMem_SetAllocator(CPyMemAllocatorDomain domain, CPyMemAllocatorEx* allocator) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMem_SetAllocator) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyMem_SetAllocator(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMem_SetAllocator_Offset, std::forward<CPyMemAllocatorDomain>(domain), allocator));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyClass_New(const reflection::Class* cls) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyClassRef>, MPyClassRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyClassRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyClass_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyClass_New_Offset, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyClass_New(const reflection::Class* cls) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyClassRef, maxon::Result<MPyClassRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyClass_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyClass_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyClass_New_Offset, cls));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_DebugFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_DebugFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_DebugFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DebugFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_DebugFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DebugFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_VerboseFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_VerboseFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_VerboseFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_VerboseFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_VerboseFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_VerboseFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_InteractiveFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_InteractiveFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_InteractiveFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InteractiveFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_InteractiveFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InteractiveFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_InspectFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_InspectFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_InspectFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_InspectFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_InspectFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_InspectFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_OptimizeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_OptimizeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_OptimizeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_OptimizeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_OptimizeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_OptimizeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_NoSiteFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_NoSiteFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_NoSiteFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoSiteFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_NoSiteFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoSiteFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_BytesWarningFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_BytesWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_BytesWarningFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_BytesWarningFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_BytesWarningFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_BytesWarningFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_FrozenFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_FrozenFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_FrozenFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_FrozenFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_FrozenFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_FrozenFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_IgnoreEnvironmentFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_IgnoreEnvironmentFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_IgnoreEnvironmentFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_DontWriteBytecodeFlag() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_DontWriteBytecodeFlag() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_DontWriteBytecodeFlag) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_DontWriteBytecodeFlag_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPy_NoUserSiteDirectory() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Int32*>, Int32*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPy_NoUserSiteDirectory() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Int32*, maxon::Result<Int32*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPy_NoUserSiteDirectory) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPy_NoUserSiteDirectory_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BaseException() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BaseException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BaseException() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BaseException) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BaseException(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BaseException_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_Exception() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_Exception(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_Exception() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Exception) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_Exception(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Exception_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_StopIteration() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_StopIteration(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_StopIteration() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StopIteration) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_StopIteration(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StopIteration_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_GeneratorExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_GeneratorExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_GeneratorExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_GeneratorExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_GeneratorExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_GeneratorExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_StandardError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_StandardError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_StandardError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_StandardError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_StandardError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_StandardError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ArithmeticError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ArithmeticError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ArithmeticError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ArithmeticError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ArithmeticError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ArithmeticError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_LookupError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_LookupError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_LookupError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_LookupError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_LookupError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_LookupError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_AssertionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_AssertionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_AssertionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AssertionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_AssertionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AssertionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_AttributeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_AttributeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_AttributeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_AttributeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_AttributeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_AttributeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_EOFError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_EOFError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_EOFError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EOFError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_EOFError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EOFError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_FloatingPointError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_FloatingPointError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_FloatingPointError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FloatingPointError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_FloatingPointError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FloatingPointError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_EnvironmentError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_EnvironmentError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_EnvironmentError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_EnvironmentError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_EnvironmentError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_EnvironmentError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IOError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IOError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IOError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IOError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IOError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IOError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_OSError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_OSError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_OSError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OSError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_OSError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OSError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ImportError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ImportError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ImportError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ImportError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IndexError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IndexError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IndexError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndexError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IndexError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndexError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_KeyError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_KeyError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_KeyError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_KeyError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_KeyboardInterrupt() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_KeyboardInterrupt() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_KeyboardInterrupt) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_KeyboardInterrupt_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_MemoryError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_MemoryError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_MemoryError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_MemoryError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_NameError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_NameError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_NameError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NameError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_NameError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NameError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_OverflowError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_OverflowError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_OverflowError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_OverflowError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_OverflowError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_OverflowError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_RuntimeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_RuntimeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_RuntimeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_RuntimeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_NotImplementedError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_NotImplementedError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_NotImplementedError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_NotImplementedError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_NotImplementedError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_NotImplementedError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SyntaxError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SyntaxError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SyntaxError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SyntaxError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_IndentationError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IndentationError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_IndentationError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_IndentationError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_IndentationError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_IndentationError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_TabError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_TabError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_TabError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TabError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_TabError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TabError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ReferenceError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ReferenceError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ReferenceError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ReferenceError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ReferenceError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ReferenceError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SystemError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SystemError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SystemError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SystemError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SystemExit() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SystemExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SystemExit() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SystemExit) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SystemExit(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SystemExit_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_TypeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_TypeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_TypeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_TypeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_TypeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_TypeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnboundLocalError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnboundLocalError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnboundLocalError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnboundLocalError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeEncodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeEncodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeEncodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeEncodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeDecodeError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeDecodeError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeDecodeError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeDecodeError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeTranslateError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeTranslateError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeTranslateError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeTranslateError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ValueError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ValueError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ValueError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ValueError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ValueError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ValueError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ZeroDivisionError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ZeroDivisionError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ZeroDivisionError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ZeroDivisionError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_WindowsError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_WindowsError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_WindowsError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_WindowsError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_WindowsError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_WindowsError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BufferError() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BufferError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BufferError() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BufferError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BufferError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BufferError_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_MemoryErrorInst() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_MemoryErrorInst() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_MemoryErrorInst) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_MemoryErrorInst_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_Warning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_Warning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_Warning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_Warning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_Warning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_Warning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UserWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UserWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UserWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UserWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UserWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UserWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_DeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_DeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_DeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_DeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_PendingDeprecationWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_PendingDeprecationWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_PendingDeprecationWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_PendingDeprecationWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_SyntaxWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_SyntaxWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_SyntaxWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_SyntaxWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_RuntimeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_RuntimeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_RuntimeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_RuntimeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_FutureWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_FutureWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_FutureWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_FutureWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_FutureWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_FutureWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_ImportWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ImportWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_ImportWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_ImportWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_ImportWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_ImportWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_UnicodeWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_UnicodeWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_UnicodeWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_UnicodeWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyExc_BytesWarning() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyConstRef>, CPyConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BytesWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyExc_BytesWarning() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyConstRef, maxon::Result<CPyConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyExc_BytesWarning) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyExc_BytesWarning(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyExc_BytesWarning_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyNullImporter_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyNullImporter_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyNullImporter_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyNullImporter_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyNullImporter_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyNullImporter_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySuper_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySuper_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySuper_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySuper_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySuper_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySuper_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySuper_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyBool_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyBool_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyBool_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyBool_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyBool_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyBool_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyModule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyModule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyModule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyModule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyModule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyUnicode_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyUnicode_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyUnicode_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyUnicode_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyUnicode_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyLong_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyLong_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyLong_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyLong_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyLong_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyFloat_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyFloat_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyFloat_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyFloat_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyFloat_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTuple_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTuple_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTuple_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTuple_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTuple_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyList_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyList_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyList_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyList_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyList_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyDict_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyDict_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyDict_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyDict_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyDict_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyClass_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyClass_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyClass_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyClass_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyClass_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyClass_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyTraceBack_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTraceBack_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyTraceBack_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyTraceBack_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyTraceBack_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyTraceBack_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPySlice_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySlice_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySlice_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPySlice_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPySlice_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPySlice_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPySlice_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyType_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyType_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyType_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyType_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyType_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyMemoryView_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyMemoryView_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyMemoryView_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyMemoryView_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyMemoryView_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyMemoryView_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const PyChar*>, const PyChar*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ConvertAndCacheString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset, str, std::forward<PyStringEncodings>(encoding), size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ConvertAndCacheString(const String& str, PyStringEncodings encoding, UInt* size) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), const PyChar*, maxon::Result<const PyChar*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ConvertAndCacheString) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ConvertAndCacheString(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ConvertAndCacheString_Offset, str, std::forward<PyStringEncodings>(encoding), size));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_RegisterSpecificPythonClass(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterSpecificPythonClass(const Id& typeId, const CPyTypeRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecificPythonClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_RegisterSpecificPythonClass(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecificPythonClass_Offset, typeId, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::PrivateRegisterBuiltinConverter(const DataType& dt, const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateRegisterBuiltinConverter) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateRegisterBuiltinConverter_Offset, dt, f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterBuiltinConverter(const DelegatePyObject_AsData& f1, const DelegatePyObject_FromData<T>& f2) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::RegisterBuiltinConverter on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->RegisterBuiltinConverter<T>(f1, f2));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetUrl(DEFAULTRUNTIME pythonPath, Url& pythonLibrary, Url& pythonHome) -> Result<void>
	{
		return (Hxx2::StaticMTable::_instance.CPythonLibraryInterface_GetUrl(pythonPath, pythonLibrary, pythonHome));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Url>, Url>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<Url>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetSpecialPath(SPECIALPATH anonymous_param_1) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), Url, maxon::Result<Url>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetSpecialPath_Offset, anonymous_param_1));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_RegisterSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::RegisterSpecialPath(SPECIALPATH anonymous_param_1, const Url& path) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_RegisterSpecialPath) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_RegisterSpecialPath(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_RegisterSpecialPath_Offset, anonymous_param_1, path);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyData_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyData_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyData_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyData_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyData_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyData_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyData_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyCapsule_Type() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyTypeConstRef>, CPyTypeConstRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyTypeConstRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyCapsule_Type() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyTypeConstRef, maxon::Result<CPyTypeConstRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyCapsule_Type) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyCapsule_Type(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyCapsule_Type_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::PrivateGetCurrentCallerContext() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::PrivateGetCurrentCallerContext() -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_PrivateGetCurrentCallerContext) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_PrivateGetCurrentCallerContext_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataType_ToMapperInstance(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_ToMapperInstance(const MPyDataRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_ToMapperInstance_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_ToMapperInstance(const DataType& dt, const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_ToMapperInstance) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_ToMapperInstance_Offset, dt, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) const -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::AssociateDataTypeWithPythonTypes(const DataType& dt, const CPyRef& type) -> Result<void>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_AssociateDataTypeWithPythonTypes) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_AssociateDataTypeWithPythonTypes_Offset, dt, type));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetAssociatedDataType(const DataType& dt) const -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<CPyRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetAssociatedDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetAssociatedDataType(const DataType& dt) -> Result<CPyRef>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<CPyRef>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetAssociatedDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetAssociatedDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetAssociatedDataType_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetConverterPyObject_FromData(const DataType& dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<DelegatePyObject_FromData<>*>, DelegatePyObject_FromData<>*>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return nullptr; } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetConverterPyObject_FromData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetConverterPyObject_FromData(const DataType& dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), DelegatePyObject_FromData<>*, maxon::Result<DelegatePyObject_FromData<>*>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetConverterPyObject_FromData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetConverterPyObject_FromData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetConverterPyObject_FromData_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_New(Data& data) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_Offset, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_New(Data& data) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_Offset, data));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataRef>, MPyDataRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyData_New(const DataType& dt, Generic* data, Bool owner, const DataType& mapDt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataRef, maxon::Result<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_New_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_New_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_New_1_Offset, dt, data, owner, mapDt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MPyDataType_New(const DataType& dt) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<MPyDataTypeRef>, MPyDataTypeRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<MPyDataTypeRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_New_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MPyDataType_New(const DataType& dt) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), MPyDataTypeRef, maxon::Result<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_New) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_New(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_New_Offset, dt));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyDataType_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_CheckExact(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyDataType_GetDataType(const MPyDataTypeRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType&>, const DataType&>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<const DataType&>, const DataType&>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<const DataType&>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyDataType_GetDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyDataType_GetDataType(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyDataType_GetDataType_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::MPyData_CheckExact(const CPyRef& o) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Bool>, Bool>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateLogNullptrError(false); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MPyData_CheckExact) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MPyData_CheckExact(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MPyData_CheckExact_Offset, o));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) const -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Data*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_AsData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_AsData(Int stackDepth, const CPyRef& obj, const DataType& expected, BlockArray<Data>& k, BaseArray<reflection::Argument>* n) -> Result<Data*>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<Data*>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_AsData) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_AsData(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_AsData_Offset, stackDepth, obj, expected, k, n));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetRegisteredTypesWithConversions() const -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetRegisteredTypesWithConversions() -> Result<BaseArray<TYPE_CONVERSION_TUPLE>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<TYPE_CONVERSION_TUPLE>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetRegisteredTypesWithConversions) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetRegisteredTypesWithConversions_Offset));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(same,T,DataType), ResultPtr<DataType>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseRef(const CPyRef& args, Int32 argIndex, Bool isOptional) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseRef on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseRef<T>(args, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<STD_IS_REPLACEMENT(reference,T)||STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>, typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseArgument(const CPyRef& args, BlockArray<Data>& tempStack, Int32 argIndex, Bool isOptional) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type, maxon::Result<typename std::enable_if<!STD_IS_REPLACEMENT(reference,T)&&!STD_IS_REPLACEMENT(pointer,T), Result<T>>::type>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseArgument on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseArgument<T>(args, tempStack, argIndex, isOptional));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) const -> Result<DataType>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<DataType>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ParseDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseDataType(const CPyRef& args, Int32 argIndex, Bool canBeNone) -> Result<DataType>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<DataType>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_ParseDataType) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_ParseDataType(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_ParseDataType_Offset, args, argIndex, canBeNone));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, DataType& dt, Bool unpackData) const -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::ParseGeneric(const CPythonLibraryRef& pylib, const CPyRef& args, Int32 argIndex, DataType& dt, Bool unpackData) -> Result<T>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<T>>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::ParseGeneric on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->ParseGeneric<T>(pylib, args, argIndex, dt, unpackData));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::SetError(const Error& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_SetError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::SetError(const Error& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_SetError(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::SetError(const ErrorPtr& err) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<void>, void>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { DebugStop(); return maxon::PrivateLogNullptrError(); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_SetError_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_1_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::SetError(const ErrorPtr& err) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), void, maxon::Result<void>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_SetError_1) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		mt_.CPythonLibraryInterface_SetError_1(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_SetError_1_Offset, err);
		return (typename ReturnHelper::ReturnType) maxon::OK;
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::MaxonConvertAuto(const CPyRef& capsule) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MaxonConvertAuto(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::MaxonConvertAuto(const CPyRef& capsule) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_MaxonConvertAuto) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_MaxonConvertAuto(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_MaxonConvertAuto_Offset, capsule));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_FromGeneric(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::CPyObject_FromGeneric(const DataType& origDt, const Generic* object, OWNERSHIP ownership, const CPyTypeRef* expected, Int* count) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CPyObject_FromGeneric) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CPyObject_FromGeneric(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CPyObject_FromGeneric_Offset, origDt, object, ownership, expected, count));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::CreateGlobalDictionary() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_CreateGlobalDictionary) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_CreateGlobalDictionary(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_CreateGlobalDictionary_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::GetCurrentTraceback() const -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCurrentTraceback(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::GetCurrentTraceback() -> Result<BaseArray<SourceLocation>>
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<BaseArray<SourceLocation>>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCurrentTraceback) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCurrentTraceback(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCurrentTraceback_Offset));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::Fn<S>::Enum_ToMapperInstance(T enumm) const -> typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<CPyRef>, CPyRef>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateNullReturnValue<CPyRef>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> template <typename T> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::COWFn<S>::Enum_ToMapperInstance(T enumm) -> typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS), CPyRef, maxon::Result<CPyRef>>::type>; static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION CPythonLibraryInterface::Enum_ToMapperInstance on super."); if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); CPythonLibraryInterface* o_ = (CPythonLibraryInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } 
		return (o_->Enum_ToMapperInstance<T>(enumm));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyRef>>, Class<CPyRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCPyRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTypeRef>>, Class<CPyTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCPyTypeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyTypeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyFrameRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyFrameRef>>, Class<CPyFrameRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyFrameRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyFrameRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCPyFrameRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyFrameRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyTracebackRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyTracebackRef>>, Class<CPyTracebackRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyTracebackRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyTracebackRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCPyTracebackRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyTracebackRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetCPyCodeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<CPyCodeRef>>, Class<CPyCodeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<CPyCodeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetCPyCodeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetCPyCodeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetCPyCodeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyClassRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyClassRef>>, Class<MPyClassRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyClassRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyClassRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyClassRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyClassRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyMemberRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyMemberRef>>, Class<MPyMemberRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyMemberRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyMemberRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyMemberRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyMemberRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyFunctionRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyFunctionRef>>, Class<MPyFunctionRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyFunctionRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyFunctionRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyFunctionRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyFunctionRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyHashMapRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyHashMapRef>>, Class<MPyHashMapRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyHashMapRef>>, Class<MPyHashMapRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyHashMapRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyHashMapRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyHashMapRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyHashMapRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyDataTypeRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataTypeRef>>, Class<MPyDataTypeRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataTypeRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataTypeRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyDataTypeRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyDataRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyDataRef>>, Class<MPyDataRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyDataRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyDataRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyDataRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyDataRefClass_Offset));
	}
	template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto CPythonLibraryInterface::Hxx1::ConstFn<S>::GetMPyCallerContextRefClass() const -> typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type
	{
		using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, typename std::conditional<S::HAS_ERROR, maxon::Result<Class<MPyCallerContextRef>>, Class<MPyCallerContextRef>>::type>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); const CPythonLibraryInterface* o_ = (const CPythonLibraryInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { o_ = CPythonLibraryInterface::NullValuePtr(); if (!o_) return maxon::PrivateIncompleteNullReturnValue<Class<MPyCallerContextRef>>(maxon::NULL_RETURN_REASON::NULLPTR, OVERLOAD_MAX_RANK); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(CPythonLibraryInterface, o_, CPythonLibraryInterface_GetMPyCallerContextRefClass) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<CPythonLibraryInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<CPythonLibraryInterface>() : PRIVATE_MAXON_VTABLE(CPythonLibraryInterface, o_); 
		return (mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass(reinterpret_cast<const maxon::GenericComponent*>(o_) + mt_.CPythonLibraryInterface_GetMPyCallerContextRefClass_Offset));
	}
	auto CPythonLibraryInterface::GetPtr() -> Ptr { return Ptr(this); }
	auto CPythonLibraryInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_py_CPythonLibraryInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_py_CPythonLibraryInterface() { new (s_ui_maxon_py_CPythonLibraryInterface) maxon::EntityUse(CPythonLibraryInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_ui_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
	MAXON_STATIC_STORAGE(maxon::EntityUse, s_usi_maxon_py_CPythonLibraryInterface); \
	MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_usi_maxon_py_CPythonLibraryInterface() { new (s_usi_maxon_py_CPythonLibraryInterface) maxon::EntityUse(CPythonLibraryInterface::_staticInterface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
	static maxon::EntityUse s_usi_maxon_py_CPythonLibraryInterface(CPythonLibraryInterface::_staticInterface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
}

struct PyModuleInterface::MTable
{
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetConstants);
	PRIVATE_MAXON_IMPLEMENTS_CHECK(GetFunctions3);
	static const maxon::Char* const _ids;
	static const maxon::METHOD_FLAGS _flags[];
	static const maxon::Bool HAS_NONSTATIC = false;
	Result<void> (*PyModuleInterface_GetFunctions3) (maxon::GenericComponent* this_, BaseArray<NativePyCFunctionTable>& functions);
	maxon::Int PyModuleInterface_GetFunctions3_Offset;
	Result<void> (*PyModuleInterface_GetConstants) (maxon::GenericComponent* this_, BaseArray<Tuple<const Char*, Int32>>& constants);
	maxon::Int PyModuleInterface_GetConstants_Offset;
	template <typename W> void Init(maxon::Int offset)
	{
	if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PyModuleInterface, GetFunctions3))
	{
		PyModuleInterface_GetFunctions3 = &W::PyModuleInterface_GetFunctions3;
		PyModuleInterface_GetFunctions3_Offset = offset;
	}
	if constexpr (PRIVATE_MAXON_IMPLEMENTS(typename W::Implementation, PyModuleInterface, GetConstants))
	{
		PyModuleInterface_GetConstants = &W::PyModuleInterface_GetConstants;
		PyModuleInterface_GetConstants_Offset = offset;
	}
	}
	template <typename S> using CombinedMTable = maxon::CombinedMTable<PyModuleInterface, typename LibraryInterface::MTable::template CombinedMTable<S>>;
	template <typename SUPER> using CompBase = maxon::PrivateComponentBase<PyModuleInterface, SUPER>;
	template <typename I> static const typename I::MTable& GetMTable() { return maxon::GetZeroRef<typename I::MTable>(); }
};

struct PyModuleInterface::Hxx2
{
	template <typename S> class CWrapper : public LibraryInterface::Hxx2::template CWrapper<S>
	{
	public:
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetConstants);
		PRIVATE_MAXON_IMPLEMENTS_HELPER_MEMBER(GetFunctions3);
		static maxon::Bool InitMTablesWithBases(maxon::ClassInfo* info, maxon::Int offset)
		{
			using Super0 = typename LibraryInterface::Hxx2::template CWrapper<S>;
			if (!S::Implementation::PROXY && !(Super0::InitMTablesWithBases(info, offset))) return false;
			auto* vt = (PyModuleInterface::MTable*) maxon::ObjectInterface::PrivateGetOrCreateMTable(info, PyModuleInterface::_interface); if (!vt) return false;
			vt->template Init<CWrapper>(offset);
			return true;
		}
		static Result<void> PyModuleInterface_GetFunctions3(maxon::GenericComponent* this_, BaseArray<NativePyCFunctionTable>& functions) { return ((typename S::Implementation*) this_)->GetFunctions3(functions); }
		static Result<void> PyModuleInterface_GetConstants(maxon::GenericComponent* this_, BaseArray<Tuple<const Char*, Int32>>& constants) { return ((typename S::Implementation*) this_)->GetConstants(constants); }
	};

};
MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return mt_.PyModuleInterface_GetFunctions3((maxon::GenericComponent*) this + mt_.PyModuleInterface_GetFunctions3_Offset, functions);
}
MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	const PyModuleInterface::MTable& mt_ = PRIVATE_MAXON_VTABLE(PyModuleInterface, this); return mt_.PyModuleInterface_GetConstants((maxon::GenericComponent*) this + mt_.PyModuleInterface_GetConstants_Offset, constants);
}

template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::Fn<S>::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions3) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_.PyModuleInterface_GetFunctions3(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetFunctions3_Offset, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::COWFn<S>::GetFunctions3(BaseArray<NativePyCFunctionTable>& functions) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetFunctions3) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_.PyModuleInterface_GetFunctions3(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetFunctions3_Offset, functions));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::Fn<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) const -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::NULLPTR); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_.PyModuleInterface_GetConstants(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetConstants_Offset, constants));
}
template <typename S> MAXON_ATTRIBUTE_FORCE_INLINE auto PyModuleInterface::Hxx1::COWFn<S>::GetConstants(BaseArray<Tuple<const Char*, Int32>>& constants) -> Result<void>
{
	using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND & maxon::VALUEKIND::NEVER_NULLPTR), false, Result<void>>; if (S::HAS_ERROR && this->GetErrorStorage().GetReferencedError()) return ReturnHelper::ReturnErrorOf(this); PyModuleInterface* o_ = (PyModuleInterface*) this->MakeWritable(true).GetPointer(); if (!(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR)) && MAXON_UNLIKELY(!o_)) { return ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::MAKE_WRITABLE_FAILED)); } const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PyModuleInterface, o_, PyModuleInterface_GetConstants) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PyModuleInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PyModuleInterface>() : PRIVATE_MAXON_VTABLE(PyModuleInterface, o_); 
	return (mt_.PyModuleInterface_GetConstants(reinterpret_cast<maxon::GenericComponent*>(o_) + mt_.PyModuleInterface_GetConstants_Offset, constants));
}
auto PyModuleInterface::GetPtr() -> Ptr { return Ptr(this); }
auto PyModuleInterface::GetPtr() const -> ConstPtr { return ConstPtr(this); }
#if defined(MAXON_DEPENDENCY_ENABLE) && !defined(PRIVATE_MAXON_REGISTRATION_UNIT) && !defined(MAXON_DEPENDENCY_DISABLE_cpython)
#ifdef MAXON_USE_REGISTER_FUNCTION
MAXON_STATIC_STORAGE(maxon::EntityUse, s_ui_maxon_PyModuleInterface); \
MAXON_ATTRIBUTE_CONSTRUCTOR static void Register_s_ui_maxon_PyModuleInterface() { new (s_ui_maxon_PyModuleInterface) maxon::EntityUse(PyModuleInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false); }
#else // !MAXON_USE_REGISTER_FUNCTION
static maxon::EntityUse s_ui_maxon_PyModuleInterface(PyModuleInterface::_interface.GetReference(), &maxon::g_translationUnit, "maxon/cpython.h", false);
#endif // MAXON_USE_REGISTER_FUNCTION
#endif
#ifndef MAXON_COMPILER_GCC
#else
#endif
#endif

#ifdef MAXON_COMPILER_GCC
	#pragma GCC diagnostic pop
#endif

#endif

