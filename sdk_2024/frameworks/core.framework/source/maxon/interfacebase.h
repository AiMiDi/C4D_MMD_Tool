#ifndef INTERFACEBASE_H__
#define INTERFACEBASE_H__

#include "maxon/entity.h"
#include "maxon/baseref.h"
#include "maxon/datatypebase.h"
#include "maxon/typename.h"

namespace maxon
{

/// @addtogroup SYSTEM
/// @{


/// @cond INTERNAL

class ClassInterface;
class ClassInfo;

using MTableBase = void;

void* PrivateSystemAlloc(Int size);
void PrivateSystemFree(void*);

//----------------------------------------------------------------------------------------
/// DataTypeInitializer functions are invoked during the initialization of interfaces to initialize their type info objects.
#ifndef MAXON_COMPILER_CLANG	// circumvent clang bug that creates false positives
/// @param[in] info								Pointer to the not-yet initialized DataType object.
/// @param[in] type								Interface identifier.
/// @param[in] impl								The interface implementation info.
/// @param[in] defaultValue					Pointer to a default value of the interface.
#endif
//----------------------------------------------------------------------------------------
using DataTypeInitializer = Result<void>(*)(DataTypeImpl* info, Id&& type, const NonvirtualInterfaceImplementation* impl, const void* defaultValue);


// used internally for the JIT assembly of Unresolved implementations to assemble the correct code depending on the return type
enum class UNRESOLVED_RETURN_TYPE : UChar
{
	VOID_ZERO,									///< void return type.
	VOID_ZERO_FREE_FUNCTION,		///< special case for a Free function.
	INTEGRAL_ZERO,							///< integral/enum/pointer type
	INTEGRAL2X_ZERO,						///< two Int-sized integral/enum/pointer types
	FLOAT_ZERO,									///< Float32
	DOUBLE_ZERO,								///< Float64
	STACK_ZERO,									///< an Int-sized type returned via stack
	POINTER_TO_ZERO,						///< a pointer which shall point to zero bytes (e.g. const Something&)
	RESULT_VOID,								///< Result<void>
	RESULT_INTEGRAL_ZERO,				///< Result<integral/enum/pointer type>
	RESULT_STACK_ZERO,					///< Result<T> where T is STACK_ZERO
	OTHER,											///< Any other type (JIT assembly unsupported).

	MEMBER_FUNCTION_FLAG = 128,	///< The function is a member function (it has a "this" parameter).
	TYPE_MASK = 127,						///< Mask to mask out the MEMBER_FUNCTION flag.
} MAXON_ENUM_FLAGS(UNRESOLVED_RETURN_TYPE);


//----------------------------------------------------------------------------------------
/// NonvirtualInterfaceReference is an EntityReference object which declares a non-virtual interface.
/// It is created by MAXON_INTERFACE_NONVIRTUAL together with code generated by the source processor.
/// @see NonvirtualInterfaceImplementation
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
class NonvirtualInterfaceReference
{
public:
	using MTableInitializer = void(*)(MTableBase*);
	using UnresolvedAssembler = Bool(*)(const NonvirtualInterfaceReference*, const void** table, const UNRESOLVED_RETURN_TYPE* returnTypes, Int count);
	using UnresolvedInitializer = Bool(*)(UnresolvedAssembler init, MTableBase* table);

	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceReference object and adds it to the reference list of the current translation unit.
	/// The MAXON_INTERFACE_REGISTER macro in the register.cpp file of the current module invokes this constructor.
	/// @param[in] iid								Unique interface identifier.
	/// @param[in] mtable							Pointer to the module's MTable for this interface.
	/// @param[in] unresolvedMTable		Pointer to the module's MTable for unresolved functions of this interface.
	/// @param[in] methodIds					Pointer to the module's method id table for this interface.
	/// @param[in] methodCount				Number of methods in the table.
	/// @param[in] initUnresolved			Function to initialize mtable with function pointers of the interface's Unresolved implementation.
	/// @param[in] nullResolve				If non-null, this is invoked to use a null-implementation when no definition for the interface exists. This is non-null only if @MAXON_ANNOTATION{nullimpl=true} is set for the interface.
	/// @param[in] unit								The translation unit containing the reference.
	/// @param[in] refType						The reference type of the interface (one of the REFERENCE flags of EntityBase::FLAGS).
	//----------------------------------------------------------------------------------------
	NonvirtualInterfaceReference(const Char* iid, MTableBase* mtable, MTableBase* unresolvedMTable, const Char* methodIds, Int methodCount, UnresolvedInitializer initUnresolved, MTableInitializer nullResolve, TranslationUnit* unit, EntityBase::FLAGS refType);

	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceReference object and adds it to the reference list of the current translation unit.
	/// The MAXON_INTERFACE_REGISTER macro in the register.cpp file of the current module invokes this constructor.
	/// @param[in] iid								Unique interface identifier.
	/// @param[in] mtable							Pointer to the module's MTable for this interface.
	/// @param[in] unresolvedMTable		Pointer to the module's MTable for unresolved functions of this interface.
	/// @param[in] methodIds					Pointer to the module's method id table for this interface.
	/// @param[in] methodCount				Number of methods in the table.
	/// @param[in] initUnresolved			Function to initialize mtable with function pointers of the interface's Unresolved implementation.
	/// @param[in] unit								The translation unit containing the reference.
	/// @param[in] refType						The reference type of the interface (one of the REFERENCE flags of EntityBase::FLAGS).
	//----------------------------------------------------------------------------------------
	NonvirtualInterfaceReference(const Char* iid, MTableBase* mtable, MTableBase* unresolvedMTable, const Char* methodIds, Int methodCount, UnresolvedInitializer initUnresolved, TranslationUnit* unit, EntityBase::FLAGS refType);

	//----------------------------------------------------------------------------------------
	/// This is invoked by the methods of an interface's Unresolved class to trigger the resolution of the interface.
	/// If the method table can be initialized properly this will return true, and the calling method of the Unresolved class
	/// will forward the invocation to the resolved method. Otherwise, false is returned, and the calling method
	/// will return the appropriate default value.
	//----------------------------------------------------------------------------------------
	static Bool PrivateResolve(NonvirtualInterfaceReference* this_, Bool showMessage);

	//----------------------------------------------------------------------------------------
	/// Returns true if the interface reference has been initialized successfully. This means that the reference has been resolved
	/// to an implementation which itself has been initialized successfully, so that it can be used.
	/// @return												True if reference and corresponding implementation have been initialized successfully.
	//----------------------------------------------------------------------------------------
	Bool IsInitialized() const
	{
		return _super.IsInitialized();
	}

	//----------------------------------------------------------------------------------------
	/// Returns the unique identifier of the interface.
	/// @return												Identifier of the interface.
	//----------------------------------------------------------------------------------------
	const Id& GetId() const
	{
		return _super.GetBase().GetId();
	}

	/// @copydoc EntityBase::GetFlags
	EntityBase::FLAGS GetFlags() const
	{
		return _super.GetBase().GetFlags();
	}

	//----------------------------------------------------------------------------------------
	/// Returns the DataType of this interface. This is only valid after a successful initialization.
	/// @return												Data type of this interface.
	//----------------------------------------------------------------------------------------
	const DataType& GetDataType() const
	{
		return _type;
	}

	//----------------------------------------------------------------------------------------
	/// Returns a const reference to the default value of the reference class. This is only valid after a successful initialization.
	/// @return												Const reference to the default value (to be cast into the reference class).
	//----------------------------------------------------------------------------------------
	const Generic* const& GetDefaultValue() const
	{
		return _defaultValue;
	}

	const Char* GetMethodIds() const
	{
		return _methodIds;
	}

	const MTableBase* GetMTable() const
	{
		return _mtable;
	}

	const EntityReference& GetReference() const
	{
		return _super;
	}

	operator const EntityReference&() const
	{
		return _super;
	}

private:
	EntityReference _super; ///< EntityReference base object.
	MTableBase* _mtable; ///< Pointer to the method table of the current module for the interface.
	MTableBase* _unresolvedMTable; ///< Pointer to the method table for unresolved functions of the current module for the interface.
	const Char* _methodIds; ///< Pointer to the method id table of the current module for the interface.
	Int _methodCount; ///< Number of methods in the method table.
	UnresolvedInitializer _initUnresolved; ///< Initializer to set function pointers of MTable to Unresolved implementations.
	DataType _type; ///< The type of this interface.
	MTableInitializer _nullResolve; ///< If non-null, this is invoked to use a null-implementation when no definition for the interface exists.
	const Generic* _defaultValue; ///< Pointer to the default value of the implementation (may be nullptr).
	friend class ObjectModel;
	friend class NonvirtualInterfaceImplementation;
};


template <typename T> class InterfaceDataTypeFunctions;

template <typename T> struct InterfaceDataTypeFunctionsTrait
{
	using Functions = InterfaceDataTypeFunctions<T>;
	static const Bool REGISTER_TYPE = true;
};

template <typename T, Bool HAS_NONSTATIC = T::MTable::HAS_NONSTATIC> struct PrivateInitInterfaceType
{
	static Result<void> Init(DataTypeImpl* info, Id&& iid, const NonvirtualInterfaceImplementation* impl, const void* defaultValue)
	{
		new (info) DataTypeImpl(std::move(iid), nullptr, nullptr, (T*) defaultValue, (typename InterfaceDataTypeFunctionsTrait<T>::Functions*) nullptr, VALUEKIND::NONE, impl, VALUEKIND::NONVIRTUAL_INTERFACE | VALUEKIND::ABSTRACT);
		if (!InterfaceDataTypeFunctionsTrait<T>::REGISTER_TYPE)
			return OK;
		return info->PrivateRegister();
	}

	static DataTypeInitializer Get() { return &Init; }
};

template <typename T> struct PrivateInitInterfaceType<T, false>
{
	static DataTypeInitializer Get() { return nullptr; }
};

//----------------------------------------------------------------------------------------
/// NonvirtualInterfaceImplementation is an EntityDefinition object which provides the implementation of a non-virtual interface.
/// It is defined by MAXON_IMPLEMENTATION and MAXON_IMPLEMENTATION_REGISTER.
//----------------------------------------------------------------------------------------
class NonvirtualInterfaceImplementation
{
public:
	//----------------------------------------------------------------------------------------
	/// Constructs the NonvirtualInterfaceImplementation object and adds it to the definition list of the current translation unit.
	/// This constructor is used by MAXON_IMPLEMENTATION_REGISTER.
	/// @param[in] dummy							Dummy parameter, this is only needed to determine template parameter C.
	/// @param[in] clsName						Name of the implementation class.
	/// @param[in] ref								Corresponding interface reference of the module of this definition.
	/// @param[in] init								Pointer to a function which initializes the implementation's MTable with the implemented function pointers.
	/// @param[in] flags							Additional entity property flags,
	/// @param[in] unit								The translation unit containing the implementation.
	/// @param[in] file								Source file name.
	/// @tparam C											Implementation class.
	///
	/// @see MAXON_INTERFACE_NONVIRTUAL
	//----------------------------------------------------------------------------------------
	template <typename C>
	NonvirtualInterfaceImplementation(C* dummy, const Char* clsName, const Char* cppName, const NonvirtualInterfaceReference& ref,
		NonvirtualInterfaceReference::MTableInitializer init, EntityBase::FLAGS flags, TranslationUnit* unit, const Char* file)
		: _super(ref._super, unit, file, flags),
			_implementationClass(clsName),
			_initMTable(init),
			_initType(PrivateInitInterfaceType<typename C::Interface>::Get()),
			_type(cppName, unit ? unit->GetModule() : nullptr),
			_initImplementation(&C::_PrivateInitImplementation),
			_freeImplementation(&C::_PrivateFreeImplementation)
	{
	}

	const Generic* GetDefaultValue() const
	{
		return _type.type.GetDefaultValue();
	}

	const DataType& GetDataType() const
	{
		return _typeRef;
	}

private:
	EntityDefinition _super; ///< EntityDefinition base object.

	const Char* const _implementationClass; ///< Name of the implementation class (without namespace prefix).
	NonvirtualInterfaceReference::MTableInitializer const _initMTable; ///< Function to initialize the method table with the function pointers of the implementation.
	DataTypeInitializer _initType; ///< Initializer function for _type.
	DataTypeImpl::Primary _type; ///< Type info for this interface.
	DataType::Primary _typeRef;
	Result<const Generic*> (*_initImplementation) (); ///< This function is invoked to initialize the implementation before it's used the first time.
	void (*_freeImplementation) (); ///< This function is invoked after the last use of the implementation.
	friend class ObjectModel;
};


class ComponentPointerHandler : public PointerHandler
{
};

class SelfPointerHandler : public PointerHandler
{
public:
	static constexpr VALUEKIND KIND = (VALUEKIND::POINTER_FLAGS | VALUEKIND::DEEP_CONSTNESS) & ~VALUEKIND::ZERO_INITIALIZED;
};

class SuperPointerHandler : public SelfPointerHandler
{
};

// This template is used for conversion operators from S to REF. Only if S matches REF regarding
// reference handling, the conversion operators shall exist.
template <typename S, typename S_HANDLER, typename HANDLER, typename REF, Bool CONST_THIS_NONCONST_PTR> struct RefConversionTarget
{
	using type = typename std::conditional<S::DIRECT_REF && STD_IS_REPLACEMENT(same, HANDLER, S_HANDLER), REF, DeleteReturnType01>::type;
};

// The specialization for the self-pointer always allows to convert to REF.
template <typename S, typename HANDLER, typename REF> struct RefConversionTarget<S, SelfPointerHandler, HANDLER, REF, false>
{
	using type = REF;
};

// But for the case of a const self-pointer and a REF which points to a non-const object we must not allow the conversion to REF.
template <typename S, typename HANDLER, typename REF> struct RefConversionTarget<S, SelfPointerHandler, HANDLER, REF, true>
{
	using type = DeleteReturnType01;
};


template <typename T, typename HANDLER, typename REFCLASS> struct DirectRefReferenceClassInfo
{
	using type = REFCLASS;
	using Component = T;

	template <typename TO> using HasBaseDetector = maxon::HasBaseDetector<T, TO>;
};

template <typename T, typename HANDLER> struct DirectRefReferenceClassInfo<T, HANDLER, void>
{
	using type = typename std::conditional<STD_IS_REPLACEMENT(const, T), typename T::ConstPtr, typename T::Ptr>::type;
	using Component = T;

	template <typename TO> using HasBaseDetector = maxon::HasBaseDetector<T, TO>;
};

template <typename T, typename C> struct DirectRefReferenceClassInfo<T, ComponentPointerHandler, C>
{
	using type = typename std::conditional<STD_IS_REPLACEMENT(const, T), typename C::ConstPtr, typename C::Ptr>::type;
	using Component = C;

	template <typename TO> using HasBaseDetector = typename C::template ComponentHasBase<typename std::remove_const<TO>::type>;
};

template <typename T, typename C> struct DirectRefReferenceClassInfo<T, SelfPointerHandler, C>
{
	using type = typename C::SelfPtr;
	using Component = C;

	template <typename TO> using HasBaseDetector = typename C::template ComponentHasBase<typename std::remove_const<TO>::type>;
};

template <typename C, typename BASE> struct SuperPtrComponentInfo;

template <typename T, typename C, typename BASE> struct DirectRefReferenceClassInfo<T, SuperPointerHandler, SuperPtrComponentInfo<C, BASE>>
{
	using type = typename BASE::SelfPtr;
	using Component = C;

	template <typename TO> using HasBaseDetector = typename BASE::template ComponentHasBase<typename std::remove_const<TO>::type>;
};


// used for RefBaseFn
template <typename T, typename HANDLER, typename REFCLASS_INFO> class DirectRef
{
public:
	using Info = DirectRefReferenceClassInfo<T, HANDLER, REFCLASS_INFO>;
	using ReferenceClass = typename Info::type;
	using Component = typename Info::Component;
	using ReferencedType = T;
	using ConstReferencedType = typename ConstIf<T, Bool(HANDLER::KIND & VALUEKIND::DEEP_CONSTNESS)>::type;
	using DirectlyReferencedType = T;
	using Handler = HANDLER;
	using BaseRefType = BaseRef<T, HANDLER>;
	static constexpr Bool DIRECT_REF = true;
	static constexpr Bool HAS_ERROR = false;
	using type = DirectRef;

	template <typename D> using IsGenericBaseOf = std::true_type;

	const ReferenceClass& PrivateGetRefMember() const
	{
		static_assert(ReferenceClass::DIRECT_REF && ReferenceClass::Handler::KIND == HANDLER::KIND
									&& STD_IS_REPLACEMENT(const, ConstReferencedType) <= STD_IS_REPLACEMENT(const, typename ReferenceClass::ReferencedType),
									"Invalid reinterpret_cast.");
		return *reinterpret_cast<const ReferenceClass*>(this);
	}

	ReferenceClass& PrivateGetRefMember()
	{
		static_assert(ReferenceClass::DIRECT_REF && ReferenceClass::Handler::KIND == HANDLER::KIND
									&& STD_IS_REPLACEMENT(const, ReferencedType) <= STD_IS_REPLACEMENT(const, typename ReferenceClass::ReferencedType),
									"Invalid reinterpret_cast.");
		return *reinterpret_cast<ReferenceClass*>(this);
	}

	MAXON_ATTRIBUTE_FORCE_INLINE T* GetPointer() { return *(T**) this; }
	MAXON_ATTRIBUTE_FORCE_INLINE ConstReferencedType* GetPointer() const { return *(T**) this; }
	MAXON_ATTRIBUTE_FORCE_INLINE const BaseRefType& GetBaseRef() const { return *reinterpret_cast<const BaseRefType*>(this); }
	MAXON_ATTRIBUTE_FORCE_INLINE BaseRefType& GetBaseRef() { return *reinterpret_cast<BaseRefType*>(this); }

	template <typename TO> using HasBaseDetector = typename Info::template HasBaseDetector<TO>;

	DirectRef& operator =(std::nullptr_t) { ResetReference(); return *this; }

	MAXON_ATTRIBUTE_FORCE_INLINE const ThreadReferencedError& GetErrorStorage() const
	{
		return *(const ThreadReferencedError*) this;
	}

	static std::nullptr_t GetWrapper()
	{
		return nullptr;
	}

	ResultRef<typename std::remove_const<T>::type> MakeWritable(Bool resetOnError = true)
	{
		return reinterpret_cast<BaseRefType*>(this)->MakeWritable(resetOnError);
	}

	//----------------------------------------------------------------------------------------
	/// Sets the internal pointer to nullptr and returns its previous value. This moves the ownership of the object
	/// from this reference to the invoking code, so you have to take care of proper deallocation once the object
	/// isn't needed any longer.
	///
	/// If this reference is a strong reference, the reference count must be exactly 1 before the call,
	/// otherwise a nullptr will be returned.
	/// @return												The pointer to the previously referenced object.
	//----------------------------------------------------------------------------------------
	T* Disconnect()
	{
		T* o = *(T**) this;
		if (HANDLER::KIND & VALUEKIND::STRONG_MASK && o)
		{
			if (!StrongReferenceCounter::Get(o).Dec())
			{
				o = nullptr;
			}
		}
		*(T**) this = nullptr;
		return o;
	}

	void PrivateSetPointer(T* ptr) { *(T**) this = ptr; }

protected:
	void ResetReference() { *reinterpret_cast<BaseRefType*>(this) = nullptr; }
};

namespace details
{
template <typename REFCLASS> struct RefMemberTypeHelper
{
	using type = REFCLASS&;
};

template <> struct RefMemberTypeHelper<void>
{
	using type = void;
};

template <> struct RefMemberTypeHelper<const void>
{
	using type = void;
};
}

template <typename REF> using RefMemberType = typename maxon::details::RefMemberTypeHelper<typename InheritConst<typename REF::ReferenceClass, REF>::type>::type;

template <typename SUPER> class ReferenceResultBase : public SUPER
{
public:
	using ReferenceClass = typename std::decay<typename SUPER::ValueType>::type;

	using SUPER::SUPER;

	using Handler = typename ReferenceClass::Handler;
	// We don't add a ReferencedType alias here to that a Result<SomeReference> isn't recognized as a reference.
	using PrivateReferencedType = typename ReferenceClass::ReferencedType;
	using PrivateErasedReferencedType = PrivateReferencedType;
	using type = ReferenceResultBase;
	using Component = PrivateReferencedType;
	static constexpr Bool DIRECT_REF = false;
	static void PrivateLookupFn();
	static std::false_type GenericVarianceCheck(const void*);

	ReferenceClass& PrivateGetRefMember()
	{
		return this->GetValue();
	}

	const ReferenceClass& PrivateGetRefMember() const
	{
		return this->GetValue();
	}

	/// @note Required for result chaining.
	static std::nullptr_t GetWrapper()
	{
		return nullptr;
	}

	/// @note Required for result chaining.
	PrivateReferencedType* GetPointer() const
	{
		return this->UncheckedGetValue().GetPointer();
	}

	/// @note Required for result chaining.
	ResultRef<typename std::remove_const<PrivateReferencedType>::type> MakeWritable(Bool resetOnError = true)
	{
		static_assert(MAXON_IS_COW_KIND(Handler::KIND), "MakeWritable must not be invoked for non-COW references.");
		return std::move(this->GetValue()).MakeWritable(resetOnError);
	}
};


namespace details
{
template <typename T> typename SFINAEHelper<std::true_type, decltype(std::declval<T>().IsPopulated())>::type TestForIsPopulatedOrIsEmptyFunction(OverloadRank2);
template <typename T> typename SFINAEHelper<std::true_type, decltype(std::declval<T>().IsEmpty())>::type TestForIsPopulatedOrIsEmptyFunction(OverloadRank1);
template <typename T> std::false_type TestForIsPopulatedOrIsEmptyFunction(OverloadRank0);

template <typename PTR> void CheckPointerType(PTR);
}

//----------------------------------------------------------------------------------------
/// RefBaseFn is used internally as base class for reference classes for interfaces.
/// RefBaseFn itself is just a class without any data members. Its subclasses have to add suitable data members.
/// RefBaseFn uses SUPER as base class, SUPER has to declare the function GetPointer() to obtain the pointer to the referenced object.
/// For example, if you use DirectRef for SUPER, then the reference class stores a pointer as its
/// first member which directly points to the referenced object. But you can also use
/// classes for SUPER which follow several indirections to reach the referenced object.
//----------------------------------------------------------------------------------------
template <typename SUPER> class RefBaseFn : public SUPER
{
public:
	const ThreadReferencedError& GetErrorStorage() const
	{
		return *(const ThreadReferencedError*) this;
	}

	template <typename S> using ResultFunctions = typename ReferenceResultBase<S>::PrivateReferencedType::template ReferenceFunctions<ReferenceResultBase<S>>::type;

	using Handler = typename SUPER::Handler;
	using ReferencedType = typename SUPER::ReferencedType;
	using ConstReferencedType = typename ConstIf<ReferencedType, Bool(Handler::KIND & VALUEKIND::DEEP_CONSTNESS)>::type;
	using PrivateReferencedType = ReferencedType;
	using PrivateErasedReferencedType = ReferencedType;
	using type = RefBaseFn;
	static void PrivateLookupFn();
	static std::false_type GenericVarianceCheck(const void*);
	static const Bool COW = MAXON_IS_COW_KIND(Handler::KIND);

#ifndef _HAS_CPP20_COMPARISONS
	Bool operator ==(const ReferencedType* ptr) const { return RefCompare<COW, true>::IsEqual(this->GetPointer(), ptr); }
	Bool operator !=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::IsEqual(this->GetPointer(), ptr); }
#endif
	Bool operator <(const ReferencedType* ptr) const { return RefCompare<COW, true>::LessThan(this->GetPointer(), ptr); }
	Bool operator >(const ReferencedType* ptr) const { return RefCompare<COW, true>::LessThan(ptr, this->GetPointer()); }
	Bool operator <=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::LessThan(ptr, this->GetPointer()); }
	Bool operator >=(const ReferencedType* ptr) const { return !RefCompare<COW, true>::LessThan(this->GetPointer(), ptr); }

#ifndef _HAS_CPP20_COMPARISONS
	Bool operator ==(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator ==(static_cast<const ReferencedType*>(ptr)); }
	Bool operator !=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator !=(static_cast<const ReferencedType*>(ptr)); }
#endif
	Bool operator <(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator <(static_cast<const ReferencedType*>(ptr)); }
	Bool operator >(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator >(static_cast<const ReferencedType*>(ptr)); }
	Bool operator <=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator <=(static_cast<const ReferencedType*>(ptr)); }
	Bool operator >=(typename std::remove_const<ReferencedType>::type* ptr) const { return this->operator >=(static_cast<const ReferencedType*>(ptr)); }

#ifndef _HAS_CPP20_COMPARISONS
	Bool operator ==(std::nullptr_t) const { return this->operator ==(static_cast<const ReferencedType*>(nullptr)); }
	Bool operator !=(std::nullptr_t) const { return this->operator !=(static_cast<const ReferencedType*>(nullptr)); }
#endif

	HashInt GetHashCode() const { return RefCompare<COW, true>::GetHashCode(this->GetPointer()); }

	UniqueHash GetUniqueHashCode() const { return RefCompare<COW, true>::GetUniqueHashCode(this->GetPointer()); }

	template <typename T, typename = typename std::enable_if<!STD_IS_REPLACEMENT(same, const T, const ObjectInterface) && !STD_IS_REPLACEMENT(same, const T, const ReferencedType)
																													 && SUPER::template HasBaseDetector<T>::value && STD_IS_REPLACEMENT(const, T) >= STD_IS_REPLACEMENT(const, ReferencedType)>::type>
	operator T*() { return reinterpret_cast<T*>(this->GetPointer()); }

	template <typename T, typename = typename std::enable_if<!STD_IS_REPLACEMENT(same, const T, const ObjectInterface) && !STD_IS_REPLACEMENT(same, const T, const ReferencedType)
																													 && SUPER::template HasBaseDetector<T>::value && STD_IS_REPLACEMENT(const, T) >= STD_IS_REPLACEMENT(const, ConstReferencedType)>::type>
	operator T*() const { return reinterpret_cast<T*>(this->GetPointer()); }

	operator ReferencedType*() { return this->GetPointer(); }

	operator ConstReferencedType*() const { return this->GetPointer(); }

	static const Bool DERIVED_FROM_OBJECT = !STD_IS_REPLACEMENT(same, const ObjectInterface, const ReferencedType) && IsVirtualInterfaceType<ReferencedType>::value;

	operator typename std::conditional<DERIVED_FROM_OBJECT, typename InheritConst<ObjectInterface, ReferencedType>::type*, DeleteReturnType01>::type() { return this->GetPointer(); }

	operator typename std::conditional<DERIVED_FROM_OBJECT, typename InheritConst<ObjectInterface, ConstReferencedType>::type*, DeleteReturnType01>::type() const { return this->GetPointer(); }

	explicit operator Bool() const
	{
		static_assert(!(COW && decltype(maxon::details::TestForIsPopulatedOrIsEmptyFunction<typename SUPER::ReferenceClass>(OVERLOAD_MAX_RANK))::value),
									"For a copy-on-write reference with IsPopulated()- or IsEmpty()-function, conversion to Bool is not allowed as it would only check the pointer. You have to use IsPopulated() or IsEmpty().");
		return MAXON_LIKELY(this->GetPointer() != nullptr);
	}

	explicit operator Bool()
	{
		static_assert(!(COW && decltype(maxon::details::TestForIsPopulatedOrIsEmptyFunction<typename SUPER::ReferenceClass>(OVERLOAD_MAX_RANK))::value),
									"For a copy-on-write reference with IsPopulated()- or IsEmpty()-function, conversion to Bool is not allowed as it would only check the pointer. You have to use IsPopulated() or IsEmpty().");
		return MAXON_LIKELY(this->GetPointer() != nullptr);
	}

private:
	operator void*() = delete;
	operator void*() const = delete;
	ReferencedType& operator *() = delete;
	ConstReferencedType& operator *() const = delete;
	ReferencedType* operator ->() = delete;
	ConstReferencedType* operator ->() const = delete;

	// prevent pointer arithmetic on reference class
	void operator +(Int) = delete;
	void operator +(Int) const = delete;
	void operator -(Int) = delete;
	void operator -(Int) const = delete;
	void operator [](Int) = delete;
	void operator [](Int) const = delete;
};

#ifdef _HAS_CPP20_COMPARISONS
template <typename S1, typename S2> inline Bool operator ==(const RefBaseFn<S1>& a, const RefBaseFn<S2>& b)
{
	constexpr Bool S1_IS_BASE = HasBaseDetector<typename S2::ReferencedType, typename S1::ReferencedType>::value;
	constexpr Bool S2_IS_BASE = HasBaseDetector<typename S1::ReferencedType, typename S2::ReferencedType>::value;
	static_assert(S1_IS_BASE || S2_IS_BASE, "Comparison of unrelated reference types.");
	constexpr Bool COW = MAXON_IS_COW_KIND(S1::Handler::KIND);
	static_assert(COW == MAXON_IS_COW_KIND(S2::Handler::KIND), "Comparison of mixed COW/non-COW reference types.");
	using BASE = typename std::conditional<S1_IS_BASE, S1, S2>::type::ReferencedType;
	return RefCompare<COW, true>::template IsEqual(reinterpret_cast<const BASE*>(a.GetPointer()), reinterpret_cast<const BASE*>(b.GetPointer()));
}

template <typename S> inline Bool operator ==(const RefBaseFn<S>& a, std::nullptr_t)
{
	return RefCompare<MAXON_IS_COW_KIND(S::Handler::KIND), true>::template IsEqual(a.GetPointer(), static_cast<const typename S::ReferencedType*>(nullptr));
}
#endif

template <typename S, VALUEKIND PTR_DEEP_ZERO> class ReferenceBaseCtorDtor : public S
{
public:
	using BaseRefType = typename S::BaseRefType;

	ReferenceBaseCtorDtor() : _object(nullptr)
	{
	}

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

	ReferenceBaseCtorDtor(const ReferenceBaseCtorDtor& src)
	{
		static_assert(!(PTR_DEEP_ZERO & VALUEKIND::DEEP_CONSTNESS), "Can't copy a reference with deep constness.");
		new (this) BaseRefType(reinterpret_cast<const BaseRefType&>(src));
	}

	ReferenceBaseCtorDtor& operator =(const ReferenceBaseCtorDtor& src)
	{
		static_assert(!(PTR_DEEP_ZERO & VALUEKIND::DEEP_CONSTNESS), "Can't copy a reference with deep constness.");
		reinterpret_cast<BaseRefType*>(this)->operator =(reinterpret_cast<const BaseRefType&>(src));
		return *this;
	}

	ReferenceBaseCtorDtor(ReferenceBaseCtorDtor&& src) : _object(src._object)
	{
		src._object = nullptr;
	}

	ReferenceBaseCtorDtor& operator =(ReferenceBaseCtorDtor&& src)
	{
		reinterpret_cast<BaseRefType*>(this)->operator =(std::move(reinterpret_cast<BaseRefType&>(src)));
		return *this;
	}

	~ReferenceBaseCtorDtor()
	{
		reinterpret_cast<BaseRefType*>(this)->~BaseRefType();
	}

private:
	union
	{
		typename S::ReferencedType* _object;
		const void* _impl; // The only purpose is for showing values during debugging: For a void pointer some IDEs check for a valid vtable and then use that to visualize the correct run-time type of the pointer.
	};
};


template <typename S> class ReferenceBaseCtorDtor<S, VALUEKIND::POINTER | VALUEKIND::ZERO_INITIALIZED> : public S
{
public:
	ReferenceBaseCtorDtor() : _object(nullptr)
	{
	}

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

private:
	union
	{
		typename S::ReferencedType* _object;
		const void* _impl; // The only purpose is for showing values during debugging: For a void pointer some IDEs check for a valid vtable and then use that to visualize the correct run-time type of the pointer.
	};
};

template <typename S> class ReferenceBaseCtorDtor<S, VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS> : public S
{
public:
	ReferenceBaseCtorDtor() = default;

	explicit ReferenceBaseCtorDtor(ENUM_DONT_INITIALIZE)
	{
	}

	ReferenceBaseCtorDtor(const ReferenceBaseCtorDtor& src) = delete;
	ReferenceBaseCtorDtor& operator =(const ReferenceBaseCtorDtor& src) = delete;

private:
	union
	{
		typename S::ReferencedType* _object;
		const void* _impl; // The only purpose is for showing values during debugging: For a void pointer some IDEs check for a valid vtable and then use that to visualize the correct run-time type of the pointer.
	};
};

template <Bool DELETE, typename SELF, typename T, typename DST, typename SRC, Bool = !STD_IS_REPLACEMENT(base_of, SELF, SRC) && maxon::HasErasedBase<T, typename SELF::ReferencedType>::value> struct ReferenceConversionHelper
{
	static const Bool value = false;
};

template <Bool DELETE, typename SELF, typename T, typename DST, typename SRC> struct ReferenceConversionHelper<DELETE, SELF, T, DST, SRC, true>
{
#ifndef MAXON_COMPILER_MSVC // workaround for MSVC, the test for a valid generic conversion is moved to constructor and assignment operator below
	static const Bool value = DST::template IsGenericBaseOf<SRC>::value != DELETE;
#else
	static const Bool value = true;
#endif
};

template <typename ST> class RefBase : public ReferenceBaseCtorDtor<typename ST::type, ST::type::Handler::KIND & (VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS | VALUEKIND::ZERO_INITIALIZED)>
{
public:
	RefBase() = default;
	RefBase(const RefBase&) = default;
	RefBase& operator =(const RefBase&) = default;
	RefBase(RefBase&&) = default;
	RefBase& operator =(RefBase&&) = default;

	using ReferenceBaseSuper = typename ST::type;
	using Super = ReferenceBaseCtorDtor<ReferenceBaseSuper, ReferenceBaseSuper::Handler::KIND & (VALUEKIND::POINTER | VALUEKIND::DEEP_CONSTNESS | VALUEKIND::ZERO_INITIALIZED)>;
	using ReferencedType = typename ReferenceBaseSuper::ReferencedType;

	MAXON_IMPLICIT RefBase(ReferencedType* ptr) : Super(DONT_INITIALIZE)
	{
		new (this) typename ReferenceBaseSuper::BaseRefType(ptr);
	}

	//----------------------------------------------------------------------------------------
	/// Constructs a reference with a pointer forwarded from a memory allocation. The template
	/// parameter is used to avoid unnecessary conversion from ResultPtr<X> to ResultPtr<const X>.
	//----------------------------------------------------------------------------------------
	template <typename PTR> explicit RefBase(ForwardResultPtr<PTR> ptr) : Super(DONT_INITIALIZE)
	{
		new (this) typename ReferenceBaseSuper::BaseRefType(ptr);
	}

	explicit RefBase(std::nullptr_t) : Super(DONT_INITIALIZE)
	{
		new (this) typename ReferenceBaseSuper::BaseRefType(nullptr);
	}

	template <typename REF, typename = typename std::enable_if<ReferenceConversionHelper<false, RefBase, typename std::decay<REF>::type::ReferencedType, ReferenceBaseSuper, typename std::decay<REF>::type>::value>::type>
	MAXON_IMPLICIT RefBase(REF&& src) : Super(DONT_INITIALIZE)
	{
#ifdef MAXON_COMPILER_MSVC
		static_assert(ReferenceBaseSuper::template IsGenericBaseOf<typename std::decay<REF>::type>::value, "Generic conversion not possible.");
#endif
		new (this) typename ReferenceBaseSuper::BaseRefType(std::forward<REF>(src));
	}

#ifndef MAXON_COMPILER_MSVC
	template <typename REF, typename = typename std::enable_if<ReferenceConversionHelper<true, RefBase, typename std::decay<REF>::type::ReferencedType, ReferenceBaseSuper, typename std::decay<REF>::type>::value>::type, typename = void>
	MAXON_IMPLICIT RefBase(REF&& src) = delete;
#endif

	RefBase& operator =(ReferencedType* ptr)
	{
		reinterpret_cast<typename ReferenceBaseSuper::BaseRefType*>(this)->operator =(ptr);
		return *this;
	}

	template <typename REF, typename = typename std::enable_if<ReferenceConversionHelper<false, RefBase, typename std::decay<REF>::type::ReferencedType, ReferenceBaseSuper, typename std::decay<REF>::type>::value>::type>
	RefBase& operator =(REF&& src)
	{
#ifdef MAXON_COMPILER_MSVC
		static_assert(ReferenceBaseSuper::template IsGenericBaseOf<typename std::decay<REF>::type>::value, "Generic conversion not possible.");
#endif
		reinterpret_cast<typename ReferenceBaseSuper::BaseRefType*>(this)->operator =(std::forward<REF>(src));
		return *this;
	}

#ifndef MAXON_COMPILER_MSVC
	template <typename REF, typename = typename std::enable_if<ReferenceConversionHelper<true, RefBase, typename std::decay<REF>::type::ReferencedType, ReferenceBaseSuper, typename std::decay<REF>::type>::value>::type, typename = void>
	RefBase& operator =(REF&& src) = delete;
#endif

	RefBase& operator =(std::nullptr_t)
	{
		this->ResetReference();
		return *this;
	}

	static MAXON_ATTRIBUTE_FORCE_INLINE const typename ReferenceBaseSuper::ReferenceClass& DefaultValue()
	{
		return GetPtrSizedZeroRef<typename ReferenceBaseSuper::ReferenceClass>();
	}

	ResultRef<typename std::remove_const<ReferencedType>::type> MakeWritable(Bool resetOnError = !maxon::HasBaseDetector<ReferencedType, ErrorInterface>::value)
	{
		return this->GetBaseRef().MakeWritable(resetOnError);
	}
};

#define HXXARG(...) __VA_ARGS__

#define HXXRETURN(a, ...) using ReturnHelper = maxon::ReferenceFunctionErrorReturnHelper<S::HAS_ERROR, maxon::Bool(S::Handler::KIND& maxon::VALUEKIND::NEVER_NULLPTR), a, __VA_ARGS__>
#define HXXRETURN0(...)		HXXRETURN(false, __VA_ARGS__)
#define HXXRETURN1(...)		HXXRETURN(true, __VA_ARGS__)

#define HXXTABLE(fname) const MTable& mt_ = std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value ? PRIVATE_MAXON_SUPERMTABLE(PrivateInterface, o_, fname) : ((S::PrivateReferencedType::INTERFACE_FLAGS & maxon::EntityBase::FLAGS::SINGLE_IMPLEMENTATION) && S::PrivateReferencedType::HasBaseDetector::template Check<PrivateInterface>::value) ? S::PrivateReferencedType::MTable::template GetMTable<PrivateInterface>() : PRIVATE_MAXON_VTABLE(PrivateInterface, o_)

#define HXXPROTECT(classname)	static_assert(std::is_base_of<maxon::SelfPointerHandler, typename S::Handler>::value, "Protected method '" classname "' can only be invoked on self or super.")

#define HXXINVOKE(classname)	static_assert(std::is_base_of<maxon::SelfPointerHandler, typename S::Handler>::value, "Method '" classname "' with refclass=false can only be invoked on self or super.")

#define HXXSUPER(classname)	static_assert(!std::is_same<typename S::Handler, maxon::SuperPointerHandler>::value, "Can't invoke MAXON_FUNCTION '" classname "' on super.");

#define HXXNORES(classname)	static_assert(!S::HAS_ERROR, "'" classname "' can\'t be used on a Result object because it does not return a Result object itself.");

#define HXXRES if (S::HAS_ERROR && MAXON_UNLIKELY(this->GetErrorStorage().GetReferencedError())) return ReturnHelper::ReturnErrorOf(this)

#define HXXCONST(...)	const PrivateInterface* o_ = (const PrivateInterface*)this->GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & (maxon::VALUEKIND::DEEP_CONSTNESS | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { o_ = PrivateInterface::DefaultValuePtr(); if (!o_) return __VA_ARGS__; }

#define HXXNONCONST(addDebugAssert, getPointerFunc, cowMode, ...) PrivateInterface* o_ = (PrivateInterface*)this->getPointerFunc GetPointer(); if (!std::integral_constant<maxon::Bool, maxon::Bool(S::Handler::KIND & ((cowMode ? maxon::VALUEKIND::DEEP_CONSTNESS : maxon::VALUEKIND::NONE) | maxon::VALUEKIND::NEVER_NULLPTR))>::value && MAXON_UNLIKELY(!o_)) { addDebugAssert; return __VA_ARGS__; }

#define HXXRET1(at)			 maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::at)
#define HXXRET2a(at)		 ReturnHelper::Return(this, at)
#define HXXRET2b(at)		 ReturnHelper::Return(this, maxon::PrivateGetNullReturnError(maxon::NULL_RETURN_REASON::at))
#define HXXRET3(at, ...) maxon::PrivateIncompleteNullReturnValue<__VA_ARGS__>(maxon::NULL_RETURN_REASON::at, OVERLOAD_MAX_RANK)
#define HXXADDRET1(...)	 maxon::AddResult<__VA_ARGS__, !(S::Handler::KIND & maxon::VALUEKIND::DEEP_CONSTNESS)>
#define HXXADDRET2(...)	 maxon::AddResult<__VA_ARGS__, S::HAS_ERROR>


template <Bool HAS_ERROR, Bool NEVER_NULLPTR, Bool RETURNS_THIS, typename T> struct ReferenceFunctionErrorReturnHelper;

template <typename T> struct ReferenceFunctionErrorReturnHelper<false, true, false, T>
{
	using ReturnType = T;

	template <typename REF> static T ReturnErrorOf(REF* ref)
	{
		return std::forward<T>(reinterpret_cast<typename std::add_lvalue_reference<T>::type>(g_writableMemory[0]));
	}

	template <typename REF> static T Return(REF* ref, const ThreadReferencedError& err)
	{
		return std::forward<T>(reinterpret_cast<typename std::add_lvalue_reference<T>::type>(g_writableMemory[0]));
	}
};

template <> struct ReferenceFunctionErrorReturnHelper<false, true, false, void>
{
	using ReturnType = void;

	template <typename REF> static void ReturnErrorOf(REF* ref)
	{
	}

	template <typename REF> static void Return(REF* ref, const ThreadReferencedError& err)
	{
	}
};

template <typename T> struct ReferenceFunctionErrorReturnHelper<false, false, false, T>
{
	using ReturnType = T;

	template <typename REF> static T ReturnErrorOf(REF* ref)
	{
		return DefaultValue<T>();
	}

	template <typename REF> static T Return(REF* ref, const ThreadReferencedError& err)
	{
		return DefaultValue<T>();
	}
};

template <typename T> struct ReferenceFunctionErrorReturnHelper<false, false, false, Result<T>>
{
	using ReturnType = Result<T>;

	template <typename REF> static ReturnType ReturnErrorOf(REF* ref)
	{
		return ReturnType();
	}

	template <typename REF> static const ThreadReferencedError& Return(REF* ref, const ThreadReferencedError& err)
	{
		return err;
	}
};

template <typename T> struct ReferenceFunctionErrorReturnHelper<true, false, false, T>
{
	using ReturnType = T;

	template <typename REF> static const ThreadReferencedError& ReturnErrorOf(REF* ref)
	{
		return ref->GetErrorStorage();
	}

	template <typename REF> static const ThreadReferencedError& Return(REF* ref, const ThreadReferencedError& err)
	{
		return err;
	}
};


template <Bool HAS_ERROR, Bool NEVER_NULLPTR, typename T> struct ReferenceFunctionErrorReturnHelper<HAS_ERROR, NEVER_NULLPTR, true, T>
{
	using ReturnType = T;

	template <typename REF> static T ReturnErrorOf(REF* ref)
	{
		return ref->PrivateGetRefMember();
	}

	template <typename REF> static T Return(REF* ref, const ThreadReferencedError& err)
	{
		return ref->PrivateGetRefMember();
	}

	template <typename REF> static T Return(REF* ref, const typename std::decay<T>::type&)
	{
		return ref->PrivateGetRefMember();
	}
};

template <Bool HAS_ERROR, Bool NEVER_NULLPTR, typename T> struct ReferenceFunctionErrorReturnHelper<HAS_ERROR, NEVER_NULLPTR, true, Result<T>>
{
	using ReturnType = Result<T>;

	template <typename REF> static ReturnType ReturnErrorOf(REF* ref)
	{
		return ReturnType(ref->PrivateGetRefMember(), Result<void>(ref->GetErrorStorage()));
	}

	template <typename REF> static ReturnType Return(REF* ref, const ThreadReferencedError& err)
	{
		return ReturnType(ref->PrivateGetRefMember(), Result<void>(err));
	}
};


/// @endcond


//----------------------------------------------------------------------------------------
/// This macro can be used to mark class/struct forward declarations and type aliases which make use of such declarations
/// for the source processor. When a declaration is marked by MAXON_FORWARD the source processor
/// generates slightly different code for interface methods/functions whose return type uses
/// that declaration in order to avoid compilation errors about incomplete types.
///
/// You have to inform the source processor about the header file in which the definition of the
/// forward declaration can be found. This is used for the auto-generated registration files
/// which need the complete definition.
///
/// Example:
/// @code
/// class DataDescriptionDefinition MAXON_FORWARD("maxon/datadescriptiondefinition.h");
/// using LanguageStringDataDescriptionDefinition = HashMap<Id, DataDescriptionDefinition> MAXON_FORWARD("maxon/datadescriptiondefinition.h");
/// @endcode
///
/// @param[in] header							The name of the header file (in quotes) where the type is defined.
//----------------------------------------------------------------------------------------
#define MAXON_FORWARD(header)


//----------------------------------------------------------------------------------------
/// This macro can be used within non-static member functions to statically assert that the given parameter Name
/// matches the surrounding class.
/// @param[in] Name								Unqualified name of the class.
//----------------------------------------------------------------------------------------
#define MAXON_CHECK_CLASS(Name) \
	static_assert(STD_IS_REPLACEMENT(same, const Name, const typename std::remove_pointer<decltype(this)>::type), "Macro parameter " #Name " doesn't match class.")


//----------------------------------------------------------------------------------------
/// Use this macro to mark a member function of an interface as an interface method.
/// For simple virtual interfaces, only non-static member functions can be used as interface methods.
/// Example:
/// @code
/// MAXON_METHOD Int GetLength() const;
/// @endcode
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#ifndef MAXON_TARGET_LINUX
#ifdef MAXON_TARGET_DEBUG
	#define MAXON_METHOD MAXON_ATTRIBUTE_NO_INLINE
#else
	#define MAXON_METHOD
#endif
#else
	#define MAXON_METHOD
#endif
//----------------------------------------------------------------------------------------
/// Use this macro to mark a member function of an interface as a function which shall be added
/// to the reference classes. Unlike MAXON_METHOD, the function invocation will not be routed
/// through the interface; you have to provide a normal C++ function definition.
/// All kinds of interfaces allow both static and non-static functions.
///
/// MAXON_FUNCTION is very useful if you need a function pair of which one function is const and the other non-const,
/// but besides constness they do the same so that a single method suffices:
/// @code
/// MAXON_METHOD const MyElement& GetElement() const;
/// MAXON_FUNCTION MyElement& GetElement() { return MAXON_NONCONST_COUNTERPART(GetElement()); }
/// @endcode
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_FUNCTION


//----------------------------------------------------------------------------------------
/// Use this macro to reserve a slot for a method in the method table of a
/// @ref MAXON_INTERFACE_SIMPLE_VIRTUAL "simple virtual interface". You can later replace
/// MAXON_METHOD_RESERVE by MAXON_METHOD without breaking binary compatibility of the interface.
///
///	@note
///	You can only reserve method slots for simple virtual interfaces. You can't use this for
///	(non-simple) virtual interfaces or non-virtual interfaces.
///
/// @warning
/// When module A has been compiled with a version of the interface which has a reserved slot implements the interface
/// and another module B has been compiled with a version with a true method, and module B calls that method on the implementation of A,
/// a crash will happen because A doesn't provide an implementation of that method.
//----------------------------------------------------------------------------------------
#define MAXON_METHOD_RESERVE



//----------------------------------------------------------------------------------------
/// MAXON_USING can be used within an interface definition (as an equivalent to the regular C++ using)
/// whenever a non-const method inherited from a base interface is hidden in the interface's reference class
/// because the interface declares a method of the same name,
/// and you want to make the inherited method visible again.
/// @code
///	class AInterface : MAXON_INTERFACE_BASES(ObjectInterface)
///	{
///		MAXON_INTERFACE(AInterface, MAXON_REFERENCE_NORMAL, "some.interface.a");
///	public:
///		MAXON_METHOD void DoSomething(Int x);
///	};
///
///	class BInterface : MAXON_INTERFACE_BASES(AInterface)
///	{
///		MAXON_INTERFACE(BInterface, MAXON_REFERENCE_NORMAL, "some.interface.b");
///	public:
///		MAXON_USING(AInterface::DoSomething);
///		MAXON_METHOD void DoSomething(const String& x);
///	};
/// @endcode
/// For const methods you have to use MAXON_USING_CONST.
/// @param[in] ...								The qualified name of an inherited non-const interface method.
//----------------------------------------------------------------------------------------
#define MAXON_USING(...)

//----------------------------------------------------------------------------------------
/// MAXON_USING_CONST can be used within an interface definition (as an equivalent to the regular C++ using)
/// whenever a const method inherited from a base interface is hidden in the interface's reference class
/// because the interface declares a method of the same name,
/// and you want to make the inherited method visible again.
///
/// For non-const methods you have to use MAXON_USING. See there for an example.
/// @param[in] ...								The qualified name of an inherited const interface method.
//----------------------------------------------------------------------------------------
#define MAXON_USING_CONST(...)

#define PRIVATE_MAXON_REMOVE_REFERENCE \
		template <typename FREE, typename CAST> void PrivateRemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::StrongReferenceCounter::Get(this).Dec() == true)) \
				FREE::Free(static_cast<const CAST*>(this)); \
		} \
		friend class maxon::StrongRefHandler; \
		friend class maxon::StrongCOWRefHandler; \
	protected:	\
		MAXON_ATTRIBUTE_FORCE_INLINE void RemoveReference() const \
		{ \
			if (MAXON_UNLIKELY(maxon::StrongReferenceCounter::Get(this).Dec() == true)) \
				Free(this); \
		} \
	private:

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, and that no reference class shall be created for the interface.
/// This can be used for interfaces which shall be accessed
/// through custom-coded wrapper classes which are then also responsible for the proper release of the objects.
/// MAXON_REFERENCE_NONE cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_NONE(FREEIMPL) \
	public: \
		static inline void Free(const void* object) { __debugbreak(); } /* use void pointer so that the interface can add an overload with the interface type */ \
		PRIVATE_MAXON_REMOVE_REFERENCE

#define PRIVATE_MAXON_REFERENCE_NONE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NONE
#define PRIVATE_MAXON_REFERENCE_NONE_COPY(Name) \
	protected: \
		Name() { MAXON_CHECK_CLASS(Name); } \
		~Name() = default; \
	private: \
		void operator =(const volatile Name&); \
		Name(const Name&); \


//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface has
/// only static methods. MAXON_REFERENCE_STATIC can only be used for non-virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_STATIC(FREEIMPL) \
	private:

#define PRIVATE_MAXON_REFERENCE_STATIC_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NONE
#define PRIVATE_MAXON_REFERENCE_STATIC_COPY(Name) private:


//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, but that a reference class shall be created for the interface. The reference
/// class will behave like an ordinary pointer. For the interface design and its usage, one has to
/// take care of the proper release of the objects.
/// MAXON_REFERENCE_POINTER cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_POINTER(FREEIMPL) \
	public: \
		template <typename ST> struct ReferenceFunctions : public maxon::SFINAEHelper<Hxx1, ST>::type::template FnHelper<ST> { }; \
		class Reference; \
		using Ptr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		static inline void Free(const void* object) { __debugbreak(); } /* use void pointer so that the interface can add an overload with the interface type */ \
		PRIVATE_MAXON_REMOVE_REFERENCE

#define PRIVATE_MAXON_REFERENCE_POINTER_FLAGS maxon::EntityBase::FLAGS::REFERENCE_POINTER
#define PRIVATE_MAXON_REFERENCE_POINTER_COPY(Name) PRIVATE_MAXON_REFERENCE_NONE_COPY(Name)

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL to indicate that the interface should not have automatic
/// reference counting, but that a reference class shall be created for the interface. The reference
/// class will behave like an ordinary pointer to a const object. For the interface design and its usage, one has to
/// take care of the proper release of the objects.
/// MAXON_REFERENCE_CONST_POINTER cannot be used for virtual interfaces.
/// @see MAXON_INTERFACE_NONVIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_CONST_POINTER(FREEIMPL) MAXON_REFERENCE_POINTER(FREEIMPL)

#define PRIVATE_MAXON_REFERENCE_CONST_POINTER_FLAGS maxon::EntityBase::FLAGS::REFERENCE_CONST_POINTER
#define PRIVATE_MAXON_REFERENCE_CONST_POINTER_COPY(Name) PRIVATE_MAXON_REFERENCE_NONE_COPY(Name)

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if non-const methods shall operate on the original object
/// instead of making a copy. This is usually used for first-class objects which have an identity
/// rather than just a value. The corresponding reference class is assumed to be the name of the interface
/// with the Interface postfix replaced by Ref (e.g., InputStreamRef for the interface InputStreamInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_NORMAL(FREEIMPL) \
	public: \
		template <typename ST> struct ReferenceFunctions : public maxon::SFINAEHelper<Hxx1, ST>::type::template FnHelper<ST> { }; \
		class Reference; \
		using Ptr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		static inline void Free(const Interface* object) FREEIMPL \
		PRIVATE_MAXON_REMOVE_REFERENCE

#define PRIVATE_MAXON_REFERENCE_NORMAL_FLAGS maxon::EntityBase::FLAGS::REFERENCE_NORMAL
#define PRIVATE_MAXON_REFERENCE_NORMAL_COPY(Name) PRIVATE_MAXON_REFERENCE_NONE_COPY(Name)

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if only const methods of the interface shall be carried over
/// to the reference class. This is usually used for stateless objects which, once initialized,
/// provide their relevant functionality through const methods (e.g., IoHandlerInterface).
/// The corresponding reference class is assumed to be the name of the interface
/// with the Interface postfix removed (e.g., IoHandler for the interface IoHandlerInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_CONST(FREEIMPL) MAXON_REFERENCE_NORMAL(FREEIMPL)

#define PRIVATE_MAXON_REFERENCE_CONST_FLAGS maxon::EntityBase::FLAGS::REFERENCE_CONST
#define PRIVATE_MAXON_REFERENCE_CONST_COPY(Name) PRIVATE_MAXON_REFERENCE_NONE_COPY(Name)

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if the reference class shall have copy-on-write semantics.
/// This means that when a non-const method is invoked through a reference and there are further references,
/// a copy of the original object is made, and the non-const method is invoked on the copy.
/// Thus, the further references aren't affected by potential modifications of the non-const method.
/// This is usually used for value types (second-class objects) where only the value is important such as String.
/// The corresponding reference class is assumed to be the name of the interface
/// without the Interface postfix (e.g., String for the interface StringInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_COPY_ON_WRITE(FREEIMPL) MAXON_REFERENCE_NORMAL(FREEIMPL)

#define PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_COPY_ON_WRITE
#define PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_COPY(Name) static inline Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION); static inline Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, const Interface& o); PRIVATE_MAXON_REFERENCE_NONE_COPY(Name)

//----------------------------------------------------------------------------------------
/// Use this as argument to MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE if the interface shall
/// use automatic reference counting, and if the reference class shall have always-copy-on-write semantics.
/// In contrast to MAXON_REFERENCE_COPY_ON_WRITE, this also makes a copy of the object if there is no other
/// reference to the object, so that non-const methods, invoked through the reference class,
/// will never modify an existing object.
/// In other words: If the refcount == 1 then a call to a set function will always duplicate the object.
/// The corresponding reference class is assumed to be the name of the interface
/// without the Interface postfix (e.g., String for the interface StringInterface).
/// @see MAXON_INTERFACE_NONVIRTUAL
/// @see MAXON_INTERFACE
//----------------------------------------------------------------------------------------
#define MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE(FREEIMPL) MAXON_REFERENCE_NORMAL(FREEIMPL)

#define PRIVATE_MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE_FLAGS maxon::EntityBase::FLAGS::REFERENCE_ALWAYS_COPY_ON_WRITE
#define PRIVATE_MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE_COPY(Name) PRIVATE_MAXON_REFERENCE_COPY_ON_WRITE_COPY(Name)


//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_REFERENCE_CLASS if you want to add further code to the automatically
/// generated non-const reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will not be part
/// of the generated const reference class or of the generated copy-on-write reference class.
/// Example:
/// @code
///	class DataFormatBaseReaderInterface : MAXON_INTERFACE_BASES(DataDictionaryObjectInterface)
///	{
///		MAXON_INTERFACE(DataFormatBaseReaderInterface, MAXON_REFERENCE_NORMAL, "net.maxon.interface.dataformatbasereader");
///
///	public:
///		MAXON_METHOD Result<void> CloseInput();
///
///		MAXON_ADD_TO_REFERENCE_CLASS(
///		Result<void> ResetMaybeCloseInput()
///		{
///			Result<void> res = OK;
///			if (this->GetPointer())
///			{
///				if (System::GetReferenceCounter(this->GetPointer()) == 1)
///					res = this->GetPointer()->CloseInput();
///				this->ResetReference();
///			}
///			return res;
///		}
///		);
///		...
///	};
/// @endcode
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_CONST_REFERENCE_CLASS
/// @see MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_REFERENCE_CLASS(...)

//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS if you want to add further code to the automatically
/// generated copy-on-write reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will not be part
/// of the generated const reference class or of the generated non-const reference class.
/// For an example see MAXON_ADD_TO_REFERENCE_CLASS.
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_REFERENCE_CLASS
/// @see MAXON_ADD_TO_CONST_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS(...)

//----------------------------------------------------------------------------------------
/// Use MAXON_ADD_TO_CONST_REFERENCE_CLASS if you want to add further code to the automatically
/// generated const reference class of an interface. The source processor adds the arguments of the macro
/// to the public part of the generated reference class. The added function will also be part
/// of the generated non-const reference class and the generated copy-on-write reference class.
/// For an example see MAXON_ADD_TO_REFERENCE_CLASS.
///
/// @param[in] ...								Code which shall be added to the generated reference class.
/// @see MAXON_ADD_TO_REFERENCE_CLASS
/// @see MAXON_ADD_TO_COPY_ON_WRITE_REFERENCE_CLASS
//----------------------------------------------------------------------------------------
#define MAXON_ADD_TO_CONST_REFERENCE_CLASS(...)

#define MAXON_ADD_TO_INTERFACE_TEMPLATE_CLASS(...)

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_NONVIRTUAL marks a class declaration as a non-virtual interface declaration. Non-virtual
/// interfaces are used to separate code into a published interface and its internal implementation.
/// The implementation may reside in a different module as code which makes use of the interface,
/// and the whole mechanism is compatible among different compilers.
///
/// @ref nvinterfaces describes the declaration and implementation of non-virtual interfaces in detail.
/// An example is the declaration of StringInterface:
/// @code
/// class Application
/// {
/// 	MAXON_INTERFACE_NONVIRTUAL(Application, MAXON_REFERENCE_NONE, "net.maxon.interface.application");
/// public:
/// 	static MAXON_METHOD Result<Url> GetUrl(APPLICATION_URLTYPE urlType);
/// 	...
/// };
/// @endcode
/// Non-virtual interfaces must not specify a base class unless you use MAXON_INTERFACE_NONVIRTUAL_DERIVED
/// instead of MAXON_INTERFACE_NONVIRTUAL.
/// Non-virtual interfaces have to be implemented by another class using MAXON_IMPLEMENTATION.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_STATIC, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @param[in] ID									The unique identifier of the interface.
/// @see @ref nvinterfaces
/// @see MAXON_METHOD
/// @see MAXON_FUNCTION
/// @see MAXON_INTERFACE_NONVIRTUAL_DERIVED
/// @see MAXON_INTERFACE
///
/// @note It is recommended to use virtual interfaces (MAXON_INTERFACE) instead of non-virtual ones unless
/// the interface consists only of static methods.
///
/// @note The macro itself leaves incomplete code which is completed by the source processor.
/// So you have to place the macro in a header file, because the source processor only scans
/// header files, and you have to include the generated hxx files in the header file.
/// MAXON_INTERFACE_NONVIRTUAL must be placed somewhere before the \#include of the first hxx file.
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_NONVIRTUAL(Name, REFKIND, ID) \
	public: \
		using Interface = Name; \
		using BaseInterface = Name; \
		static maxon::NonvirtualInterfaceReference _interface; \
		struct MTable; \
		struct Hxx1; \
		struct Hxx2; \
		using NonvirtualInterfaceMarker = std::true_type; \
		using IsAllocType = std::true_type; \
		static const Name* DefaultValuePtr() { MAXON_ASSERT_STANDARD_LAYOUT(Name); return (const Name*) _interface.GetDefaultValue(); } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
		static constexpr const maxon::Char* PrivateGetCppName(); \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_COPY(Name) \
		template <typename T> friend void maxon::Destruct(const T* object); \
		REFKIND(;)

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_NONVIRTUAL_DERIVED marks a class declaration as a non-virtual interface declaration
/// which is derived from another such declaration (i.e., either MAXON_INTERFACE_NONVIRTUAL or MAXON_INTERFACE_NONVIRTUAL_DERIVED).
/// You have to use the base interface as base class in the class declaration.
/// The derived interface inherits all methods from its base interface. You cannot use more than
/// one direct base interface. Example:
/// @code
/// class MacroPortInterface : public AttributedObjectInterface
/// {
/// 	MAXON_INTERFACE_NONVIRTUAL_DERIVED(MacroPortInterface, MAXON_REFERENCE_NORMAL, "net.maxon.interface.macroport");
///   ...
/// };
/// @endcode
/// Derived non-virtual interfaces have to be implemented by another class using MAXON_IMPLEMENTATION_DERIVED.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @param[in] ID									The unique identifier of the interface.
/// @see @ref nvinterfaces
/// @see MAXON_INTERFACE_NONVIRTUAL
///
/// @warning As one can act (through an upcasted pointer to the base interface) on the implementation
/// of the derived interface as if it was the implementation of the base interface, the
/// implementation of the derived interface should derive from the implementation of the base interface
/// (at least both have to be compatible).
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_NONVIRTUAL_DERIVED(Name, REFKIND, ID) \
	public: \
		using Interface = Name; \
		static NonvirtualInterfaceReference _interface; \
		struct MTable; \
		struct Hxx1; \
		struct Hxx2; \
		using NonvirtualInterfaceMarker = std::true_type; \
		template <typename ST> struct ReferenceFunctions : public maxon::SFINAEHelper<Hxx1, ST>::type::template FnHelper<ST> { }; \
		class Reference; \
		using Ptr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		static const Name* DefaultValuePtr() { return (const Name*) _interface.GetDefaultValue(); } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
		static constexpr const maxon::Char* PrivateGetCppName(); \
		void RemoveReference() const { PrivateRemoveReference<Name, Name>(); } \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		PRIVATE_##REFKIND##_COPY(Name)

#define _MAXON_IMPLEMENTATION_BASICS(C) \
	public: \
		using MTable = std::false_type; /* for the IsInterfaceType detection */ \
		static C* Get(Interface* object) { return (C*) object; } \
		static const C* Get(const Interface* object) { return (const C*) object; } \
		static const C* GetOrDefaultValue(const Interface* object) { return object ? (const C*) object : _defaultValue; } \
	private: \
		using Implementation = C; \
		template <typename T> friend void maxon::Destruct(const T* object); \
		static maxon::Result<const maxon::Generic*> _PrivateInitImplementation(); \
		static void _PrivateFreeImplementation(); \
		friend class maxon::NonvirtualInterfaceImplementation; \
		friend class maxon::StrongRefHandler; \
		template <typename D, typename B, maxon::Int HAS_BASE_OR_SAME> friend class maxon::details::HasBaseHelper; \
		class _Wrapper; \
		static C* _defaultValue;

#define MAXON_IMPLEMENTATION_BASICS(C, I) \
	public: \
		using Interface = I; \
		using PrivateInterface = I; \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return (Interface*) this; } \
		const Interface* ToInterface() const { return (const Interface*) this; } \
		_MAXON_IMPLEMENTATION_BASICS(C)

#define MAXON_IMPLEMENTATION_NO_ALLOC(C, cast) \
		_MAXON_IMPLEMENTATION_BASICS(C) \
	public: \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return cast<Interface*>(this); } \
		const Interface* ToInterface() const { return cast<const Interface*>(this); } \
		using NonvirtualInterfaceMarker = std::false_type; \
		using IsAllocType = std::false_type; \
		using IsImplementationType = std::true_type; \
		static void Free(const volatile BaseInterface* object) \
		{ \
			maxon::details::PrivateFreeWithDestructor<C>(reinterpret_cast<const C*>(const_cast<const BaseInterface*>(object))); \
		} \
		using BaseInterface::DefaultValuePtr


#define _MAXON_IMPLEMENTATION(C, cast) \
		MAXON_IMPLEMENTATION_NO_ALLOC(C, cast); \
	public: \
		template <typename D> static MAXON_ATTRIBUTE_FORCE_INLINE typename maxon::SFINAEHelper<Interface*, typename D::SourceLocationMarker>::type Alloc(const D& allocLocation) { return cast<Interface*>(MAXON_SAFE_PLACEMENT_NEW (maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD)) typename maxon::SFINAEHelper<C, D>::type); } \
		template <typename A1> static MAXON_ATTRIBUTE_FORCE_INLINE Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, A1&& a1) { return cast<Interface*>(maxon::ObjectConstructor<C, maxon::TestForCopyFromMember<C>::isSupported>::Alloc(maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD), std::forward<A1>(a1))); } \
		template <typename A1, typename A2, typename... ARGS> static MAXON_ATTRIBUTE_FORCE_INLINE Interface* Alloc(MAXON_SOURCE_LOCATION_DECLARATION, A1&& a1, A2&& a2, ARGS&&... args) { return cast<Interface*>(MAXON_SAFE_PLACEMENT_NEW(maxon::DefaultAllocator::Alloc(SIZEOF(C), MAXON_SOURCE_LOCATION_FORWARD)) C(std::forward<A1>(a1), std::forward<A2>(a2), std::forward<ARGS>(args)...)); }


//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION has to be used within an implementation class for a non-virtual interface
/// (declared with MAXON_INTERFACE_NONVIRTUAL). For more details, see @ref nvinterfaces.
/// An example is the implementation of StringInterface by a class XStringImpl:
/// @code
/// class XStringImpl : private StringInterface
/// {
///   MAXON_IMPLEMENTATION(XStringImpl);
/// public:
///   XStringImpl() { }
///   XStringImpl(const XStringImpl& str) { Insert(0, &str); }
///   Int GetLength() const { return _txt.GetCount(); }
///   ...
/// };
/// MAXON_IMPLEMENTATION_REGISTER(XStringImpl);
/// @endcode
/// Don't forget to add MAXON_IMPLEMENTATION_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION(C) \
	public: \
		using PrivateInterface = Interface; \
		_MAXON_IMPLEMENTATION(C, static_cast)
// the PrivateInterface type alias above is needed because C::Interface is inaccessible from the outside when C doesn't inherit publicly from Interface, and a using Interface::Interface doesn't work

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_DERIVED has to be used within an implementation class for a derived non-virtual interface
/// (declared with MAXON_INTERFACE_NONVIRTUAL_DERIVED). The implementation class should derive from the implementation
/// class of the base interface. For more details, see @ref nvinterfaces.
/// An example is the implementation of MacroPortInterface by a class Port (AttributedObject implements
/// the base interface AttributedObjectInterface):
/// @code
/// class Port : public AttributedObject
/// {
/// 	MAXON_IMPLEMENTATION_DERIVED(Port, MacroPortInterface);
/// public:
///   ...
/// };
/// MAXON_IMPLEMENTATION_REGISTER(Port);
/// @endcode
/// Don't forget to add MAXON_IMPLEMENTATION_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @param[in] I									Name of the derived interface which C implements.
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_DERIVED(C, I) \
	public: \
		using Interface = I; \
		using PrivateInterface = I; \
		_MAXON_IMPLEMENTATION(C, reinterpret_cast)

// TODO: (Ole) in the *.dox docu it should be mentioned how return values work (that there needs to be a DefaultValue implementation) and how to add those if you're not using the basic datatypes
// TODO: (Ole) it should be mentioned that in interface headers "Int* bla" works, but "Int *bla" doesn't
// TODO: (Ole) also it should be mentioned that commenting out lines doesn't work in interface headers - however #if 0 / #endif works
// TODO: (Ole) it should also be mentioned that includes in interface headers need to be chosen extremely carefully as otherwise unnecessary or unwanted dependencies are generated; forwards should be used whereever possible

// if an interface implementation has a DefaultValue function, use this
template <typename C> inline typename DefaultValueDetector<C*, &C::DefaultValue>::type ImplementationCreateDefaultValue(OverloadRank3)
{
	return C::DefaultValue();
}

#define COW_KIND_SFINAE typename std::enable_if<MAXON_IS_COW_KIND(C::PrivateInterface::Hxx1::ReferenceClass::Handler::KIND), C*>::type

// otherwise, use a default-constructed object if the interface has a COW reference class
template <typename C> inline COW_KIND_SFINAE ImplementationCreateDefaultValue(OverloadRank2)
{
	static_assert(MAXON_IS_COW_KIND(C::PrivateInterface::Hxx1::ReferenceClass::Handler::KIND), "Compiler bug, non-COW references shouldn't use this overload");
	C* o = (C*) PrivateSystemAlloc(SIZEOF(C));
	if (o)
	{
		new (o) C;
		StrongRefHandler::AddReference(o->ToInterface());
	}
	return o;
}

// otherwise, return nullptr if there is a non-COW reference class
template <typename C> inline typename SFINAEHelper<C*, typename C::PrivateInterface::Hxx1::ReferenceClass::Handler>::type ImplementationCreateDefaultValue(OverloadRank1)
{
	static_assert(!MAXON_IS_COW_KIND(C::PrivateInterface::Hxx1::ReferenceClass::Handler::KIND), "Compiler bug, COW references shouldn't use this overload");
	return nullptr;
}

// otherwise, use nullptr as default value for interfaces without reference class
template <typename C> inline C* ImplementationCreateDefaultValue(OverloadRank0)
{
	return nullptr;
}

// now the same for the proper destruction of the default value
template <typename C> inline typename DefaultValueDetector<C*, &C::DefaultValue>::type ImplementationDestroyDefaultValue(const C*, OverloadRank3)
{
	return nullptr;
}

class PrivateDummyFree
{
public:
	static void Free(const void*) { }
};

template <typename C> inline COW_KIND_SFINAE ImplementationDestroyDefaultValue(const C* o, OverloadRank2)
{
	o->ToInterface()->template PrivateRemoveReference<PrivateDummyFree, const void>();
	o->~C();
	PrivateSystemFree(const_cast<C*>(o));
	return nullptr;
}

template <typename C> inline void ImplementationDestroyDefaultValue(const C*, OverloadRank0)
{
}

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_REGISTER completes the implementation of a non-virtual interface.
/// It has to be used below the declaration of the implementation class (see MAXON_IMPLEMENTATION).
///
/// @param[in] C									Name of the implementation class.
/// @param[in] ...								Additional flags for the NonvirtualInterfaceImplementation such as EntityBase::FLAGS::EXPLICIT.
/// @see @ref nvinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_REGISTER(C, ...) \
	PRIVATE_MAXON_REGISTER_CHECK("MAXON_IMPLEMENTATION_REGISTER"); \
	class C::_Wrapper : public C::Interface::Hxx2::Wrapper<C> \
	{ \
		static maxon::NonvirtualInterfaceImplementation _implementation; \
		friend class ObjectModel; \
	}; \
  maxon::NonvirtualInterfaceImplementation C::_Wrapper::_implementation((C*) nullptr, #C, C::Interface::PrivateGetCppName(), C::Interface::_interface, (maxon::NonvirtualInterfaceReference::MTableInitializer) &maxon::details::InitMTable<typename C::Interface::MTable, typename C::_Wrapper>, C::Interface::REFERENCE_KIND | maxon::EntityBase::FLAGS(__VA_ARGS__), &maxon::g_translationUnit, MAXON_FILE); \
	C* C::_defaultValue; \
	maxon::Result<const maxon::Generic*> C::_PrivateInitImplementation() \
	{ \
		_defaultValue = maxon::ImplementationCreateDefaultValue<C>( OVERLOAD_MAX_RANK); \
		using namespace maxon::defaultimplementation; \
		maxon::Result<void> res = InitImplementation(); \
		if (res == maxon::FAILED) return maxon::Result<const maxon::Generic*>(nullptr, std::move(res)); \
		return (const maxon::Generic*) _defaultValue; \
	} \
	void C::_PrivateFreeImplementation() \
	{ \
		using namespace maxon::defaultimplementation; FreeImplementation(); \
		maxon::ImplementationDestroyDefaultValue<C>(_defaultValue, OVERLOAD_MAX_RANK); \
	}

#define MAXON_IMPLEMENTATION_REGISTER_TEMPLATE(C, ...) \
	PRIVATE_MAXON_REGISTER_CHECK("MAXON_IMPLEMENTATION_REGISTER"); \
	template <> class C::_Wrapper : public C::Interface::Hxx2::Wrapper<C> \
	{ \
		static maxon::NonvirtualInterfaceImplementation _implementation; \
		friend class ObjectModel; \
	}; \
	maxon::NonvirtualInterfaceImplementation				 C::_Wrapper::_implementation((C*)nullptr, #C, C::Interface::PrivateGetCppName(), C::Interface::_interface, (maxon::NonvirtualInterfaceReference::MTableInitializer)&maxon::details::InitMTable<typename C::Interface::MTable, typename C::_Wrapper>, C::Interface::REFERENCE_KIND | maxon::EntityBase::FLAGS(__VA_ARGS__), &maxon::g_translationUnit, MAXON_FILE); \
	template <> C*																	 C::_defaultValue; \
	template <> maxon::Result<const maxon::Generic*> C::_PrivateInitImplementation() \
	{ \
		_defaultValue = maxon::ImplementationCreateDefaultValue<C>(OVERLOAD_MAX_RANK); \
		using namespace maxon::defaultimplementation; \
		maxon::Result<void> res = InitImplementation(); \
		if (res == maxon::FAILED) \
			return maxon::Result<const maxon::Generic*>(nullptr, std::move(res)); \
		return (const maxon::Generic*)_defaultValue; \
	} \
	template <> void C::_PrivateFreeImplementation() \
	{ \
		using namespace maxon::defaultimplementation; \
		FreeImplementation(); \
		maxon::ImplementationDestroyDefaultValue<C>(_defaultValue, OVERLOAD_MAX_RANK); \
	}

struct ClassInfoBase
{
	/// Owning class object. Although just a simple pointer, this acts as a strong reference due to the internals of object handling.
	const ClassInterface* _class;

	/// Destruct&free function.
	void (*_free)(const void*);

	/// The name of the class. It may contain additional characters at the end, use only the first _nameLength characters.
	const Char* _name;

	/// The number of leading characters to use from _name.
	Int _nameLength;

	//----------------------------------------------------------------------------------------
	/// The name of the implementation class. For a true Class this is its identifier.
	/// Otherwise (for an implementation of a simple virtual interface) this is a compiler-generated (and compiler-specific) name.
	/// @return												Name of the class as character block (not necessarily null-terminated).
	//----------------------------------------------------------------------------------------
	const Block<const Char>& GetName() const
	{
		// Block isn't available in this header file, but _name/_nameLength are layout-compatible with Block.
		return reinterpret_cast<const Block<const Char>&>(_name);
	}

	void PrivateInitName(const Char* name);
};

//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_SIMPLE_VIRTUAL marks a class declaration as a simple virtual interface declaration.
/// Unlike true virtual interfaces (MAXON_INTERFACE), simple virtual interfaces only
/// support tree-like inheritance (no multiple inheritance), and they don't support adapters between different versions.
/// They have less overhead for method invocations, so you should use simple virtual interfaces
/// for performance-critical low-level purposes, where the interface is unlikely to change often.
///
/// @ref svinterfaces describes the declaration and implementation of simple virtual interfaces in detail.
/// As an example, consider:
/// @code
/// class SimpleInterface
/// {
/// 	MAXON_INTERFACE_SIMPLE_VIRTUAL(SimpleInterface, MAXON_REFERENCE_NORMAL);
/// public:
/// 	MAXON_METHOD void DoSomething(Int index);
/// };
/// @endcode
/// You can derive from simple virtual interfaces using MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED.
///
/// Simple virtual interfaces can be implemented by several classes.
/// An implementation class has to derive from the interface and to contain MAXON_IMPLEMENTATION_SIMPLE,
/// and in its constructors it has to pass the static @c _clsMTable member declared by MAXON_IMPLEMENTATION_SIMPLE to the constructor
/// of the base interface. Finally you have to use MAXON_IMPLEMENTATION_SIMPLE_REGISTER behind the
/// class declaration to construct the vtable:
/// @code
/// class SimpleImpl : private SimpleInterface
/// {
/// 	MAXON_IMPLEMENTATION_SIMPLE(SimpleImpl);
/// public:
/// 	SimpleImpl() : SimpleInterface(_clsMTable) { }
/// 	void DoSomething(Int index) { }
/// };
///
/// MAXON_IMPLEMENTATION_SIMPLE_REGISTER(SimpleImpl);
/// @endcode
/// Simple virtual interfaces can be class templates (all other kinds of interfaces can't).
/// In this case you have to prefix the registration as in
/// @code
/// template <typename ARRAY> MAXON_IMPLEMENTATION_SIMPLE_REGISTER(ArrayImpl<ARRAY>);
/// @endcode
///
/// Simple virtual interfaces can't have static methods, but they may have static functions
/// (marked with MAXON_FUNCTION).
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @see @ref svinterfaces
/// @see MAXON_METHOD
/// @see MAXON_METHOD_RESERVE
/// @see MAXON_FUNCTION
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED
/// @see MAXON_IMPLEMENTATION_SIMPLE
/// @see MAXON_IMPLEMENTATION_SIMPLE_REGISTER
/// @see MAXON_INTERFACE
///
/// @note The macro itself leaves incomplete code which is completed by the source processor.
/// So you have to place the macro in a header file, because the source processor only scans
/// header files, and you have to include the generated hxx files in the header file.
/// MAXON_INTERFACE_SIMPLE_VIRTUAL must be placed somewhere before the \#include of the first hxx file.
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_SIMPLE_VIRTUAL(Name, REFKIND) \
	public: \
		using Interface = Name; \
		using BaseInterface = Name; \
		struct MTable; \
		using HasBaseDetector = maxon::details::DefaultHasBase<Interface>; \
		struct Hxx1; \
		struct Hxx2; \
		static std::nullptr_t DefaultValuePtr() { return nullptr; } \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
		using IsAllocType = std::true_type; \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		static maxon::InterfaceReference* PrivateGetInterface() { return nullptr; } \
		const maxon::ClassInfoBase* PrivateGetClassInfo() const { return _vtableCls; } \
	protected: \
		inline Name(const MTable& vtable); \
		~Name() { MAXON_CHECK_CLASS(Name); } \
		REFKIND({ object->_vtableCls->_free(object); }) \
	PRIVATE_MAXON_INTERFACE_SIMPLE_VIRTUAL_VTABLE_ACCESS: \
		const maxon::ClassInfoBase* _vtableCls; \
	private: \
		MAXON_DISALLOW_COPY_AND_ASSIGN(Name);

#ifdef MAXON_COMPILER_MSVC
	#define PRIVATE_MAXON_INTERFACE_SIMPLE_VIRTUAL_VTABLE_ACCESS public
#else
	#define PRIVATE_MAXON_INTERFACE_SIMPLE_VIRTUAL_VTABLE_ACCESS protected
#endif


// needed for the array, set and map interfaces
#if defined(MAXON_COMPILER_MSVC) && MAXON_COMPILER_MSVC >= 1914
	#define CPP_853_HACK // MSVC has a bug regarding C++11 8.5.3. GCC < 5.1 had one, see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57610.

	#define CPP_853_HACK_MAXON_INTERFACE_SIMPLE_VIRTUAL(Name, REFKIND) \
		public: \
			using Interface = Name; \
			using BaseInterface = Name; \
			struct MTable; \
			struct Hxx1; \
			struct Hxx2; \
			static std::nullptr_t DefaultValuePtr() { return nullptr; } \
			template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
			using IsAllocType = std::true_type; \
			static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		protected: \
			inline Name(const MTable& vtable); \
			const maxon::ClassInfoBase* _vtableCls; \
			REFKIND({ object->_vtableCls->_free(object); }) \
		private: \
			void operator =(const Name&);
#endif


//----------------------------------------------------------------------------------------
/// MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED marks a class declaration as a simple virtual interface declaration
/// which is derived from another such declaration (i.e., declared with MAXON_INTERFACE_SIMPLE_VIRTUAL
/// or MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED).
/// You have to use the base interface as base class in the class declaration.
/// The derived interface inherits all methods from its base interface. You cannot use more than
/// one direct base interface. Example:
/// @code
/// class DerivedSimpleInterface : private SimpleInterface
/// {
/// 	MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED(DerivedSimpleInterface, MAXON_REFERENCE_NORMAL);
/// public:
/// 	MAXON_METHOD void DoSomethingElse();
/// };
/// @endcode
/// The implementation of a derived simple virtual interface is the same as for a
/// non-derived simple virtual interface.
///
/// @param[in] Name								Name of the interface (has to be the same as the surrounding class name).
/// @param[in] REFKIND						One of MAXON_REFERENCE_NONE, MAXON_REFERENCE_POINTER, MAXON_REFERENCE_CONST_POINTER, MAXON_REFERENCE_NORMAL, MAXON_REFERENCE_CONST, MAXON_REFERENCE_COPY_ON_WRITE, MAXON_REFERENCE_ALWAYS_COPY_ON_WRITE.
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED(Name, REFKIND) \
	public: \
		using Interface = Name; \
		struct MTable; \
		using HasBaseDetector = maxon::details::DefaultHasBase<Interface>; \
		struct Hxx1; \
		struct Hxx2; \
		template <typename ST> struct ReferenceFunctions : public maxon::SFINAEHelper<Hxx1, ST>::type::template FnHelper<ST> { }; \
		class Reference; \
		using Ptr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
		using ConstPtr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
		template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
		static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		static maxon::InterfaceReference* PrivateGetInterface() { return nullptr; } \
	protected: \
		inline Name(const MTable& vtable); \
		~Name() { MAXON_CHECK_CLASS(Name); } \
	private: \
		MAXON_DISALLOW_COPY_AND_ASSIGN(Name);

#ifdef CPP_853_HACK

	#define CPP_853_HACK_MAXON_INTERFACE_SIMPLE_VIRTUAL_DERIVED(Name, REFKIND) \
		public: \
			using Interface = Name; \
			struct MTable; \
			struct Hxx1; \
			struct Hxx2; \
			template <typename ST> struct ReferenceFunctions : public maxon::SFINAEHelper<Hxx1, ST>::type::template FnHelper<ST> { }; \
			class Reference; \
			using Ptr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<Interface, maxon::PointerHandler, void>>>>; \
			using ConstPtr = maxon::RefBase<ReferenceFunctions<maxon::RefBaseFn<maxon::DirectRef<const Interface, maxon::PointerHandler, void>>>>; \
			template <typename DUMMY> static inline maxon::Int PrivateInstantiateDefaultValueHelper(); \
			static const maxon::EntityBase::FLAGS REFERENCE_KIND = PRIVATE_##REFKIND##_FLAGS; \
		protected: \
			inline Name(const MTable& vtable); \
		private: \
			void operator =(const Name&);
#endif

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_SIMPLE has to be used in the implementation of a simple
/// virtual interface. It defines the necessary members for such an implementation.
/// For an example, see MAXON_INTERFACE_SIMPLE_VIRTUAL.
///
/// Don't forget to add MAXON_IMPLEMENTATION_SIMPLE_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_SIMPLE(C) \
	public: \
		using IsAllocType = std::false_type; \
		using MTable = std::false_type; /* for the IsInterfaceType detection */ \
		static void Free(const typename Interface::BaseInterface* o) { maxon::DeleteConstPtrObj(static_cast<const C*>(o)); } \
		using Interface::RemoveReference; \
		static const typename Interface::MTable _clsMTable; \
		Interface* ToInterface() { MAXON_CHECK_CLASS(C); return this; } \
		const Interface* ToInterface() const { return this; } \
		static C* Get(typename Interface::BaseInterface* object) { return (C*) object; } \
		static const C* Get(const typename Interface::BaseInterface* object) { return (const C*) object; } \
		static C* GetOrDefault(typename Interface::BaseInterface* object) { return (object && object->PrivateGetClassInfo() == (reinterpret_cast<const maxon::ClassInfoBase*>((&_clsMTable) + 1) - 1)) ? (C*) object : nullptr; } \
		static const C* GetOrDefault(const typename Interface::BaseInterface* object) { return (object && object->PrivateGetClassInfo() == (reinterpret_cast<const maxon::ClassInfoBase*>((&_clsMTable) + 1) - 1)) ? (const C*) object : nullptr; }

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_SIMPLE_DERIVABLE has to be used in the implementation of a simple
/// virtual interface. It defines the necessary members for such an implementation.
/// For an example, see MAXON_INTERFACE_SIMPLE_VIRTUAL.
///
/// This wrapper macro enables the class to also be derived by other simple interface implementations.
///
/// Don't forget to add MAXON_IMPLEMENTATION_SIMPLE_REGISTER below the implementation class.
///
/// @param[in] C                                    Name of the implementation class (has to be the same as the surrounding class name).
/// @param[in] BASE                                    Name of the class that is being derived from.
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_SIMPLE_DERIVABLE(C, BASE) \
	protected: \
		MAXON_IMPLEMENTATION_SIMPLE(C) \
		explicit C(const Interface::MTable& derivedTable) : BASE(derivedTable) { } \
	private:

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_SIMPLE_FINAL can be used in the implementation of a simple
/// virtual interface that will not be able to be derived from. It defines the necessary members and the default constructor for such an implementation.
/// For an example, see MAXON_INTERFACE_SIMPLE_VIRTUAL.
///
/// Don't forget to add MAXON_IMPLEMENTATION_SIMPLE_REGISTER below the implementation class.
///
/// @param[in] C									Name of the implementation class (has to be the same as the surrounding class name).
/// @param[in] BASE									Name of the base class.
/// @see @ref svinterfaces
/// @see MAXON_INTERFACE_SIMPLE_VIRTUAL
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_SIMPLE_FINAL(C, BASE) \
	protected: \
		MAXON_IMPLEMENTATION_SIMPLE(C) \
	public: \
		C() : BASE(_clsMTable) { } \
	private: 
		

//----------------------------------------------------------------------------------------
/// MAXON_IMPLEMENTATION_SIMPLE_REGISTER completes the implementation of a simple virtual interface.
/// It has to be used below the declaration of the implementation class (see MAXON_INTERFACE_SIMPLE_VIRTUAL).
///
/// @param[in] C									Name of the implementation class.
/// @see @ref svinterfaces
//----------------------------------------------------------------------------------------
#define MAXON_IMPLEMENTATION_SIMPLE_REGISTER(C) \
	const typename C::Interface::MTable C::_clsMTable = typename C::Interface::MTable(static_cast<C*>(nullptr));


#define MAXON_GENERIC(...) PRIVATE_MAXON_GENERIC_A(PRIVATE_MAXON_GENERIC_REMOVE_VARIANCE __VA_ARGS__)
#define MAXON_GENERIC_BASE(...)

#define PRIVATE_MAXON_GENERIC_REMOVE_VARIANCE(...) PRIVATE_MAXON_GENERIC_REMOVE_VARIANCE
#define PRIVATE_PRIVATE_MAXON_GENERIC_REMOVE_VARIANCE

#define PRIVATE_MAXON_GENERIC_A(...) PRIVATE_MAXON_GENERIC_B(__VA_ARGS__)

#ifdef MAXON_COMPILER_INTEL
	#define PRIVATE_MAXON_GENERIC_B(X) PRIVATE_MAXON_GENERIC_C(PRIVATE_##X)
#else
	#define PRIVATE_MAXON_GENERIC_B(...) PRIVATE_MAXON_GENERIC_C(PRIVATE_##__VA_ARGS__)
#endif

#define PRIVATE_MAXON_GENERIC_C(...) PRIVATE_MAXON_GENERIC_D(PRIVATE_MAXON_GENERIC_SWITCH_A(__VA_ARGS__), __VA_ARGS__)
#define PRIVATE_MAXON_GENERIC_D(SWITCH, ...) SWITCH(__VA_ARGS__)

#define PRIVATE_MAXON_GENERIC_SWITCH_A(...) PRIVATE_MAXON_GENERIC_SWITCH_B(PRIVATE_MAXON_GENERIC_TYPENAME_TEST_##__VA_ARGS__)
#define PRIVATE_MAXON_GENERIC_SWITCH_B(...) MAXON_EXPAND(PRIVATE_MAXON_GENERIC_SWITCH_C(__VA_ARGS__))
#define PRIVATE_MAXON_GENERIC_SWITCH_C(X, ...) PRIVATE_MAXON_GENERIC_SWITCH_D(MAXON_VA_NARGS(X))
#define PRIVATE_MAXON_GENERIC_SWITCH_D(N) PRIVATE_MAXON_GENERIC_SWITCH_E(N)
#define PRIVATE_MAXON_GENERIC_SWITCH_E(N) PRIVATE_MAXON_GENERIC_SWITCH_F(N)
#define PRIVATE_MAXON_GENERIC_SWITCH_F(N) PRIVATE_MAXON_GENERIC_SWITCH_##N

#define PRIVATE_MAXON_GENERIC_SWITCH_0(...) MAXON_EXPAND(PRIVATE_MAXON_GENERIC_SWITCH_TYPENAME(__VA_ARGS__))
#define PRIVATE_MAXON_GENERIC_SWITCH_1(...) static constexpr __VA_ARGS__

#define PRIVATE_MAXON_GENERIC_SWITCH_TYPENAME(...) PRIVATE_MAXON_GENERIC_USING_##__VA_ARGS__

#define PRIVATE_MAXON_GENERIC_TYPENAME_TEST_typename ,
#define PRIVATE_MAXON_GENERIC_USING_typename using

namespace details
{

struct DirectInstanceHandler
{
	static constexpr VALUEKIND KIND = VALUEKIND::DEEP_CONSTNESS | VALUEKIND::NEVER_NULLPTR;
};

template <typename REFERENCED, typename ERASED> class DirectInstance : public ERASED
{
public:
	using PrivateReferencedType = REFERENCED;
	using PrivateErasedReferencedType = ERASED;
	static void PrivateLookupFn();
	static std::false_type GenericVarianceCheck(const void*);
	using Handler = DirectInstanceHandler;

	static constexpr Bool DIRECT_REF = false;
	static constexpr Bool HAS_ERROR = false;
	using type = DirectInstance;
	using ReferenceClass = void;

	MAXON_ATTRIBUTE_FORCE_INLINE REFERENCED* GetPointer()
	{
		return static_cast<REFERENCED*>(this);
	}

	MAXON_ATTRIBUTE_FORCE_INLINE const REFERENCED* GetPointer() const
	{
		return static_cast<const REFERENCED*>(this);
	}

	MAXON_ATTRIBUTE_FORCE_INLINE const ThreadReferencedError& GetErrorStorage() const
	{
		return *(const ThreadReferencedError*) this;
	}

	MAXON_ATTRIBUTE_FORCE_INLINE ResultRef<REFERENCED> MakeWritable(Bool resetOnError = true)
	{
		return *static_cast<REFERENCED*>(this);
	}
};

template <typename MTABLE, typename WRAPPER> inline void InitMTable(MTABLE* tbl)
{
	tbl->template Init<WRAPPER>();
}

template <typename T> using GetReferenceClass = typename T::ReferenceClass;
template <typename T> using GetPrivateReferencedType = typename T::PrivateReferencedType;

template <typename T1, typename T2, typename = void> struct HasCommonType
{
	static const Bool value = false;
};

template <typename T1, typename T2> struct HasCommonType<T1, T2, typename SFINAEHelper<void, typename std::common_type<T1, T2>::type>::type>
{
	static const Bool value = true;
};

template <typename T, Bool HAS_ERROR> struct AddResultHelper
{
	using type = T;
};

template <typename T> struct AddResultHelper<T, true>
{
	using type = Result<T>;
};

template <typename T> struct AddResultHelper<ResultOk<T>, true>
{
	using type = Result<T>;
};

template <typename T> struct AddResultHelper<Result<T>, true>
{
	using type = Result<T>;
};

template <> struct AddResultHelper<ResultMemT<Bool>, true>
{
	using type = Result<void>;
};

template <typename T> struct AddResultHelper<ResultMemT<T*>, true>
{
	using type = Result<T*>;
};

template <typename T> struct AddResultHelper<ResultRef<T>, true>
{
	using type = Result<T&>;
};

}

template <typename T, Bool HAS_ERROR> using AddResult = typename maxon::details::AddResultHelper<T, HAS_ERROR>::type;

template <typename TO, typename FROM, Bool SAFE> struct GenericCastMemberTrait<TO, FROM, SAFE, typename SFINAEHelper<void, typename TO::DirectlyReferencedType, typename FROM::DirectlyReferencedType>::type>
{
	static const Bool value = SAFE ? STD_IS_REPLACEMENT(constructible, TO, const FROM&)
		: ((STD_IS_REPLACEMENT(const, typename TO::DirectlyReferencedType) >= STD_IS_REPLACEMENT(const, typename FROM::DirectlyReferencedType))
			 && (maxon::details::HasCommonType<const typename TO::DirectlyReferencedType*, const typename FROM::DirectlyReferencedType*>::value
					 || (STD_IS_REPLACEMENT(base_of, ObjectInterface, typename TO::DirectlyReferencedType) && STD_IS_REPLACEMENT(base_of, ObjectInterface, typename FROM::DirectlyReferencedType))));
};

/// @cond INTERNAL

//----------------------------------------------------------------------------------------
// Default implementation of some basic interface methods.
//----------------------------------------------------------------------------------------
namespace defaultimplementation
{
inline Result<void> InitImplementation() { return OK; }

inline void FreeImplementation() { }
}


// Define some target-ABI-dependent macros to handle (non-static) member functions for method tables.
#ifndef PRIVATE_MAXON_MTABLE_PTMF
  #define PRIVATE_MAXON_MF_POINTER_BASE(NAME, CLS, CONST, RES, ...) \
		MAXON_EXPAND_VA_ARGS RES (*NAME) (CONST CLS*, ##__VA_ARGS__); /* function pointer in method table */ \
		/* NAME_GetPtr<Wrapper<Impl>>(true) is called to get the function pointer and object offset for NAME. */ \
		/* The following overload is used as fallback when there's no better way, it uses the Wrapper function which is known to have exactly matching signature. */ \
		template <typename W> \
		static MAXON_ATTRIBUTE_FORCE_INLINE maxon::Tuple<decltype(NAME), maxon::Int> NAME##_GetPtr(maxon::Int offset, int) { return {&W::NAME, offset}; }

	// For a non-static method the ABI of AMD64 (x64 for Mac/Linux) and the ABI of AArch64 allow a hack:
	// In these ABIs a pointer-to-member-function consists of two Int-sized fields where the first contains the function pointer when the function is non-virtual
	// and the second contains the object offset.
	// Because calling conventions of member functions match those of non-member functions with the "this" argument as first argument, we can use that function pointer
	// as if it was a regular non-member function pointer.
	#ifdef MAXON_TARGET_ABI_SYSTEMV_AMD64
		#define PRIVATE_MAXON_MF_POINTER(NAME, SIMPLENAME, WITHOFFSET, CLS, CONST, RES, ...) \
			PRIVATE_MAXON_MF_POINTER_BASE(NAME, CLS, CONST, RES, ##__VA_ARGS__) \
			template <typename W, typename = decltype(maxon::details::CheckPointerType<MAXON_EXPAND_VA_ARGS RES (W::Implementation::*) (__VA_ARGS__) CONST>(&W::Implementation::SIMPLENAME))> \
			static MAXON_ATTRIBUTE_FORCE_INLINE maxon::Tuple<decltype(NAME), maxon::Int> NAME##_GetPtr(maxon::Int offset, bool) \
			{ \
				MAXON_EXPAND_VA_ARGS RES (W::Implementation::* ptr) (__VA_ARGS__) CONST = &W::Implementation::SIMPLENAME; \
				static_assert(SIZEOF(ptr) == 2 * SIZEOF(maxon::Int)); \
				const maxon::Int* raw = reinterpret_cast<const maxon::Int*>(&ptr); \
				/* Check if there's a regular function pointer in the pointer-to-member-function. We must not have a virtual call. For AMD64 we have to check the lowest bit of the first field. */ \
				return (raw[0] & 1 || (!WITHOFFSET && raw[1] != 0)) ? maxon::Tuple<decltype(NAME), maxon::Int>(&W::NAME, offset) : maxon::Tuple<decltype(NAME), maxon::Int>(reinterpret_cast<decltype(NAME)>(raw[0]), offset + raw[1]); \
			}
	#elif defined(MAXON_TARGET_ABI_AARCH64)
		// Same as MAXON_TARGET_ABI_SYSTEMV_AMD64 but we have to check lowest bit of second field, and shift the second field by one to obtain the offset.
		#define PRIVATE_MAXON_MF_POINTER(NAME, SIMPLENAME, WITHOFFSET, CLS, CONST, RES, ...) \
			PRIVATE_MAXON_MF_POINTER_BASE(NAME, CLS, CONST, RES, ##__VA_ARGS__) \
			template <typename W, typename = decltype(maxon::details::CheckPointerType<MAXON_EXPAND_VA_ARGS RES (W::Implementation::*) (__VA_ARGS__) CONST>(&W::Implementation::SIMPLENAME))> \
			static MAXON_ATTRIBUTE_FORCE_INLINE maxon::Tuple<decltype(NAME), maxon::Int> NAME##_GetPtr(maxon::Int offset, bool) \
			{ \
				MAXON_EXPAND_VA_ARGS RES (W::Implementation::* ptr) (__VA_ARGS__) CONST = &W::Implementation::SIMPLENAME; \
				static_assert(SIZEOF(ptr) == 2 * SIZEOF(maxon::Int)); \
				const maxon::Int* raw = reinterpret_cast<const maxon::Int*>(&ptr); \
				return (raw[1] & 1 || (!WITHOFFSET && raw[1] != 0)) ? maxon::Tuple<decltype(NAME), maxon::Int>(&W::NAME, offset) : maxon::Tuple<decltype(NAME), maxon::Int>(reinterpret_cast<decltype(NAME)>(raw[0]), offset + (raw[1] >> 1)); \
			}
	#else
		// For other ABIs we have the fallback only.
		#define PRIVATE_MAXON_MF_POINTER(NAME, SIMPLENAME, WITHOFFSET, CLS, CONST, RES, ...) \
			PRIVATE_MAXON_MF_POINTER_BASE(NAME, CLS, CONST, RES, ##__VA_ARGS__)
	#endif

	#define PRIVATE_MAXON_MF_WRAPPER(NAME, CLS, CONST, RES, ...) static MAXON_EXPAND_VA_ARGS RES NAME(CONST CLS* this_, ##__VA_ARGS__)
	#define PRIVATE_MAXON_MF_INVOKE(OBJ, FPTR, ...) FPTR(OBJ, ##__VA_ARGS__)
	#define PRIVATE_MAXON_MF_THIS(CLS) this_
	#define PRIVATE_MAXON_MF_REFLECTION_INVOCATION(RES, ...) &maxon::reflection::Invocation<MAXON_EXPAND_VA_ARGS RES, maxon::GenericComponent*, ##__VA_ARGS__>::Invoke
	#define PRIVATE_MAXON_MF_CAST(TYPE, PTR) PTR
#else
	// When PRIVATE_MAXON_MTABLE_PTMF is defined (that's the case for Windows) a different hack is used, in that case a pointer-to-member-function is just a single pointer,
	// and the method tables use PTMFs instead of plain function pointers.
	#define PRIVATE_MAXON_MF_POINTER(NAME, SIMPLENAME, WITHOFFSET, CLS, CONST, RES, ...) \
  	MAXON_EXPAND_VA_ARGS RES (CLS::*NAME) (__VA_ARGS__) CONST; \
	  template <typename W> \
		static MAXON_ATTRIBUTE_FORCE_INLINE maxon::Tuple<decltype(NAME), maxon::Int> NAME##_GetPtr(maxon::Int offset, int) { auto ptr = &W::NAME; return {reinterpret_cast<decltype(NAME)>(ptr), offset}; } \
		/* std::is_polymorphic is used to avoid problematic cases with non-virtual base classes but virtual derived classes. In debug that's not needed because debug versions have a virtual ComponentRoot class. */ \
		template <typename W, MAXON_IF_TARGET_DEBUG(, typename = std::enable_if_t<!std::is_polymorphic<typename W::Implementation>::value> MAXON_COMMA) \
							typename = decltype(maxon::details::CheckPointerType<MAXON_EXPAND_VA_ARGS RES (W::Implementation::*)(__VA_ARGS__) CONST>(&W::Implementation::SIMPLENAME))> \
		static MAXON_ATTRIBUTE_FORCE_INLINE maxon::Tuple<decltype(NAME), maxon::Int> NAME##_GetPtr(maxon::Int offset, bool) \
		{ \
			MAXON_EXPAND_VA_ARGS RES (W::Implementation::* ptr) (__VA_ARGS__) CONST = &W::Implementation::SIMPLENAME; \
			static_assert(SIZEOF(ptr) == SIZEOF(void*)); \
			return {reinterpret_cast<decltype(NAME)>(ptr), offset}; \
		}

	#define PRIVATE_MAXON_MF_WRAPPER(NAME, CLS, CONST, RES, ...) MAXON_EXPAND_VA_ARGS RES NAME(__VA_ARGS__)CONST
	#define PRIVATE_MAXON_MF_INVOKE(OBJ, FPTR, ...) (OBJ->*FPTR)(__VA_ARGS__)
	#define PRIVATE_MAXON_MF_THIS(CLS) reinterpret_cast<CLS*>(this)
	#define PRIVATE_MAXON_MF_REFLECTION_INVOCATION(RES, ...) &maxon::reflection::Invocation<MAXON_EXPAND_VA_ARGS RES, ##__VA_ARGS__>::InvokeMember<maxon::GenericComponent>
	#define PRIVATE_MAXON_MF_CAST(TYPE, PTR) reinterpret_cast<TYPE>(PTR)
#endif

// Now the same for static (non-member) functions.
#define PRIVATE_MAXON_SF_POINTER(NAME, SIMPLENAME, TEST_IMPL, RES, ...) \
	MAXON_EXPAND_VA_ARGS RES (*NAME) (__VA_ARGS__); \
	template <typename W> static MAXON_ATTRIBUTE_FORCE_INLINE decltype(NAME) NAME##_GetPtr(int) { return &W::NAME; } \
	/* For a static method we test if the implementation class has a function with exactly matching signature, then there's no need to use the wrapper function regardless of the ABI. */ \
	TEST_IMPL(template <typename W, typename = decltype(maxon::details::CheckPointerType<decltype(NAME)>(&W::Implementation::SIMPLENAME))> static MAXON_ATTRIBUTE_FORCE_INLINE decltype(NAME) NAME##_GetPtr(bool) { return &W::Implementation::SIMPLENAME; })

/// @endcond

/// @}

} // namespace maxon

#endif // INTERFACEBASE_H__
